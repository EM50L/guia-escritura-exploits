<h1 id="diseccionando-un-binario">Diseccionando un binario</h1>

<h2 id="layout-del-formato-elf-executable-and-linking-format-de-gnulinux">Layout del formato ELF (Executable and Linking Format) de GNU/Linux</h2>
<p>El formato ELF de un binario de GNU/Linux se encuentra organizado en <strong>secciones</strong> que estructuran sus instrucciones, sus datos y otra información necesaria para el <em>linker</em> en el <a href="https://es.wikipedia.org/wiki/Enlazado">proceso de enlazado</a>. Desde la perspectiva del sistema operativo el formato ELF se estructura bajo la forma de <strong>segmentos</strong> que utilizará para cargar en memoria el proceso.</p>

<p>En esta ocasión sólo será importante considerar algunas de las secciones de un archivo ELF, a las que podremos categorizar dentro de dos grandes grupos: por un lado la sección de las instrucciones y por otro las de los datos del programa.</p>

<p><strong>INSTRUCCIONES:</strong></p>
<ol>
  <li><strong>Sección .text</strong>: corresponde a las instrucciones del programa.
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">contenido</span> <span class="n">en</span> <span class="p">.</span><span class="n">text</span> <span class="o">|</span> <span class="n">instrucci</span><span class="err">ó</span><span class="n">n</span>     
<span class="mi">8</span><span class="n">b</span> <span class="mi">03</span>                <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="p">[ebx]</span>
</code></pre></div>    </div>
    <p>Por ejemplo, si el programa cuenta con esta instrucción <code class="highlighter-rouge">mov</code>, en la sección <code class="highlighter-rouge">.text</code> del binario encontraremos el código máquina <code class="highlighter-rouge">0x8b03</code>.</p>
  </li>
</ol>

<p><strong>DATOS:</strong>
Compuesto por tres secciones que corresponden a los datos de un programa:</p>

<ol>
  <li>Sección <strong>.data</strong>: con las variables estáticas y globales inicializadas del proceso.</li>
  <li>Sección <strong>.rodata</strong>: es idéntica a la sección .data pero únicamente para datos de sólo lectura (<em>Read Only data</em>).</li>
  <li>Sección <strong>.bss</strong>: con las variables no inicializadas.</li>
</ol>

<p>Así como las variables <em>estáticas</em> (declaradas como <code class="highlighter-rouge">static</code> o por fuera de una función) se almacenan en la sección <code class="highlighter-rouge">.data</code> y persisten a lo largo de la ejecución del programa, en cambio las variables locales declaradas dentro de una función son consideradas <em>dinámicas</em> en C y se almacenan en la pila como parte del <a href="1-introduccion.md#call-y-convenci%C3%B3n-del-llamado-a-funciones">frame de la función</a>. Por último el <strong>heap</strong> es el área de memoria reservada para el almacenamiento de memoria dinámica, manipulada a través de malloc(), realloc(), free(), etc.</p>

<p>El gráfico a continuación ilustra cómo el sistema operativo carga en memoria el proceso teniendo en cuenta la estructura del ELF definida previamente:</p>

<p><img src="imagenes/teoria2/segmento-data.png" alt="detalle segmento DATA" /></p>

<p>Para ejemplificar el funcionamiento de las secciones en el siguiente programa de ejemplo se indica en qué sección estará cada variable:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//en .data: variable global inicializada</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="c1">//en .bss: variable global no inicializada</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
	<span class="c1">//en la pila: variable local</span>
	<span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span>

	<span class="c1">//en .bss: variable estática no inicializada</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>

	<span class="c1">//en la pila: ptr es un puntero local que apunta a memoria dinámica en el heap</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
	<span class="c1">//en el heap</span>
	<span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>

	<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Es posible ver un detalle de las secciones de un binario con <code class="highlighter-rouge">readelf -S</code>:</p>
<div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> readelf <span class="nt">-S</span> programa
<span class="go">There are 35 section headers, starting at offset 0x1120:

Section Headers:
     [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
     [ 0]                   NULL            00000000 000000 000000 00      0   0  0
     [ 1] .interp           PROGBITS        08048134 000134 000013 00   A  0   0  1
     [ 2] .note.ABI-tag     NOTE            08048148 000148 000020 00   A  0   0  4
     (...)
     [11] .init             PROGBITS        08048294 000294 000023 00  AX  0   0  4
     [12] .plt              PROGBITS        080482c0 0002c0 000040 04  AX  0   0 16
</span><span class="gp"> =&gt;</span>  <span class="o">[</span>13] .text             PROGBITS        08048300 000300 000192 00  AX  0   0 16
<span class="go">     [14] .fini             PROGBITS        08048494 000494 000014 00  AX  0   0  4
</span><span class="gp"> =&gt;</span>  <span class="o">[</span>15] .rodata           PROGBITS        080484a8 0004a8 000008 00   A  0   0  4
<span class="go">     [16] .eh_frame_hdr     PROGBITS        080484b0 0004b0 00002c 00   A  0   0  4
     [17] .eh_frame         PROGBITS        080484dc 0004dc 0000ac 00   A  0   0  4
     [18] .init_array       INIT_ARRAY      08049588 000588 000004 00  WA  0   0  4
     [19] .fini_array       FINI_ARRAY      0804958c 00058c 000004 00  WA  0   0  4
     [20] .jcr              PROGBITS        08049590 000590 000004 00  WA  0   0  4
     [21] .dynamic          DYNAMIC         08049594 000594 0000e8 08  WA  6   0  4
     [22] .got              PROGBITS        0804967c 00067c 000004 04  WA  0   0  4
     [23] .got.plt          PROGBITS        08049680 000680 000018 04  WA  0   0  4
</span><span class="gp"> =&gt;</span>  <span class="o">[</span>24] .data             PROGBITS        08049698 000698 000008 00  WA  0   0  4
<span class="gp"> =&gt;</span>  <span class="o">[</span>25] .bss              NOBITS          080496a0 0006a0 000004 00  WA  0   0  1
<span class="go">     [26] .comment          PROGBITS        00000000 0006a0 000039 01  MS  0   0  1
</span><span class="c">....
</span></code></pre></div></div>
<p>Y con <code class="highlighter-rouge">readelf -l</code> vemos la estructura del ELF desde la perspectiva de los segmentos utilizados por el sistema operativo para cargar el ejecutable en memoria:</p>
<div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> readelf <span class="nt">-l</span> programa
<span class="go">
Elf file type is EXEC (Executable file)
Entry point 0x8048300
There are 8 program headers, starting at offset 52

   Program Headers:
</span><span class="gp">      Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align         ;</span> Segmento   |  Permisos/Flags
<span class="gp">      PHDR           0x000034 0x08048034 0x08048034 0x00100 0x00100 R E 0x4           ;</span>    <span class="c">#00             R E</span>
<span class="gp">      INTERP         0x000134 0x08048134 0x08048134 0x00013 0x00013 R   0x1           ;</span>    <span class="c">#01             R            </span>
<span class="gp">   +-&lt;LOAD           0x000000 0x08048000 0x08048000 0x00588 0x00588 R E 0x1000        ;</span>    <span class="c">#02             R E</span>
<span class="gp"> +-|-&lt;LOAD           0x000588 0x08049588 0x08049588 0x00118 0x0011c RW  0x1000        ;</span>    <span class="c">#03             RW </span>
<span class="gp"> | |  DYNAMIC        0x000594 0x08049594 0x08049594 0x000e8 0x000e8 RW  0x4           ;</span>    <span class="c">#04             RW </span>
<span class="gp"> | |  NOTE           0x000148 0x08048148 0x08048148 0x00044 0x00044 R   0x4           ;</span>    <span class="c">#05             R  </span>
<span class="gp"> | |  GNU_EH_FRAME   0x0004b0 0x080484b0 0x080484b0 0x0002c 0x0002c R   0x4           ;</span>    <span class="c">#06             R  </span>
<span class="gp"> | |  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10          ;</span>    <span class="c">#07             RW </span>
<span class="go"> | |
 | | Section to Segment mapping:
 | |   Segment Sections...
 | |   00     
 | |   01     .interp 
</span><span class="gp"> | +-&gt;</span> 02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini
<span class="go"> |           .rodata .eh_frame_hdr .eh_frame 
</span><span class="gp"> +---&gt;</span> 03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss 
<span class="go">       04     .dynamic 
       05     .note.ABI-tag .note.gnu.build-id 
       06     .eh_frame_hdr 
       07 

</span></code></pre></div></div>
<p>En el ELF se agrupan las secciones <code class="highlighter-rouge">.rodata</code> y <code class="highlighter-rouge">.text</code> -entre otras- en un segmento con permisos de lectura y ejecución (<code class="highlighter-rouge">Flags: R E</code>), y en otro las secciones <code class="highlighter-rouge">.data</code> y <code class="highlighter-rouge">.bss</code> con permisos de lectura y escritura (<code class="highlighter-rouge">Flags: RW</code>).</p>

<p>Otras secciones importantes a la hora de pensar una estrategia de ataque son:</p>

<ol>
  <li>
    <p><strong>Sección .got</strong>: corresponde a la <strong>Global Offset Table</strong>, una tabla en cuyas entradas están las direcciones efectivas de las funciones de bibliotecas compartidas presentes en el programa.</p>
  </li>
  <li>
    <p><strong>Sección .plt</strong>: corresponde a la <strong>Procedure Linkage Table</strong>, otra tabla necesaria para la resolución de las direcciones de funciones de bibliotecas compartidas cuyo rol veremos a continuación.</p>
  </li>
</ol>

<h3 id="global-offset-table-got">Global Offset Table (GOT)</h3>
<p>Dada la relevancia que tendrá en los exploits es importante detenerse en la sección <code class="highlighter-rouge">.got</code> que corresponde a la <em>Global Offset Table</em> o “Tabla global de offsets” en español.</p>

<p>En un binario ELF linkeado dinámicamente (ver en el siguiente apartado), cuando se produce un llamado a una función de una biblioteca compartida se recurre a la tabla GOT para resolverlo. Justamente esta tabla es un listado de punteros donde se indican las direcciones efectivas de esas funciones en tiempo de ejecución.</p>

<p>Por ejemplo podriamos ilustrar la tabla GOT de un programa que llama a <code class="highlighter-rouge">printf()</code> y <code class="highlighter-rouge">exit()</code> de la biblioteca <code class="highlighter-rouge">libc</code> como:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">secci</span><span class="err">ó</span><span class="n">n</span> <span class="p">.</span><span class="n">got</span>

 <span class="o">-----------------------</span> <span class="o">--------------------------</span>
<span class="o">|</span> <span class="n">Nombre</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n</span>  <span class="o">|</span> <span class="n">Direcci</span><span class="err">ó</span><span class="n">n</span> <span class="n">en</span> <span class="n">biblioteca</span>  <span class="o">|</span>
<span class="o">|-----------------------|--------------------------|</span>
<span class="o">|</span> <span class="n">printf</span><span class="p">()</span>              <span class="o">|</span> <span class="mh">0xb7e89d80</span> <span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">)</span>     <span class="o">|</span>
<span class="o">|</span> <span class="n">exit</span><span class="p">()</span>                <span class="o">|</span> <span class="mh">0xb7e561b0</span> <span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">)</span>     <span class="o">|</span> 
</code></pre></div></div>

<h3 id="enlazado-dinámico-de-binarios">Enlazado dinámico de binarios</h3>
<p>El proceso de enlazado para resolver referencias a módulos o a funciones de bibliotecas compartidas se puede resolver a grandes rasgos de dos maneras. Por un lado, incorporando al binario el código de esos módulos o bibliotecas utilizado (enlazado estático), o manteniendo una referencia al código compartido que el sistema operativo se encargará de resolver en tiempo de ejecución (enlazado dinámico). El enlazado dinámico pospone el cálculo de las direcciones de esas funciones hasta que sean efectivamente llamadas en tiempo de ejecución, es decir, el proceso de enlace se produce “a demanda”.</p>

<p>Para evitar que la resolución de estas referencias implique modificar el código de un proceso, se crea una tabla aparte en el binario: la tabla GOT que se ubica en la seccion <code class="highlighter-rouge">.got</code>. Como la dirección de las bibliotecas compartidas es desconocida al momento de compilación, el compilador apunta esas funciones a entradas de la tabla GOT cuya ubicación es conocida y estática. Una vez calculadas sus direcciones efectivas solo será necesario actualizar las entradas de la GOT, sin modificar el código en <code class="highlighter-rouge">.text</code>. Esta estrategia trae enormes ventajas en el manejo de permisos de las secciones de un binario. Esta tabla -y su correspondiente sección- tendrá permisos de escritura (ya que debe actualizarse en tiempo de ejecución) y en cambio la sección de código <code class="highlighter-rouge">.text</code> podrá únicamente tener permisos de lectura y ejecución.</p>

<h4 id="procedure-lookup-table-o-plt"><em>Procedure Lookup Table</em> o PLT</h4>
<p>En muchos casos una función incluida en un programa puede ser llamada o no de acuerdo, por ejemplo, al input de un usuario. Para no llevar a cabo el proceso de enlazado dinámico de todas las funciones externas de un programa, se recurre a una etapa intermedia en la resolución de esas referencias: la tabla PLT o <em>Procedure Lookup Table</em> en inglés.</p>

<p>Cada función de una biblioteca -presente en el programa- tiene una entrada en la tabla PLT. A su vez, cada una de esas entradas apunta a una entrada en la GOT. En tiempo de ejecución se inicia un proceso por el cual se resuelve la dirección efectiva en memoria de la función dentro de la biblioteca. En un primer llamado a la función, se aprovecha una función trampolin dentro de la sección <code class="highlighter-rouge">.plt</code> que invoca al <em>dynamic linker</em>. Este resuelve la dirección de la función en la biblioteca y la ejecuta. También actualiza la entrada en la GOT con la dirección efectiva de la función dentro de la biblioteca compartida para los subsiguientes llamados.</p>

<p>Por ejemplo, en el siguiente programa <code class="highlighter-rouge">imprimir.c</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"you win!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> gcc <span class="nt">-m32</span> <span class="nt">-mpreferred-stack-boundary</span><span class="o">=</span>2 <span class="nt">-o</span> imprimir imprimir.c
</code></pre></div></div>
<ol>
  <li>
    <p>Al compilarlo de esta manera con <code class="highlighter-rouge">gcc</code>, <code class="highlighter-rouge">libc</code> va a estar linkeada dinámicamente al binario, es decir no va a estar incluida en él y por lo tanto -en tiempo de compilación- no se va a conocer la dirección de funciones como <code class="highlighter-rouge">printf()</code> o <code class="highlighter-rouge">exit()</code> contenidas en esa biblioteca.</p>

    <p>Con <code class="highlighter-rouge">ldd</code> vemos las bibliotecas dinámicas enlazadas a este binario y el directorio en el que se encuentran:</p>
    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> ldd imprimir
<span class="go">    linux-gate.so.1 (0xb7ffd000)
</span><span class="gp">=&gt;</span>  libc.so.6 <span class="o">=&gt;</span> /lib/i386-linux-gnu/i686/cmov/libc.so.6 <span class="o">(</span>0xb7e46000<span class="o">)</span>
<span class="go">    /lib/ld-linux.so.2 (0x80000000)
</span></code></pre></div>    </div>
    <p>Y es posible con <code class="highlighter-rouge">objdump</code> ver las direcciones de cada entrada de la tabla GOT:</p>
    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> objdump <span class="nt">--dynamic-reloc</span> imprimir      
<span class="go">   
imprimir:     file format elf32-i386
   
DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE 
080496c8 R_386_JUMP_SLOT   puts
080496d0 R_386_JUMP_SLOT   exit
</span></code></pre></div>    </div>
    <p>Como en casos anteriores la función llamada es <code class="highlighter-rouge">puts()</code> y no <code class="highlighter-rouge">printf()</code> porque se trata de un string fijo, sin parámetros.   <br />
Es posible pensar que en este punto en la tabla GOT aún no está definida la dirección efectiva de las funciones en la biblioteca.</p>
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="o">-----------------</span> <span class="o">-----------------------</span> <span class="o">-------------------------</span>
<span class="o">|</span> <span class="n">Entrada</span> <span class="n">en</span> <span class="p">.</span><span class="n">got</span> <span class="o">|</span> <span class="n">Nombre</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n</span>  <span class="o">|</span> <span class="n">Direcci</span><span class="err">ó</span><span class="n">n</span> <span class="n">en</span> <span class="n">biblioteca</span> <span class="o">|</span>
<span class="o">|-----------------|-----------------------|-------------------------|</span>
<span class="o">|</span> <span class="mi">080496</span><span class="n">c8</span>        <span class="o">|</span> <span class="n">puts</span><span class="p">()</span>                <span class="o">|</span> <span class="o">???</span> <span class="p">(</span><span class="n">no</span> <span class="n">resuelto</span><span class="p">)</span>       <span class="o">|</span>
<span class="o">|</span> <span class="mi">080496</span><span class="n">d0</span>        <span class="o">|</span> <span class="n">exit</span><span class="p">()</span>                <span class="o">|</span> <span class="o">???</span> <span class="p">(</span><span class="n">no</span> <span class="n">resuelto</span><span class="p">)</span>       <span class="o">|</span> 
</code></pre></div>    </div>
  </li>
  <li>Siguiendo con el programa de ejemplo, en el código assembler del llamado a <code class="highlighter-rouge">printf()</code> y a <code class="highlighter-rouge">exit()</code> vemos que el compilador genera dos llamados que apuntan a la tabla PLT: <code class="highlighter-rouge">puts@plt</code> y <code class="highlighter-rouge">exit@plt</code>.
    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> objdump <span class="nt">-M</span> intel <span class="nt">-d</span> imprimir
</code></pre></div>    </div>
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Disassembly</span> <span class="n">of</span> <span class="kr">section</span> <span class="p">.</span><span class="n">text</span><span class="o">:</span>
<span class="mi">0804842</span><span class="n">b</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">&gt;:</span>
     <span class="mi">804842</span><span class="n">b</span><span class="o">:</span> <span class="mi">55</span>                    <span class="k">push</span>   <span class="n">ebp</span>
     <span class="mi">804842</span><span class="n">c</span><span class="o">:</span> <span class="mi">89</span> <span class="n">e5</span>                 <span class="k">mov</span>    <span class="n">ebp</span><span class="p">,</span><span class="n">esp</span>
     <span class="mi">804842</span><span class="n">e</span><span class="o">:</span> <span class="mi">68</span> <span class="n">e0</span> <span class="mi">84</span> <span class="mi">04</span> <span class="mi">08</span>        <span class="k">push</span>   <span class="mh">0x80484e0</span>
  <span class="o">=&gt;</span> <span class="mi">8048433</span><span class="o">:</span> <span class="n">e8</span> <span class="n">b8</span> <span class="n">fe</span> <span class="n">ff</span> <span class="n">ff</span>        <span class="k">call</span>   <span class="mi">80482</span><span class="n">f0</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;</span>   <span class="c">; llamado a puts@plt en .plt</span>
     <span class="mi">8048438</span><span class="o">:</span> <span class="mi">83</span> <span class="n">c4</span> <span class="mi">04</span>              <span class="k">add</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0x4</span>
     <span class="mi">804843</span><span class="n">b</span><span class="o">:</span> <span class="mi">6</span><span class="n">a</span> <span class="mi">00</span>                 <span class="k">push</span>   <span class="mh">0x0</span>
  <span class="o">=&gt;</span> <span class="mi">804843</span><span class="n">d</span><span class="o">:</span> <span class="n">e8</span> <span class="n">ce</span> <span class="n">fe</span> <span class="n">ff</span> <span class="n">ff</span>        <span class="k">call</span>   <span class="mi">8048310</span> <span class="o">&lt;</span><span class="n">exit</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;</span>   <span class="c">; llamado a exit@plt en .plt</span>
</code></pre></div>    </div>
    <p>Si seguimos las direcciones de los respectivos <code class="highlighter-rouge">call</code> vemos que se produce un salto a la sección <code class="highlighter-rouge">.plt</code>.</p>
  </li>
  <li>Analizamos la sección <code class="highlighter-rouge">.plt</code> buscando las direcciones <code class="highlighter-rouge">80482f0 &lt;puts@plt&gt;</code> y <code class="highlighter-rouge">8048310 &lt;exit@plt&gt;</code>:
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span><span class="err">@</span><span class="n">abos</span><span class="o">:~</span><span class="err">$</span> <span class="n">objdump</span> <span class="o">-</span><span class="n">M</span> <span class="n">intel</span> <span class="o">-</span><span class="n">d</span> <span class="n">imprimir</span>

<span class="n">Disassembly</span> <span class="n">of</span> <span class="kr">section</span> <span class="p">.</span><span class="n">plt</span><span class="o">:</span>
   
<span class="mi">080482</span><span class="n">f0</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;:</span>
  <span class="o">=&gt;</span> <span class="mi">80482</span><span class="n">f0</span><span class="o">:</span> <span class="n">ff</span> <span class="mi">25</span> <span class="n">c8</span> <span class="mi">96</span> <span class="mi">04</span> <span class="mi">08</span>     <span class="k">jmp</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="n">ds</span><span class="o">:</span><span class="mh">0x80496c8</span>   <span class="c">; jmp &lt;puts@GOT&gt;</span>
     <span class="mi">80482</span><span class="n">f6</span><span class="o">:</span> <span class="mi">68</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>        <span class="k">push</span>   <span class="mh">0x0</span>
     <span class="mi">80482</span><span class="n">fb</span><span class="o">:</span> <span class="n">e9</span> <span class="n">e0</span> <span class="n">ff</span> <span class="n">ff</span> <span class="n">ff</span>        <span class="k">jmp</span>    <span class="mi">80482</span><span class="n">e0</span> <span class="o">&lt;</span><span class="n">_init</span><span class="o">+</span><span class="mh">0x30</span><span class="o">&gt;</span>
   
<span class="mi">08048310</span> <span class="o">&lt;</span><span class="n">exit</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;:</span>
  <span class="o">=&gt;</span> <span class="mi">8048310</span><span class="o">:</span> <span class="n">ff</span> <span class="mi">25</span> <span class="n">d0</span> <span class="mi">96</span> <span class="mi">04</span> <span class="mi">08</span>     <span class="k">jmp</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="n">ds</span><span class="o">:</span><span class="mh">0x80496d0</span>   <span class="c">; jmp &lt;exit@GOT&gt;</span>
     <span class="mi">8048316</span><span class="o">:</span> <span class="mi">68</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>        <span class="k">push</span>   <span class="mh">0x10</span>
     <span class="mi">804831</span><span class="n">b</span><span class="o">:</span> <span class="n">e9</span> <span class="n">c0</span> <span class="n">ff</span> <span class="n">ff</span> <span class="n">ff</span>        <span class="k">jmp</span>    <span class="mi">80482</span><span class="n">e0</span> <span class="o">&lt;</span><span class="n">_init</span><span class="o">+</span><span class="mh">0x30</span><span class="o">&gt;</span>
</code></pre></div>    </div>
    <p>En ambos casos, la primer instrucción es un salto dentro del segmento de datos (<code class="highlighter-rouge">ds:</code>) y si miramos detenidamente las direcciones del salto corresponden a las direcciones de cada entrada en la GOT que vimos con <code class="highlighter-rouge">objdump --dynamic-reloc</code>.   <br />
Son entonces dos saltos que apuntan a entradas de la tabla GOT: <code class="highlighter-rouge">jmp puts@GOT</code> (<code class="highlighter-rouge">jmp ds:0x80496c8</code>) y el segundo <code class="highlighter-rouge">jmp &lt;exit@GOT&gt;</code> (<code class="highlighter-rouge">jmp ds:0x80496d0</code>). Corroboramos que efectivamente esas direcciones a dónde se salta corresponden a la tabla GOT, es decir, en este caso pertenecen a la sección <code class="highlighter-rouge">.got.plt</code>.</p>
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span><span class="err">@</span><span class="n">abos</span><span class="o">:~</span><span class="err">$</span> <span class="n">objdump</span> <span class="o">-</span><span class="n">s</span> <span class="n">imprimir</span>

<span class="n">Contents</span> <span class="n">of</span> <span class="kr">section</span> <span class="p">.</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">:</span>     
 <span class="mi">80496</span><span class="n">bc</span> <span class="n">d0950408</span> <span class="mi">00000000</span> <span class="mi">00000000</span> <span class="n">f6820408</span>  <span class="p">................</span>
 <span class="mi">80496</span><span class="n">cc</span> <span class="mi">06830408</span> <span class="mi">16830408</span> <span class="mi">26830408</span>    <span class="err">^</span>       <span class="p">........</span><span class="o">&amp;</span><span class="p">...</span>   
 <span class="c">;                   ^                 |</span>
 <span class="c">;                   |                 | </span>
 <span class="c">;                   |        0x80496c8: 0804286f en little endian</span>
 <span class="c">;          0x80496d0: 08043816  en little endian</span>
</code></pre></div>    </div>
    <p>En la primer columna <code class="highlighter-rouge">objdump</code> nos muestra las direcciones correspondientes a la sección <code class="highlighter-rouge">.got.plt</code>, en las siguientes cuatro columnas sus valores en hexa y en la última su representación en ASCII (se indica un punto en el caso de ser caracteres no imprimibles).    <br />
Efectivamente ambos saltos apuntan a la sección .got (o lo que es lo mismo a <code class="highlighter-rouge">.got.plt</code>). Por comodidad graficamos el contenido de la sección <code class="highlighter-rouge">.got.plt</code> que nos mostró <code class="highlighter-rouge">objdump -s</code> de la siguiente manera:</p>
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="o">-----------------</span> <span class="o">-----------------------</span> <span class="o">---------------------------</span>
<span class="o">|</span> <span class="n">Entrada</span> <span class="n">en</span> <span class="p">.</span><span class="n">got</span> <span class="o">|</span> <span class="n">Nombre</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n</span>  <span class="o">|</span> <span class="n">Direcci</span><span class="err">ó</span><span class="n">n</span> <span class="n">en</span> <span class="err">¿</span><span class="n">biblioteca</span><span class="o">?</span> <span class="o">|</span>
<span class="o">|-----------------|-----------------------|---------------------------|</span>
<span class="o">|</span> <span class="mi">080496</span><span class="n">c8</span>        <span class="o">|</span> <span class="n">printf</span><span class="p">()</span>              <span class="o">|</span> <span class="mh">0x080482f6</span> <span class="p">(</span><span class="n">secci</span><span class="err">ó</span><span class="n">n</span> <span class="p">.</span><span class="n">plt</span><span class="p">)</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">080496</span><span class="n">d0</span>        <span class="o">|</span> <span class="n">exit</span><span class="p">()</span>                <span class="o">|</span> <span class="mh">0x08048316</span> <span class="p">(</span><span class="n">secci</span><span class="err">ó</span><span class="n">n</span> <span class="p">.</span><span class="n">plt</span><span class="p">)</span> <span class="o">|</span> 
</code></pre></div>    </div>

    <p>En este punto, viendo el output anterior de <code class="highlighter-rouge">objdump -s</code> nos damos cuenta que aún la tabla GOT no tiene las direcciones efectivas de las funciones sino que almacena direcciones que apuntan nuevamente a la sección <code class="highlighter-rouge">.plt</code>.   <br />
Es posible corroborarlo viendo el contenido de la dirección <code class="highlighter-rouge">0x080482f6</code> en el caso de <code class="highlighter-rouge">printf()</code> y de <code class="highlighter-rouge">0x08048316</code> en el caso de <code class="highlighter-rouge">exit()</code>:</p>
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span><span class="err">@</span><span class="n">abos</span><span class="o">:~</span><span class="err">$</span> <span class="n">objdump</span> <span class="o">-</span><span class="n">M</span> <span class="n">intel</span> <span class="o">-</span><span class="n">d</span> <span class="n">imprimir</span>

<span class="n">Disassembly</span> <span class="n">of</span> <span class="kr">section</span> <span class="p">.</span><span class="n">plt</span><span class="o">:</span>
   
<span class="mi">080482</span><span class="n">f0</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;:</span>
     <span class="mi">80482</span><span class="n">f0</span><span class="o">:</span> <span class="n">ff</span> <span class="mi">25</span> <span class="n">c8</span> <span class="mi">96</span> <span class="mi">04</span> <span class="mi">08</span>     <span class="k">jmp</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="n">ds</span><span class="o">:</span><span class="mh">0x80496c8</span>   <span class="c">; jmp &lt;puts@GOT&gt;</span>
  <span class="o">=&gt;</span> <span class="mi">80482</span><span class="n">f6</span><span class="o">:</span> <span class="mi">68</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>        <span class="k">push</span>   <span class="mh">0x0</span>                      <span class="c">; addr 0x080482f6</span>
     <span class="mi">80482</span><span class="n">fb</span><span class="o">:</span> <span class="n">e9</span> <span class="n">e0</span> <span class="n">ff</span> <span class="n">ff</span> <span class="n">ff</span>        <span class="k">jmp</span>    <span class="mi">80482</span><span class="n">e0</span> <span class="o">&lt;</span><span class="n">_init</span><span class="o">+</span><span class="mh">0x30</span><span class="o">&gt;</span>
   
<span class="mi">08048310</span> <span class="o">&lt;</span><span class="n">exit</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;:</span>
     <span class="mi">8048310</span><span class="o">:</span> <span class="n">ff</span> <span class="mi">25</span> <span class="n">d0</span> <span class="mi">96</span> <span class="mi">04</span> <span class="mi">08</span>     <span class="k">jmp</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="n">ds</span><span class="o">:</span><span class="mh">0x80496d0</span>   <span class="c">; jmp &lt;exit@GOT&gt;</span>
  <span class="o">=&gt;</span> <span class="mi">8048316</span><span class="o">:</span> <span class="mi">68</span> <span class="mi">10</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>        <span class="k">push</span>   <span class="mh">0x10</span>                     <span class="c">; addr 0x08048316</span>
     <span class="mi">804831</span><span class="n">b</span><span class="o">:</span> <span class="n">e9</span> <span class="n">c0</span> <span class="n">ff</span> <span class="n">ff</span> <span class="n">ff</span>        <span class="k">jmp</span>    <span class="mi">80482</span><span class="n">e0</span> <span class="o">&lt;</span><span class="n">_init</span><span class="o">+</span><span class="mh">0x30</span><span class="o">&gt;</span>
</code></pre></div>    </div>
    <p>En ambas entradas de la GOT se apunta a una instrucción dentro de <code class="highlighter-rouge">.plt</code> que hace <code class="highlighter-rouge">push</code> de un valor y un salto a la misma dirección de memoria (<code class="highlighter-rouge">jmp 80482e0</code>). Como se verá a continuación, en ambos casos, se produce un salto a una función trampolín dentro de <code class="highlighter-rouge">.plt</code>.</p>

    <p><strong>¿Por qué las entradas en la GOT apuntan a la sección <code class="highlighter-rouge">.plt</code> nuevamente?</strong>  <br />
En un primer llamado a una función de una biblioteca compartida, en la entrada de la GOT correspondiente se apunta a un sector de la tabla PLT que hace un llamado a una función trampolín. Esa función se encarga de transferirle el control al <em>dynamic linker</em>. Este es el encargado de hacer un llamado a la función invocada y después actualizar la entrada en la GOT con su dirección efectiva en la biblioteca correspondiente.    <br />
A partir de entonces la entrada en la GOT se encuentra actualizada, y ya no apuntará a la función trampolín dentro de <code class="highlighter-rouge">.plt</code> sino directamente a una dirección en una biblioteca compartida.</p>

    <p>En el ejemplo, el llamado al <em>linker</em> sucede con el <code class="highlighter-rouge">jmp 80482e0</code> que es un salto a una función trampolin también dentro de la sección <code class="highlighter-rouge">.plt</code> que invoca al <em>dynamic linker</em>. Este será el encargado de actualizar la GOT, es decir, reemplazar las direcciones <code class="highlighter-rouge">0x080482f6</code> en el caso de <code class="highlighter-rouge">printf()</code> y <code class="highlighter-rouge">0x08048316</code> en el caso de <code class="highlighter-rouge">exit()</code> por sus direcciones efectivas en la <code class="highlighter-rouge">libc.so</code> cargada en memoria.</p>

    <p>Es posible ver estos cambios si consultamos el contenido de la GOT después de ejecutar por primera vez cada una de las funciones:</p>
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="mh">0x0804842c</span> <span class="n">main</span><span class="o">+</span><span class="mi">1</span>  <span class="k">mov</span>    <span class="n">ebp</span><span class="p">,</span><span class="n">esp</span>
      <span class="mh">0x0804842e</span> <span class="n">main</span><span class="o">+</span><span class="mi">3</span>  <span class="k">push</span>   <span class="mh">0x80484e0</span>
      <span class="mh">0x08048433</span> <span class="n">main</span><span class="o">+</span><span class="mi">8</span>  <span class="k">call</span>   <span class="mh">0x80482f0</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;</span>
<span class="n">eip</span><span class="o">=&gt;</span> <span class="mh">0x08048438</span> <span class="n">main</span><span class="o">+</span><span class="mi">13</span> <span class="k">add</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0x4</span>              <span class="c">; 1er instrucción después de ejecutar printf()</span>
      <span class="mh">0x0804843b</span> <span class="n">main</span><span class="o">+</span><span class="mi">16</span> <span class="k">push</span>   <span class="mh">0x0</span>
      <span class="mh">0x0804843d</span> <span class="n">main</span><span class="o">+</span><span class="mi">18</span> <span class="k">call</span>   <span class="mh">0x8048310</span> <span class="o">&lt;</span><span class="n">exit</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;</span>
   <span class="err">───────────────────────────────────────────────────────────────────────────────────────────────</span>
   <span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">/</span><span class="n">xw</span> <span class="mh">0x80496c8</span>                                <span class="c">; consultamos la entrada de printf() en la GOT:</span>
   <span class="mh">0x80496c8</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">&gt;:</span> <span class="mh">0xb7e89d80</span>              <span class="c">; la entrada de printf() se actualizó</span>
   <span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">/</span><span class="n">xw</span> <span class="mh">0x80496d0</span>                                <span class="c">; consultamos la entrada de exit() en la GOT:</span>
   <span class="mh">0x80496d0</span> <span class="o">&lt;</span><span class="n">exit</span><span class="err">@</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">&gt;:</span> <span class="mh">0x08048316</span>              <span class="c">; la entrada de exit() aún no se actualizó</span>
   <span class="o">&gt;&gt;&gt;</span> 
</code></pre></div>    </div>
    <p>Después de ejecutar <code class="highlighter-rouge">printf()</code> vemos como en la tabla GOT se especifica la dirección de esa función dentro de <code class="highlighter-rouge">libc</code> (<code class="highlighter-rouge">0xb7e89d80</code>). Podriamos ilustrar la tabla GOT en este punto de la siguiente manera:</p>
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="o">-----------------</span> <span class="o">-----------------------</span> <span class="o">-----------------------------</span>
<span class="o">|</span> <span class="n">Entrada</span> <span class="n">en</span> <span class="p">.</span><span class="n">got</span> <span class="o">|</span> <span class="n">Nombre</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n</span>  <span class="o">|</span> <span class="n">Direcci</span><span class="err">ó</span><span class="n">n</span> <span class="n">en</span> <span class="n">biblioteca</span>     <span class="o">|</span>
<span class="o">|-----------------|-----------------------|-----------------------------|</span>
<span class="o">|</span> <span class="mi">080496</span><span class="n">c8</span>        <span class="o">|</span> <span class="n">printf</span><span class="p">()</span>              <span class="o">|</span> <span class="mh">0xb7e89d80</span> <span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">)</span>        <span class="o">|</span>
<span class="o">|</span> <span class="mi">080496</span><span class="n">d0</span>        <span class="o">|</span> <span class="n">exit</span><span class="p">()</span>                <span class="o">|</span> <span class="mh">0x08048316</span> <span class="p">(.</span><span class="n">plt</span><span class="p">)</span>           <span class="o">|</span> 
</code></pre></div>    </div>
    <p>Si avanzamos con la ejecución de <code class="highlighter-rouge">exit()</code> vemos que también su valor se actualiza en la tabla. Utilizamos un <em>watchpoint</em> en gdb para que la ejecución se detenga cuando el valor de <code class="highlighter-rouge">exit</code> en la GOT se modifique:</p>
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">/</span><span class="n">xw</span> <span class="mh">0x80496d0</span>                        <span class="c">; valor anterior de exit() en la GOT</span>
<span class="mh">0x80496d0</span> <span class="o">&lt;</span><span class="n">exit</span><span class="err">@</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">&gt;:</span> <span class="mh">0x08048316</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="n">watch</span> <span class="o">*</span><span class="mh">0x80496d0</span>
<span class="err">───</span> <span class="n">Output</span><span class="o">/</span><span class="n">messages</span> <span class="err">───────────────────────────────────────────────────────────────────────────</span>
<span class="n">Hardware</span> <span class="n">watchpoint</span> <span class="mi">5</span><span class="o">:</span> <span class="o">*</span><span class="mh">0x80496d0</span> <span class="p">...</span>     <span class="c">; la ejecución de detiene</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">/</span><span class="n">xw</span> <span class="mh">0x80496d0</span>
<span class="mh">0x80496d0</span> <span class="o">&lt;</span><span class="n">exit</span><span class="err">@</span><span class="n">got</span><span class="p">.</span><span class="n">plt</span><span class="o">&gt;:</span> <span class="mh">0xb7e561b0</span>      <span class="c">; valor actualizado de exit() en la GOT</span>
</code></pre></div>    </div>
    <p>Ya en este punto la tabla GOT contiene las direcciones efectivas de las dos funciones en <code class="highlighter-rouge">libc</code>:</p>
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="o">----------------</span>   <span class="o">---------------------</span>   <span class="o">------------------------</span>
<span class="o">|</span> <span class="n">Entrada</span> <span class="n">en</span> <span class="p">.</span><span class="n">got</span> <span class="o">|</span> <span class="n">Nombre</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n</span>  <span class="o">|</span> <span class="n">Direcci</span><span class="err">ó</span><span class="n">n</span> <span class="n">en</span> <span class="n">biblioteca</span> <span class="o">|</span>
<span class="o">|-----------------|-----------------------|-------------------------|</span>
<span class="o">|</span> <span class="mi">080496</span><span class="n">c8</span>        <span class="o">|</span> <span class="n">printf</span><span class="p">()</span>              <span class="o">|</span> <span class="mh">0xb7e89d80</span> <span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">)</span>    <span class="o">|</span>
<span class="o">|</span> <span class="mi">080496</span><span class="n">d0</span>        <span class="o">|</span> <span class="n">exit</span><span class="p">()</span>                <span class="o">|</span> <span class="mh">0xb7e561b0</span> <span class="p">(</span><span class="n">libc</span><span class="p">.</span><span class="n">so</span><span class="p">)</span>    <span class="o">|</span> 
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="la-utilidad-de-la-got">La utilidad de la GOT</h3>
<p><strong>¿Cómo es posible aprovecharse de la GOT a la hora de escribir exploits?</strong>   <br />
La dirección de una entrada en la GOT está definida para cada binario, de modo que es independiente de la pila y sus variables de entorno. Se almacena en una posición de memoria estática y conocida y debe ser un sector de memoria que se pueda escribir, porque como se vió antes su contenido se actualiza de manera “diferida” en tiempo de ejecución.</p>

<p>Estas cualidades hacen de la GOT un recurso valioso para la escritura de exploits. Sobretodo en los casos donde no es de utilidad sobreescribir la dirección de retorno de la pila, como por ejemplo en un escenario en el que <code class="highlighter-rouge">main()</code> nunca retorna porque el programa finaliza con <code class="highlighter-rouge">exit()</code> o se mantiene en un loop infinito.</p>

<blockquote>
  <p><strong>Consideraciones:</strong> es necesario recordar para abusar de los permisos de escritura de la tabla GOT la <a href="../configuracion.md#deshabilitar-relro">mitigación RELRO</a> o <em>RELocation Read-Only</em> en inglés) debe estar deshabilitada o parcialmente habilitada como sucede por defecto en la mayoría de las distribuciones de Linux.</p>
</blockquote>

<p>Si nuestro objetivo es hacer una lectura o escritura arbitraria en memoria, la GOT toma relevancia de la siguiente manera:</p>

<ol>
  <li><strong>En una escritura arbitraria</strong>   <br />
Supongamos que gracias a la vulnerabilidad de un programa podemos escribir un valor arbitrario en algún lugar de la memoria y como dijimos antes una escritura en la dirección de retorno de la pila no es de utilidad. Si optamos por sobreescribir la entrada de alguna función en la GOT (que se encuentra en una sección de memoria con permisos de escritura), al ser llamada esa función ya no se reenvía la ejecución a la biblioteca correspondiente sino a dónde hemos especificado (por ejemplo la dirección de un shellcode).
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="o">---------------------</span>  <span class="o">-------------------------</span>
<span class="o">|</span> <span class="n">Nombre</span> <span class="n">de</span> <span class="n">la</span> <span class="n">funci</span><span class="err">ó</span><span class="n">n</span> <span class="o">|</span> <span class="n">Direcci</span><span class="err">ó</span><span class="n">n</span> <span class="n">en</span> <span class="n">biblioteca</span> <span class="o">|</span>
<span class="o">|----------------------|-------------------------|</span>
<span class="o">|</span> <span class="n">printf</span><span class="p">()</span>             <span class="o">|</span> <span class="o">&amp;</span><span class="n">shellcode</span><span class="p">()</span>            <span class="o">|</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>En una lectura arbitraria</strong>        <br />
Si podemos filtrar direcciones contenidas en la GOT podemos conocer información relevante para atacar un proceso.   <br />
Por ejemplo en un ataque más avanzado con la mitigación <a href="../configuracion.md#deshabilitar-aslr">ASLR</a> habilitada, una lectura de memoria sería de gran utilidad ya que la dirección de <code class="highlighter-rouge">libc</code> en cada ejecución del binario es diferente.</p>

    <p>Los cambios en la dirección de <code class="highlighter-rouge">libc</code> se pueden observar si ejecutamos varias veces el programa anterior con ASLR habilitado:</p>
    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> <span class="nb">sudo </span>sysctl <span class="nt">-w</span> kernel.randomize_va_space<span class="o">=</span>1                <span class="p">;</span> habilitamos ASLR
<span class="go">   
</span><span class="gp">user@abos:~$</span> ldd imprimir
<span class="gp">  libc.so.6 =&gt;</span> /lib/i386-linux-gnu/i686/cmov/libc.so.6 <span class="o">(</span>0xb75b6000<span class="o">)</span>    <span class="p">;</span> libc.so <span class="o">=&gt;</span> 0xb75b6000
<span class="gp">user@abos:~$</span> ldd imprimir
<span class="gp">  libc.so.6 =&gt;</span> /lib/i386-linux-gnu/i686/cmov/libc.so.6 <span class="o">(</span>0xb75ae000<span class="o">)</span>    <span class="p">;</span> libc.so <span class="o">=&gt;</span> 0xb75ae000
<span class="gp">user@abos:~$</span> ldd imprimir
<span class="gp">  libc.so.6 =&gt;</span> /lib/i386-linux-gnu/i686/cmov/libc.so.6 <span class="o">(</span>0xb7559000<span class="o">)</span>    <span class="p">;</span> libc.so <span class="o">=&gt;</span> 0xb7559000
</code></pre></div>    </div>

    <p>Pero la dirección de las entradas en la GOT es fija -sin ninguna mitigación extra como una compilación con PIE por ejemplo- y por lo tanto idéntica en cada ejecución.</p>

    <p>(Primero habilitamos ASLR, deshabilitada por defecto en gdb)</p>
    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp"> user@abos:~$</span> gdb imprimir
<span class="go"> (gdb) show disable-randomization 
       Disabling randomization of debuggee's virtual address space is on.
 (gdb) set disable-randomization off
 (gdb) show disable-randomization 
 Disabling randomization of debuggee's virtual address space is off.
</span></code></pre></div>    </div>

    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp"> ;</span> 1er ejecución
<span class="go">
 (gdb) r 
</span><span class="gp"> (gdb) x/2i $</span>eip
<span class="gp"> =&gt;</span> 0x8048433 &lt;main+8&gt;:  call   0x80482f0 &lt;puts@plt&gt;
<span class="gp">    0x8048438 &lt;main+13&gt;</span>: add    <span class="nv">$0x4</span>,%esp
<span class="go"> (gdb) si 
 0x080482f0 in puts@plt ()
</span><span class="gp"> (gdb) x/i $</span>eip
<span class="gp"> =&gt;</span> 0x80482f0 &lt;puts@plt&gt;:  jmp    <span class="k">*</span>0x80496c8                    <span class="p">;</span> jmp &lt;puts@GOT&gt;
<span class="go">
 (gdb) p puts
</span><span class="gp"> $</span>1 <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0xb7618d80 &lt;_IO_puts&gt;    <span class="p">;</span> 1er ejecución: 0xb7618d80 addr puts<span class="o">()</span> <span class="k">in </span>libc
<span class="gp"> (gdb) x/i $</span>eip
<span class="gp"> =&gt;</span> 0x80482f0 &lt;puts@plt&gt;:  jmp    <span class="k">*</span>0x80496c8                    <span class="p">;</span> 1er ejecución: 0x80496c8  addr puts<span class="o">()</span> <span class="k">in </span>GOT
<span class="go">
</span><span class="gp"> ;</span> 2da ejecución   
<span class="go"> (gdb) r
 The program being debugged has been started already.
 Start it from the beginning? (y or n) y 
 (...)
 (gdb) si
 0x080482f0 in puts@plt ()
 (gdb) p puts 
</span><span class="gp"> $</span>2 <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0xb7604d80 &lt;_IO_puts&gt;    <span class="p">;</span> 2da ejecución: 0xb7604d80 addr puts<span class="o">()</span> <span class="k">in </span>libc
<span class="gp"> (gdb) x/i $</span>eip
<span class="gp"> =&gt;</span> 0x80482f0 &lt;puts@plt&gt;:  jmp    <span class="k">*</span>0x80496c8                    <span class="p">;</span> 2da ejecución: 0x80496c8  addr puts<span class="o">()</span> <span class="k">in </span>GOT
</code></pre></div>    </div>
    <p>Observamos como en dos ejecuciones diferentes la dirección de <code class="highlighter-rouge">libc</code> se modifica, no así la dirección de <code class="highlighter-rouge">puts()</code> dentro de la tabla GOT.</p>

    <p>En este escenario una lectura arbitraria de la GOT sería útil. Como vimos la dirección de una entrada en la GOT será idéntica aunque ASLR esté habilitada y si leyeramos su contenido obtendremos información de la dirección efectiva de una función en <code class="highlighter-rouge">libc</code> (que cambiará cada vez). Si logramos esa información es posible calcular -sumando siempre el mismo offset- la dirección de otras funciones dentro de esa biblioteca como <code class="highlighter-rouge">system()</code> por ejemplo, aunque la mitigación ASLR se encuentre habilitada.</p>
  </li>
</ol>

<h3 id="herramientas">Herramientas</h3>
<p><a href="../herramientas.md#secciones-de-un-binario">Análisis de secciones de un binario</a></p>

<h3 id="práctica">Práctica</h3>
<p>Con los contenidos vistos hasta el momento es posible avanzar con <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/abo3.c">Abo 3</a>, <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/abo4.c">Abo 4</a>, <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/abo5.c">Abo 5</a> y <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/abo6.c">Abo 6</a>.</p>

<p>Y está disponible una práctica guiada para la <a href="3-practica.md">resolución de Abo 3 a través del ataque “Smash the stack”</a>. Y del <a href="3-practica.md#ataque-de-reescritura-de-la-global-offset-table-got">Abo 5 con una ataque de reescritura de la GOT</a>.  <br />
También se presenta un <a href="4-practica.md">ataque usando variables de entorno con el Abo 6</a>.</p>

