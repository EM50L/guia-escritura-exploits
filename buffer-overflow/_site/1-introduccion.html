<h1 id="introducción">Introducción</h1>

<h2 id="primer-programa-en-assembler">Primer programa en assembler</h2>
<p>Un programa se compone de una serie de instrucciones de máquina que al ejecutarse se almacenan en la memoria del proceso. Cada instrucción es un flujo de bytes que interpretados por el procesador modifican el estado del programa.    <br />
El código de un programa escrito en lenguaje ensamblador o assembler permite trabajar con una representación simbólica de ese flujo de bytes. Por ejemplo, la instrucción en assembler <code class="highlighter-rouge">add eax, 0x1</code> suma 1 al contenido del registro de memoria <code class="highlighter-rouge">eax</code>. Y <code class="highlighter-rouge">add eax, 0x1</code> es en realidad una representación simbólica del número: <code class="highlighter-rouge">83 c0 01</code> (en hexadecimal) o lo que es lo mismo <code class="highlighter-rouge">1000 0011 1100 0000 0000 0001</code>. Este último es el contenido binario efectivamente almacenado en la memoria.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">instrucci</span><span class="err">ó</span><span class="n">n</span>       <span class="o">|</span> <span class="n">contenido</span> <span class="n">binario</span> <span class="n">en</span> <span class="n">mem</span><span class="p">.</span>       <span class="o">|</span> <span class="n">contenido</span> <span class="n">hexa</span> <span class="n">en</span> <span class="n">mem</span><span class="p">.</span> 
<span class="k">add</span>    <span class="n">eax</span><span class="p">,</span> <span class="mh">0x1</span>   <span class="o">|</span> <span class="mi">1000</span> <span class="mi">0011</span> <span class="mi">1100</span> <span class="mi">0000</span> <span class="mi">0000</span> <span class="mi">0001</span>   <span class="o">|</span> <span class="mi">83</span> <span class="n">c0</span> <span class="mi">01</span>                     
</code></pre></div></div>

<p>Por facilidad de lectura el contenido escrito en memoria se representará en hexadecimal y no en binario.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dir</span><span class="p">.</span> <span class="n">mem</span><span class="p">.</span> <span class="o">|</span> <span class="n">contenido</span> <span class="n">en</span> <span class="n">mem</span><span class="p">.</span>   <span class="o">|</span>   <span class="n">instrucci</span><span class="err">ó</span><span class="n">n</span>
<span class="mi">08048334</span><span class="o">:</span>   <span class="mi">83</span> <span class="n">c0</span> <span class="mi">01</span>                <span class="k">add</span>    <span class="n">eax</span><span class="p">,</span><span class="mh">0x1</span>
<span class="mi">08048337</span><span class="o">:</span>   <span class="mi">83</span> <span class="n">c3</span> <span class="mi">01</span>                <span class="k">add</span>    <span class="n">ebx</span><span class="p">,</span><span class="mh">0x1</span>
<span class="mi">0804833</span><span class="n">a</span><span class="o">:</span>   <span class="mi">83</span> <span class="n">c0</span> <span class="mi">02</span>                <span class="k">add</span>    <span class="n">eax</span><span class="p">,</span><span class="mh">0x2</span>
<span class="mi">0804833</span><span class="n">c</span><span class="o">:</span>   <span class="mi">83</span> <span class="n">c3</span> <span class="mi">02</span>                <span class="k">add</span>    <span class="n">ebx</span><span class="p">,</span><span class="mh">0x2</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Consideraciones:</strong></p>
  <ul>
    <li>Tener en cuenta que se trabaja con la arquitectura Intel x86.</li>
    <li>Y que a lo largo de la guía el código assembler se presenta con la <a href="https://es.wikipedia.org/wiki/Lenguaje_ensamblador_x86#Sintaxis">sintaxis Intel</a>. Las diferencias con la sintaxis AT&amp;T son numerosas, una de las más importantes es que en la sintaxis Intel el registro destino se indica primero y luego el registro fuente, al revés que en AT&amp;T.</li>
  </ul>
</blockquote>

<p>La CPU, dependiendo de su arquitectura, tiene una cierta cantidad de registros. 
Los registros son memoria de muy alta velocidad que es utilizada como si fueran variables globales dentro de un programa. A través de instrucciones en assembler se les asigna un valor y sobre ellos se realizan operaciones aritméticas.    <br />
En una computadora de 32 bits, el número más grande que se puede almacenar en un registro es de 32 bits y de 64 bits para una computadora de 64.    <br />
Dentro de los denominados registros de propósito general de 32 bits están: <code class="highlighter-rouge">eax</code>, <code class="highlighter-rouge">ebx</code>, <code class="highlighter-rouge">ecx</code> y <code class="highlighter-rouge">edx</code>. (Por convención cuando los registros son de 64 bits se denominan: <code class="highlighter-rouge">rax</code>, <code class="highlighter-rouge">rbx</code>, <code class="highlighter-rouge">rcx</code> y <code class="highlighter-rouge">rdx</code>). A ellos se suman los registros <code class="highlighter-rouge">esi</code>, <code class="highlighter-rouge">edi</code> y otros registros también considerados de propósito general de los que hablaremos más adelante.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">==========================</span>
<span class="n">registro</span> <span class="n">eax</span> <span class="o">=</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>
<span class="o">==========================</span>

<span class="n">dir</span><span class="p">.</span> <span class="n">mem</span><span class="p">.</span> <span class="o">|</span> <span class="n">instrucci</span><span class="err">ó</span><span class="n">n</span>       <span class="o">|</span> <span class="err">¿</span><span class="n">qu</span><span class="err">é</span> <span class="n">hace</span><span class="o">?</span>
<span class="mi">08048334</span><span class="o">:</span>   <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="mh">0x4</span>      <span class="c">; almacena el valor 4 en el registro eax</span>
<span class="mi">08048339</span><span class="o">:</span>   <span class="k">add</span> <span class="n">eax</span><span class="p">,</span> <span class="mh">0x3</span>      <span class="c">; suma 3 al valor almacenado en eax</span>
<span class="mi">0804833</span><span class="n">f</span><span class="o">:</span>   <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">eax</span>      <span class="c">; almacena el valor del registro eax en ebx</span>

<span class="o">==========================</span>
<span class="n">registro</span> <span class="n">eax</span> <span class="o">=</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">07</span>
<span class="n">registro</span> <span class="n">ebx</span> <span class="o">=</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">07</span>
<span class="o">==========================</span>
</code></pre></div></div>

<p>Cuando una instrucción manipula sólo una porción de los 32 bits de un registro puede acceder únicamente a ese subset de bytes utilizando nombres como: <code class="highlighter-rouge">ax</code>, <code class="highlighter-rouge">ah</code> y <code class="highlighter-rouge">al</code> según el criterio que indica la imagen:</p>

<p><img src="imagenes/partes-registro.png" alt="registro-eax" /></p>

<p>Por ejemplo, para modificar el byte menos significativo de <code class="highlighter-rouge">eax</code> una instrucción usaría directamente <code class="highlighter-rouge">al</code>. Como se puede ver con ello la instrucción ocupa menos espacio en memoria (parece un detalle pero en la escritura de exploits la cuestión del espacio es muy relevante).</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dir</span><span class="p">.</span> <span class="n">mem</span><span class="p">.</span> <span class="o">|</span> <span class="n">contenido</span> <span class="n">en</span> <span class="n">mem</span><span class="p">.</span>   <span class="o">|</span>   <span class="n">instrucci</span><span class="err">ó</span><span class="n">n</span>
<span class="mi">08048330</span><span class="o">:</span>   <span class="n">b8</span> <span class="mi">04</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>          <span class="k">mov</span>    <span class="n">eax</span><span class="p">,</span><span class="mh">0x4</span>
<span class="mi">08048335</span><span class="o">:</span>   <span class="mi">66</span> <span class="n">b8</span> <span class="mi">04</span> <span class="mi">00</span>             <span class="k">mov</span>    <span class="n">ax</span> <span class="p">,</span><span class="mh">0x4</span>
<span class="mi">08048339</span><span class="o">:</span>   <span class="n">b4</span> <span class="mi">04</span>                   <span class="k">mov</span>    <span class="n">ah</span> <span class="p">,</span><span class="mh">0x4</span>
<span class="mi">0804833</span><span class="n">b</span><span class="o">:</span>   <span class="n">b0</span> <span class="mi">04</span>                   <span class="k">mov</span>    <span class="n">al</span> <span class="p">,</span><span class="mh">0x4</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Consideraciones:</strong> 
En el ejemplo anterior cuando se quería copiar el número 4 en <code class="highlighter-rouge">mov    eax,0x4</code>, éste se almacenaba en formato <strong>little endian</strong> bajo la forma <code class="highlighter-rouge">04 00 00 00</code>. Cuando nos referimos a little endian o big endian hablamos del formato en el que una computadora almacena los datos en celdas de memoria.      Justamente en la arquitectura x86 los datos se almacenan en el formato <strong>little endian</strong>, es decir, el byte menos siginificativo se almacena en una posición de memoria menor, y así hasta el byte más significativo.</p>

  <p><img src="imagenes/teoria0/formato-little-endian.png" alt="formato" /></p>

  <p>Fuente: <a href="https://es.wikipedia.org/wiki/Endianness">Wikipedia</a></p>

  <p>Por lo tanto, en <em>little endian</em> el dato <code class="highlighter-rouge">0x12345678</code> se almacena en memoria:</p>
  <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="mh">0x78</span> <span class="o">|</span> <span class="mh">0x56</span> <span class="o">|</span> <span class="mh">0x34</span> <span class="o">|</span> <span class="mh">0x12</span>
  <span class="n">n</span>    <span class="o">|</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span>  <span class="o">|</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span>  <span class="o">|</span> <span class="n">n</span><span class="o">+</span><span class="mi">3</span> 
</code></pre></div>  </div>
  <p>El dato <code class="highlighter-rouge">ABCD</code>, es decir <code class="highlighter-rouge">\x41\x42\x43\x44</code> se almacena en memoria como <code class="highlighter-rouge">DCBA</code>:</p>
  <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="mh">0x44</span> <span class="o">|</span> <span class="mh">0x43</span> <span class="o">|</span> <span class="mh">0x42</span> <span class="o">|</span> <span class="mh">0x41</span>
  <span class="n">n</span>    <span class="o">|</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span>  <span class="o">|</span> <span class="n">n</span><span class="o">+</span><span class="mi">2</span>  <span class="o">|</span> <span class="n">n</span><span class="o">+</span><span class="mi">3</span> 
</code></pre></div>  </div>
</blockquote>

<h2 id="el-contador-de-programa--registro-eip">El contador de programa ( registro <code class="highlighter-rouge">eip</code>).</h2>

<p>El <em>instruction pointer register</em> apunta a la siguiente instrucción a ser ejecutada por el programa. Cada vez que una instrucción se procesa, el procesador actualiza automáticamente este registro para que apunte a la siguiente instrucción a ser ejecutada. Para ello su valor se incrementa de acuerdo al tamaño de la instrucción (por ejemplo, la instrucción <code class="highlighter-rouge">add eax, 0x1</code> que se almacena en memoria como <code class="highlighter-rouge">83 c0 01</code>, ocupa 3 bytes).</p>

<p>Además de los registros para el almacenamiento de datos en un programa se utilizan áreas de memoria que pueden ser accedidas con instrucciones de accesos a memoria del tipo <code class="highlighter-rouge">load/store</code> o con las operaciones de la pila <code class="highlighter-rouge">push/pop</code>.</p>

<h2 id="instrucción-mov">Instrucción MOV</h2>
<p>En la arquitectura x86 <code class="highlighter-rouge">mov</code> es la instrucción encargada de los accesos a memoria.</p>
<ol>
  <li><code class="highlighter-rouge">mov reg, [addr]</code>: permite copiar valores desde una dirección de memoria a un registro.</li>
  <li><code class="highlighter-rouge">mov [addr], reg</code>: permite copiar valores desde un registro a una dirección de memoria.</li>
</ol>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">==========================</span>
<span class="n">registro</span> <span class="n">ebx</span> <span class="o">=</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>
<span class="o">==========================</span>

<span class="n">dir</span><span class="p">.</span> <span class="n">mem</span><span class="p">.</span> <span class="o">|</span> <span class="n">contenido</span> <span class="n">en</span> <span class="n">mem</span><span class="p">.</span>  <span class="o">|</span> <span class="n">instrucci</span><span class="err">ó</span><span class="n">n</span>           <span class="o">|</span> <span class="err">¿</span><span class="n">qu</span><span class="err">é</span> <span class="n">hace</span><span class="o">?</span>
<span class="mi">08048334</span><span class="o">:</span>   <span class="mi">68</span> <span class="mi">10</span> <span class="mi">85</span> <span class="mi">04</span> <span class="mi">08</span>       <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="p">[0x08048510]</span> <span class="c">; almacena el valor 0x123 en el registro ebx</span>
<span class="mi">08048339</span><span class="o">:</span> <span class="p">....</span>                                  <span class="o">|</span> 
<span class="p">...</span>                                             <span class="o">|</span>
<span class="mi">08048510</span><span class="o">:</span>   <span class="mi">23</span> <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span>      <span class="o">&lt;------------------+</span>      <span class="c">; 0x123 almacenado en little endian</span>

<span class="o">==========================</span>
<span class="n">registro</span> <span class="n">ebx</span> <span class="o">=</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">23</span>
<span class="o">==========================</span>
</code></pre></div></div>

<p>De manera similar a la dereferencia de punteros en C, un operando de una instrucción puede ser dereferenciado como puntero si está rodeado de corchetes. El uso de corchetes en las direcciones como <code class="highlighter-rouge">[0x08048510]</code> es similar a su uso en los arrays como <code class="highlighter-rouge">array[2]</code>. En vez de un índice se usa una dirección de memoria para localizar un valor.</p>
<ol>
  <li>Con []: <code class="highlighter-rouge">mov eax, [ebx]</code>   <br />
Al segundo operando de <code class="highlighter-rouge">mov</code> se lo trata como un puntero, se sigue esa dirección y se copia el valor almacenado en ella en <code class="highlighter-rouge">eax</code>.
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">==========================</span>
<span class="n">registro</span> <span class="n">eax</span> <span class="o">=</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>
<span class="n">registro</span> <span class="n">ebx</span> <span class="o">=</span> <span class="mi">08</span> <span class="mi">04</span> <span class="mi">85</span> <span class="mi">10</span>    <span class="c">; 0x08048510</span>
<span class="o">==========================</span>
   
<span class="n">dir</span><span class="p">.</span> <span class="n">mem</span><span class="p">.</span> <span class="o">|</span> <span class="n">contenido</span> <span class="n">en</span> <span class="n">mem</span><span class="p">.</span> <span class="o">|</span> <span class="n">instrucci</span><span class="err">ó</span><span class="n">n</span>     <span class="o">|</span> <span class="err">¿</span><span class="n">qu</span><span class="err">é</span> <span class="n">hace</span><span class="o">?</span>
<span class="mi">08048334</span><span class="o">:</span>   <span class="mi">8</span><span class="n">b</span> <span class="mi">03</span>               <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="p">[ebx]</span>  <span class="c">; ebx = 0x08048510. [ebx] = 0x123. eax = 0x123. </span>
<span class="p">...</span>                                        <span class="o">|</span>    <span class="c">; guardo en eax el contenido almacenado en 0x08048510</span>
<span class="mi">08048510</span><span class="o">:</span>   <span class="mi">23</span> <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span>         <span class="o">&lt;----------+</span>

<span class="o">==========================</span>
<span class="n">registro</span> <span class="n">eax</span> <span class="o">=</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">23</span>     <span class="c">; Notar que el valor está invertido en relación a cómo se almacena en little endian en memoria</span>
<span class="o">==========================</span>
</code></pre></div>    </div>
  </li>
  <li>Sin []: <code class="highlighter-rouge">mov eax, ebx</code>   <br />
Al no usar corchetes, el segundo operando consiste en el contenido de <code class="highlighter-rouge">ebx</code> (no entendido ya como puntero), por lo que se lo copia directamente en <code class="highlighter-rouge">eax</code>.
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">==========================</span>
<span class="n">registro</span> <span class="n">eax</span> <span class="o">=</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>
<span class="n">registro</span> <span class="n">ebx</span> <span class="o">=</span> <span class="mi">08</span> <span class="mi">04</span> <span class="mi">85</span> <span class="mi">10</span>    <span class="c">; 0x08048510</span>
<span class="o">==========================</span>
   
<span class="n">dir</span><span class="p">.</span> <span class="n">mem</span><span class="p">.</span> <span class="o">|</span> <span class="n">contenido</span> <span class="n">en</span> <span class="n">mem</span><span class="p">.</span> <span class="o">|</span> <span class="n">instrucci</span><span class="err">ó</span><span class="n">n</span>      <span class="o">|</span> <span class="err">¿</span><span class="n">qu</span><span class="err">é</span> <span class="n">hace</span><span class="o">?</span>
<span class="mi">08048336</span><span class="o">:</span>   <span class="mi">89</span> <span class="n">d8</span>               <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">ebx</span>     <span class="c">; ebx = 0x08048510. eax = 0x08048510. </span>
<span class="p">...</span>                                              <span class="c">; guardo en eax el contenido almacenado en ebx</span>
<span class="mi">08048510</span><span class="o">:</span>   <span class="mi">23</span> <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span> 
   
<span class="o">==========================</span>
<span class="n">registro</span> <span class="n">eax</span> <span class="o">=</span> <span class="mi">08</span> <span class="mi">04</span> <span class="mi">85</span> <span class="mi">10</span>
<span class="o">==========================</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="la-pila">La pila</h2>
<h3 id="push--pop">PUSH &amp; POP</h3>
<p>Las operaciones <code class="highlighter-rouge">push/pop</code> manipulan un área de la memoria de un proceso denominada pila o stack. Es un área de la RAM manejada como una estructura de datos <em>LIFO</em> (<em>last in, first out</em>: último en entrar, primero en salir) donde los elementos se almacenan con <code class="highlighter-rouge">push</code> y se desapilan con <code class="highlighter-rouge">pop</code>.    <br />
La pila se utiliza para almacenar: valores de registros de manera temporaria, variables locales, parametros de funciones y direcciones de retorno.</p>

<p>Uno de los registros especiales vinculados a la pila es el puntero de pila.</p>

<h3 id="puntero-de-pila-registro-esp">Puntero de pila (registro <code class="highlighter-rouge">esp</code>).</h3>
<p>El <em>stack pointer register</em> (o <em>extended stack pointer</em>) apunta al tope de la pila, es decir al último elemento almacenado en ella. Cuando se almacena un nuevo valor en la pila con <code class="highlighter-rouge">push</code>, el valor del puntero se actualiza para siempre apuntar al tope de la pila.</p>

<p><img src="imagenes/teoria0/crecimiento-pila.png" alt="stack" /></p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">==========================</span>
<span class="n">registro</span> <span class="n">esp</span> <span class="o">=</span> <span class="mh">0xbffff590</span>
<span class="o">==========================</span>

<span class="n">dir</span><span class="p">.</span> <span class="n">mem</span><span class="p">.</span> <span class="o">|</span> <span class="n">contenido</span> <span class="n">en</span> <span class="n">mem</span><span class="p">.</span> <span class="o">|</span> <span class="n">instrucci</span><span class="err">ó</span><span class="n">n</span> <span class="o">|</span> <span class="err">¿</span><span class="n">qu</span><span class="err">é</span> <span class="n">hace</span><span class="o">?</span>
<span class="mi">08048334</span><span class="o">:</span>   <span class="mi">68</span> <span class="mi">00</span> <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span>      <span class="k">push</span> <span class="mh">0x100</span>  <span class="c">; actualiza esp = esp - 4</span>
<span class="p">...</span>                                         <span class="c">; y apila el valor 0x100</span>
<span class="p">...</span>                                                     <span class="o">|</span>
<span class="n">bffff58c</span><span class="o">:</span>   <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>                                 <span class="o">|</span>
<span class="n">bffff590</span><span class="o">:</span>   <span class="mi">00</span> <span class="mi">03</span> <span class="mi">00</span> <span class="mi">00</span>         <span class="o">&lt;=</span> <span class="n">ESP</span>                  <span class="o">|</span>
                                                        <span class="o">|</span>
                                                        <span class="o">|</span>
                                                        <span class="o">|</span>
<span class="o">==========================</span>                              <span class="o">|</span>
<span class="n">registro</span> <span class="n">esp</span> <span class="o">=</span> <span class="mh">0xbffff58c</span>                               <span class="o">|</span>
<span class="o">==========================</span>                              <span class="o">|</span>
<span class="p">...</span>                                                     <span class="o">|</span>
<span class="p">...</span>                                                     <span class="o">|</span>
<span class="n">bffff58c</span><span class="o">:</span>   <span class="mi">00</span> <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span>         <span class="o">&lt;=</span> <span class="n">ESP</span>            <span class="o">&lt;-----+</span> 
<span class="n">bffff590</span><span class="o">:</span>   <span class="mi">00</span> <span class="mi">03</span> <span class="mi">00</span> <span class="mi">00</span>  
</code></pre></div></div>
<p>Cuando se desapila un dato con <code class="highlighter-rouge">pop</code> lo apuntado por <code class="highlighter-rouge">esp</code> se almacena en el regitro indicado en la instrucción. Y el valor de <code class="highlighter-rouge">esp</code> se actualiza con el nuevo tope de pila.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">==========================</span>
<span class="n">registro</span> <span class="n">esp</span> <span class="o">=</span> <span class="mh">0xbffff58c</span>
<span class="o">==========================</span>

<span class="n">dir</span><span class="p">.</span> <span class="n">mem</span><span class="p">.</span> <span class="o">|</span> <span class="n">contenido</span> <span class="n">en</span> <span class="n">mem</span><span class="p">.</span> <span class="o">|</span> <span class="n">instrucci</span><span class="err">ó</span><span class="n">n</span> <span class="o">|</span> <span class="err">¿</span><span class="n">qu</span><span class="err">é</span> <span class="n">hace</span><span class="o">?</span>
<span class="mi">08048339</span><span class="o">:</span>   <span class="mi">5</span><span class="n">b</span>                  <span class="k">pop</span> <span class="n">ebx</span>     <span class="c">; desapila 0x100, lo guarda en ebx</span>
<span class="p">...</span>                                         <span class="c">; y actualiza esp = esp + 4</span>
<span class="n">bffff58c</span><span class="o">:</span>   <span class="mi">00</span> <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span>         <span class="o">&lt;=</span> <span class="n">ESP</span>
<span class="n">bffff590</span><span class="o">:</span>   <span class="mi">00</span> <span class="mi">03</span> <span class="mi">00</span> <span class="mi">00</span>  



<span class="o">==========================</span>
<span class="n">registro</span> <span class="n">esp</span> <span class="o">=</span> <span class="mh">0xbffff590</span>
<span class="n">registro</span> <span class="n">ebx</span> <span class="o">=</span> <span class="mh">0x00000100</span>
<span class="o">==========================</span>
<span class="p">...</span>
<span class="n">bffff58c</span><span class="o">:</span>   <span class="mi">00</span> <span class="mi">01</span> <span class="mi">00</span> <span class="mi">00</span>      
<span class="n">bffff590</span><span class="o">:</span>   <span class="mi">00</span> <span class="mi">03</span> <span class="mi">00</span> <span class="mi">00</span>         <span class="o">&lt;=</span> <span class="n">ESP</span>
</code></pre></div></div>
<p>Es interesante notar que con <code class="highlighter-rouge">pop ebx</code> el valor <code class="highlighter-rouge">0x100</code> se almacena en <code class="highlighter-rouge">ebx</code> quedando la dirección <code class="highlighter-rouge">0xbffff58c</code> disponible para su uso. Es posible ver cómo aún permanece <code class="highlighter-rouge">0x100</code> en <code class="highlighter-rouge">0xbffff58c</code> porque todavía no se lo ha sobreescrito por otra instrucción que utilice la pila.</p>

<h3 id="crecimiento-de-la-pila">Crecimiento de la pila</h3>
<p>En el ejemplo, contraintuitivamente, al almacenar un nuevo valor en la pila con <code class="highlighter-rouge">push</code>, el tope de la pila que estaba en <code class="highlighter-rouge">0xbffff590</code> pasa a estar en <code class="highlighter-rouge">0xbffff58c</code>. Es decir que, al agregar un elemento, la pila creció hacia las direcciones numéricas menores.    <br />
Al desapilar un elemento el proceso fue inverso, la pila decreció desde <code class="highlighter-rouge">0xbffff58c</code> hasta <code class="highlighter-rouge">0xbffff590</code>, es decir decreció hacia direcciones mayores.    <br />
Esto se debe a que la pila crece desde direcciones numéricas mayores (que son usadas primero) hacia las direcciones de memoria menores. Es decir, crece desde <code class="highlighter-rouge">0xf...fff</code> hacia <code class="highlighter-rouge">0x0...000</code>. Como la pila crece desde su base -desde la dirección más alta- hacia direcciones menores de memoria, al apilar un nuevo elemento se debe decrementar el puntero de la pila y al desapilar un elemento se debe incrementar el puntero de la pila. Por eso con <code class="highlighter-rouge">push</code> se resta <code class="highlighter-rouge">esp = esp - 4</code> y con <code class="highlighter-rouge">pop</code> se suma <code class="highlighter-rouge">esp = esp + 4</code>.</p>

<p><img src="imagenes/teoria0/crecimiento-pila.png" alt="stack" /></p>

<blockquote>
  <p><strong>Consideraciones</strong>:
Es posible pensar a las instrucciones <code class="highlighter-rouge">push</code> y <code class="highlighter-rouge">pop</code> como dos instrucciones concatenadas.</p>
  <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c">; push eax puede pensarse como:</span>
<span class="k">sub</span> <span class="n">esp</span><span class="p">,</span> <span class="mi">4</span>               <span class="c">; actualizo tope de la pila (o registro esp)</span>
<span class="k">mov</span> <span class="p">[esp],</span> <span class="n">eax</span>           <span class="c">; almaceno contenido de eax allí</span>

 
<span class="c">; pop eax puede pensarse como:</span>
<span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="p">[esp]</span>           <span class="c">; almaceno valor de esp en eax</span>
<span class="k">add</span> <span class="n">esp</span><span class="p">,</span> <span class="mi">4</span>               <span class="c">; actualizo tope de la pila</span>
</code></pre></div>  </div>
</blockquote>

<h3 id="instrucciones-de-salto">Instrucciones de salto</h3>
<p>En assembler instrucciones del tipo <code class="highlighter-rouge">jump</code>, <code class="highlighter-rouge">branch</code> o <code class="highlighter-rouge">call</code> modifican el valor del contador del programa. De esta manera instrucciones como <code class="highlighter-rouge">jmp</code>, <code class="highlighter-rouge">je</code>, <code class="highlighter-rouge">jne</code>, <code class="highlighter-rouge">call</code> provocan que el programa deje de ejecutarse de manera lineal modificando el flujo de ejecución.</p>

<p>La instrucción <code class="highlighter-rouge">jmp</code> es un ejemplo de un salto incondicional, es decir, siempre va a ejecutarse.    <br />
En cambio <code class="highlighter-rouge">jne</code> (<code class="highlighter-rouge">jump if not equals</code> o saltar si los operandos son distintos) es un salto condicional que depende del valor del flag zero. Existe un registro especial llamado <strong>registro de estado</strong> o registro eflags (rflags en 64 bits) donde cada bit almacena información de control que se modifica con las operaciones aritmético lógicas. Se compone de flags (o banderas en español) de 1 bit, como el <code class="highlighter-rouge">Z o zero flag</code> que se setea en 1 si la operación anterior resultó en 0, por ejemplo si el resultado de una resta como <code class="highlighter-rouge">sub ebx, eax</code> dió 0. Otros flags son <code class="highlighter-rouge">S o sign flag</code> si el resultado de la operación anterior da negativo y <code class="highlighter-rouge">O u overflow flag</code> si se produce un overflow.</p>

<p><img src="imagenes/teoria0/eflags-register.png" alt="registro" /></p>

<p>Fuente: <a href="#material-consultado">Intel (2011)</a></p>

<p>La información del registro de estado es utilizada luego por instrucciones de salto condicional. Si el resultado de una resta es 0, eso implica que ambos operandos son iguales y que la condición de <code class="highlighter-rouge">jump if equals</code> debe considerarse como verdadera y por lo tanto el salto debe producirse.</p>

<p>Por ejemplo, considerando el siguiente programa:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">==========================</span>
<span class="n">registro</span> <span class="n">eax</span> <span class="o">=</span> <span class="mh">0x100</span>
<span class="n">registro</span> <span class="n">ebx</span> <span class="o">=</span> <span class="mh">0x100</span>
<span class="n">registro</span> <span class="n">de</span> <span class="n">estado</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">=</span><span class="mi">0</span>
<span class="o">==========================</span>

<span class="mi">08048332</span><span class="o">:</span> <span class="k">sub</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">eax</span>       <span class="c">; el resultado es 0. ebx = 0. Z = 1</span>
<span class="mi">08048334</span><span class="o">:</span> <span class="k">je</span>  <span class="mi">8048340</span>        <span class="c">; ¿Z==1? true. eip = 0x08048340</span>

<span class="o">==========================</span>
<span class="n">registro</span> <span class="n">eax</span> <span class="o">=</span> <span class="mh">0x100</span>
<span class="n">registro</span> <span class="n">ebx</span> <span class="o">=</span> <span class="mh">0x0</span>
<span class="n">registro</span> <span class="n">de</span> <span class="n">estado</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">=</span><span class="mi">1</span>
<span class="o">==========================</span>

</code></pre></div></div>

<p>Una instrucción de salto condicional como <code class="highlighter-rouge">je 8048340</code> (<code class="highlighter-rouge">jump equals</code>) evalúa que los operandos de la última instrucción aritmético lógica sean iguales, si lo son el salto debe producirse. Es posible conocer si son iguales a partir de una resta con <code class="highlighter-rouge">sub</code>: si se antecede esa instrucción al <code class="highlighter-rouge">jump if equals</code> y si el resultado de esa resta da 0, es que ambos operandos son iguales (tal como indica el ejemplo); si el resultado no da 0 es que no lo son.    <br />
En el ejemplo la operación <code class="highlighter-rouge">sub ebx, eax</code> tiene como efecto setear Z=1, porque el resultado de la resta fue 0. La instrucción <code class="highlighter-rouge">jump if equals</code> evalúa el valor de <code class="highlighter-rouge">Z</code>, si es 1 significa que los operandos eran iguales, por ende <code class="highlighter-rouge">eip</code> se modifica por el nuevo valor y el salto se produce.</p>

<p>De esta manera, es posible evaluar saltos condicionales corroborando el estado del flag <code class="highlighter-rouge">zero</code>.</p>

<h3 id="call-y-convención-del-llamado-a-funciones">CALL y convención del llamado a funciones</h3>
<p>En la arquitectura x86, en el llamado a funciones la pila juega un rol fundamental. En este espacio de memoria se almacenan las variables locales de la función llamada, sus argumentos y su dirección de retorno.  Justamente se habla de <code class="highlighter-rouge">frame</code> o marco de una función al sector de la pila donde ésta almacena sus argumentos y variables locales, entre otra información.   <br />
A medida que se llaman funciones y se retorna de ellas, en la pila se crean y destruyen <code class="highlighter-rouge">frames</code>, permaneciendo siempre en el tope de la pila el marco de la función en ejecución.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">funcion_a</span><span class="p">(</span><span class="n">param_1</span><span class="p">,</span> <span class="n">param_2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">var_1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">var_2</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
        <span class="n">funcion_b</span><span class="p">(</span><span class="n">arg_3</span><span class="p">,</span> <span class="n">arg_4</span><span class="p">)</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">funcion_b</span><span class="p">(</span><span class="n">param_3</span><span class="p">,</span> <span class="n">param_4</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">var</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
        <span class="n">funcion_c</span><span class="p">(</span><span class="n">arg_5</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">funcion_c</span><span class="p">(</span><span class="n">param_5</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">var</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
        <span class="p">...</span>                         <span class="o">&lt;=</span> <span class="n">EIP</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">funcion_a</span><span class="p">(</span><span class="n">arg_1</span><span class="p">,</span> <span class="n">arg_2</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Mensaje</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Después del llamado a las tres funciones (<code class="highlighter-rouge">funcion_a, funcion_b, funcion_c</code>) y cuando se están ejecutando instrucciones dentro de la <code class="highlighter-rouge">funcion_c</code> (<code class="highlighter-rouge">eip</code> apunta al cuerpo de esa función), el layout de la pila -en una versión simplificada- es:</p>

<p><img src="imagenes/teoria0/frames-de-funciones.png" alt="frames" /></p>

<p>Por convención los parámetros de una función se encuentran disponibles en la pila y se almacenan en orden inverso: desde el último al primero, de esta manera se encontrarán disponibles en el orden correcto. (Bajo otras convenciones los parámetros se almacenan en registros).   <br />
En el ejemplo anterior, el llamado a <code class="highlighter-rouge">funcion_a(arg_1, arg_2)</code> haría que primero se apile <code class="highlighter-rouge">arg_2</code> y después <code class="highlighter-rouge">arg_1</code>.</p>

<p><img src="imagenes/teoria0/frame-funcion_a.png" alt="frame" /></p>

<p>Este gráfico es una versión simplificada del layout de la pila como se verá a continuación.</p>

<h4 id="frame-pointer-registro-ebp">Frame pointer (registro <code class="highlighter-rouge">ebp</code>).</h4>
<p>En tiempo de compilación no es posible conocer la dirección de memoria que tendrán los argumentos y variables locales de una función al ejecutar un programa. Por eso para acceder a ellos se usa el registro especial <code class="highlighter-rouge">ebp</code> o <em>frame pointer</em> (también llamado <em>base pointer register</em>) que apunta a una ubicación fija dentro del marco de una función, para que la dirección de variables y argumentos pueda ser accedida como offsets utilizando este registro.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ebp</span><span class="o">-</span><span class="mh">0x8</span>     <span class="c">; variable local #2  </span>
<span class="n">ebp</span><span class="o">-</span><span class="mh">0x4</span>     <span class="c">; variable local #1  </span>
<span class="n">ebp</span>         <span class="c">; valor ebp de función llamadora  </span>
<span class="n">ebp</span><span class="o">+</span><span class="mh">0x4</span>     <span class="c">; dirección de retorno  </span>
<span class="n">ebp</span><span class="o">+</span><span class="mh">0x8</span>     <span class="c">; parámetro #1  </span>
<span class="n">ebp</span><span class="o">+</span><span class="mh">0xc</span>     <span class="c">; parámetro #2  </span>
</code></pre></div></div>

<p>Entonces en el llamado a una función sus parámetros y variables locales son accedidos como un offset de <code class="highlighter-rouge">ebp</code>, siempre negativo en el caso de las variables locales (<code class="highlighter-rouge">ebp-0x4: var local #1</code>, <code class="highlighter-rouge">ebp-0x8: var local #2</code>) y siempre positivo para los argumentos (<code class="highlighter-rouge">ebp+0x8: param #1</code>, <code class="highlighter-rouge">ebp+0xc: param #2</code>) ya que fueron apilados con anterioridad.</p>

<p>Considerando el mismo programa de ejemplo anterior, cuando la ejecución se encuentra en la <code class="highlighter-rouge">funcion_a</code> sin haber llamado todavía la <code class="highlighter-rouge">funcion_b</code>:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">funcion_a</span><span class="p">(</span><span class="n">param_1</span><span class="p">,</span> <span class="n">param_2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">var_1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">var_2</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
        <span class="n">funcion_b</span><span class="p">(</span><span class="n">arg_3</span><span class="p">,</span> <span class="n">arg_4</span><span class="p">)</span>   <span class="o">&lt;=</span> <span class="n">EIP</span>
<span class="p">}</span>
</code></pre></div></div>

<p>En la pila se observa el stack frame de la <code class="highlighter-rouge">funcion_a</code> después de ser llamada, con los respectivos offsets de <code class="highlighter-rouge">ebp</code>:</p>

<p><img src="imagenes/teoria0/frame-funcion_a-2.png" alt="frame" /></p>

<p>Este es el layout resultante de la pila y ya no una versión simplificada.</p>

<h4 id="prologo-de-una-funcion">Prologo de una funcion</h4>
<p>A las instrucciones iniciales que se pueden observar tanto en <code class="highlighter-rouge">main()</code> como en <code class="highlighter-rouge">funcion_a()</code> se las denomina <strong>prólogo</strong>:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">; prólogo</span>

<span class="k">push</span>    <span class="n">ebp</span>                                     
<span class="k">mov</span>     <span class="n">ebp</span><span class="p">,</span> <span class="n">esp</span>                                
</code></pre></div></div>
<p>El prólogo de una función son las instrucciones en assembler que modifican los registros para la creación del marco de la función llamada.</p>
<ol>
  <li><code class="highlighter-rouge">push ebp</code>: el valor del registro <code class="highlighter-rouge">ebp</code> se modifica en cada llamado a una función (es diferente para cada frame), por eso su valor se almacena en la pila. El valor del registro <code class="highlighter-rouge">ebp</code> almacenado permite acceder a las variables y parámetros de la función llamadora. Se lo almacena en la pila porque -al llamar a una función- se modifica el valor de <code class="highlighter-rouge">ebp</code> para acceder a las variables y parámetros de la función llamada.</li>
  <li><code class="highlighter-rouge">mov ebp, esp</code>: se apunta el registro <code class="highlighter-rouge">ebp</code> al puntero de la pila, de esta manera se establece una dirección de referencia para el nuevo marco de la función llamada. 
Como inmediatamente antes se habían apilado los parámetros, estos serán accedidos; <code class="highlighter-rouge">[ebp+0x8] parámetro #1</code> y <code class="highlighter-rouge">[ebp+0xc] parámetro #2</code>.
Como a posteriori se apilan las variables locales, éstas serán accedidas: <code class="highlighter-rouge">[ebp-0x4] variable local #1</code> y <code class="highlighter-rouge">[ebp-0x8] variable local #2</code>.</li>
</ol>

<p>Resultando en el layout ya mencionado:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ebp</span><span class="o">-</span><span class="mh">0x8</span>     <span class="c">; variable local #2  </span>
<span class="n">ebp</span><span class="o">-</span><span class="mh">0x4</span>     <span class="c">; variable local #1  </span>
<span class="n">ebp</span>         <span class="c">; valor ebp de función llamadora  </span>
<span class="n">ebp</span><span class="o">+</span><span class="mh">0x4</span>     <span class="c">; dirección de retorno  </span>
<span class="n">ebp</span><span class="o">+</span><span class="mh">0x8</span>     <span class="c">; parámetro #1  </span>
<span class="n">ebp</span><span class="o">+</span><span class="mh">0xc</span>     <span class="c">; parámetro #2  </span>
</code></pre></div></div>

<h4 id="epilogo-de-una-funcion">Epilogo de una funcion</h4>
<p>Luego, se denomina <strong>epílogo</strong> a las instrucciones que, al finalizar la ejecución de la función llamada, vuelven la pila al estado inicial antes del llamado a la función:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">; epílogo</span>

<span class="k">leave</span>             
<span class="k">ret</span>               
</code></pre></div></div>
<p>La instrucción <code class="highlighter-rouge">leave</code> puede pensarse como dos instrucciones:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mov</span> <span class="n">esp</span><span class="p">,</span> <span class="n">ebp</span>  <span class="c">; leave, parte 1</span>
<span class="k">pop</span> <span class="n">ebp</span>       <span class="c">; leave, parte 2       </span>
<span class="k">ret</span>               
</code></pre></div></div>

<ol>
  <li><code class="highlighter-rouge">mov esp, ebp</code> deja de lado las variables locales de la función llamada y reestablece el tope de la pila</li>
  <li><code class="highlighter-rouge">pop ebp</code> actualiza el registro <code class="highlighter-rouge">ebp</code> a la base del marco de la función llamadora anterior.</li>
  <li><code class="highlighter-rouge">ret</code> es un retorno desde una función llamada. Desapila una dirección del tope de la pila (apuntada por <code class="highlighter-rouge">esp</code>) y la almacena en el registro <code class="highlighter-rouge">eip</code> para ejecutar a continuación esa instrucción. (Al desapilarla, actualiza el valor de <code class="highlighter-rouge">esp</code> al nuevo tope de la pila)</li>
</ol>

<h4 id="qué-es-la-dirección-de-retorno">¿Qué es la dirección de retorno?</h4>
<p>Al igual que con los saltos condicionales e incondicionales, el llamado a una función modifica el flujo de ejecución de un programa. No obstante, a diferencia de los saltos, cuando la función llamada termina de ejecutarse el control debe retornar a la función llamadora. El punto al que se debe retornar es la instrucción exactamente posterior al llamado a la función (dentro de la función llamadora).</p>

<p>Considerando una versión modificada del ejemplo anterior que imprime dos mensajes:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">funcion_a</span><span class="p">(</span><span class="kt">int</span> <span class="n">param_1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">param_2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">var_1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">var_2</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Mensaje en funcion_a()"</span><span class="p">);</span>
<span class="p">}</span>                                          <span class="o">&lt;=</span> <span class="n">eip</span> <span class="n">debe</span> <span class="n">retornar</span> <span class="n">a</span> <span class="n">main</span><span class="p">()</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">funcion_a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Mensaje en main()"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>En <code class="highlighter-rouge">main()</code> se llama a <code class="highlighter-rouge">funcion_a(1,2)</code>. Estando al final de la <code class="highlighter-rouge">funcion_a</code> una vez finalizada su ejecución (es decir, ya impreso el mensaje “Mensaje en funcion_a()”), el contador del programa debe retornar a <code class="highlighter-rouge">main()</code> y continuar con la ejecución de <code class="highlighter-rouge">printf("Mensaje en main()")</code>.</p>

<p>¿Cómo se sabe dónde retornar dentro de main? Para conocer en qué punto exacto de <code class="highlighter-rouge">main()</code> debe continuar el flujo de ejecución se usa la dirección de retorno y la instrucción <code class="highlighter-rouge">call</code>.</p>

<p>Viendo el pseudo assembler (código assembler levemente modificado para que resulte más fácil su lectura) es posible identificar el llamado de <code class="highlighter-rouge">funcion_a(1,2)</code> dentro de <code class="highlighter-rouge">main()</code> con el <a href="../herramientas.md#objdump">desensamblador OBJDUMP</a>.</p>

<p>(El significado de los flags para la compilación del programa se detalla en la <a href="../configuracion.md#simular-entorno-sin-mitigaciones">sección de configuración</a>).</p>
<div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@u:~$</span> <span class="nb">sudo </span>sysctl <span class="nt">-w</span> kernel.randomize_va_space<span class="o">=</span>0
<span class="gp">user@u:~$</span> gcc <span class="nt">-g</span> <span class="nt">-m32 -no-pie</span> <span class="nt">-fno-stack-protector</span> <span class="nt">-fno-asynchronous-unwind-tables</span> 
<span class="go">-mpreferred-stack-boundary=2 -o funcion_a funcion_a.c

</span><span class="gp">user@u:~$</span> objdump <span class="nt">-M</span> intel <span class="nt">-S</span> funcion_a
</code></pre></div></div>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">0804841</span><span class="n">e</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">&gt;:</span>

<span class="k">int</span> <span class="n">main</span><span class="p">()</span> <span class="err">{</span>
 <span class="mi">804841</span><span class="n">e</span><span class="o">:</span> <span class="mi">55</span>                    <span class="k">push</span>   <span class="n">ebp</span>
 <span class="mi">804841</span><span class="n">f</span><span class="o">:</span> <span class="mi">89</span> <span class="n">e5</span>                 <span class="k">mov</span>    <span class="n">ebp</span><span class="p">,</span><span class="n">esp</span>
        
    <span class="n">funcion_a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="c">;</span>
    <span class="mi">8048421</span><span class="o">:</span> <span class="mi">6</span><span class="n">a</span> <span class="mi">02</span>                 <span class="k">push</span>   <span class="mh">0x2</span>                  <span class="c">; param_2</span>
    <span class="mi">8048423</span><span class="o">:</span> <span class="mi">6</span><span class="n">a</span> <span class="mi">01</span>                 <span class="k">push</span>   <span class="mh">0x1</span>                  <span class="c">; param_1</span>
    <span class="mi">8048425</span><span class="o">:</span> <span class="n">e8</span> <span class="n">d1</span> <span class="n">ff</span> <span class="n">ff</span> <span class="n">ff</span>        <span class="k">call</span>   <span class="mi">80483</span><span class="n">fb</span> <span class="o">&lt;</span><span class="n">funcion_a</span><span class="o">&gt;</span>  <span class="c">; call funcion_a(1,2)</span>
    <span class="mi">804842</span><span class="n">a</span><span class="o">:</span> <span class="mi">83</span> <span class="n">c4</span> <span class="mi">08</span>              <span class="k">add</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0x8</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"Mensaje en main()"</span><span class="p">)</span><span class="c">;</span>
    <span class="mi">804842</span><span class="n">d</span><span class="o">:</span> <span class="mi">68</span> <span class="n">da</span> <span class="mi">84</span> <span class="mi">04</span> <span class="mi">08</span>        <span class="k">push</span>   <span class="mh">0x80484da</span>            <span class="c">; addr "Mensaje en main()"</span>
    <span class="mi">8048432</span><span class="o">:</span> <span class="n">e8</span> <span class="mi">99</span> <span class="n">fe</span> <span class="n">ff</span> <span class="n">ff</span>        <span class="k">call</span>   <span class="mi">80482</span><span class="n">d0</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;</span>   <span class="c">; call printf("Mensaje en main()");</span>
    <span class="mi">8048437</span><span class="o">:</span> <span class="mi">83</span> <span class="n">c4</span> <span class="mi">04</span>              <span class="k">add</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0x4</span>
<span class="err">}</span>
 <span class="mi">804843</span><span class="n">a</span><span class="o">:</span> <span class="n">c9</span>                    <span class="k">leave</span>  
 <span class="mi">804843</span><span class="n">b</span><span class="o">:</span> <span class="n">c3</span>                    <span class="k">ret</span>  
</code></pre></div></div>

<blockquote>
  <p><strong>Consideraciones:</strong> como <code class="highlighter-rouge">printf("Mensaje..." )</code> tiene como argumento un string fijo sin parámetros por una optimización del compilador se llama a la función <code class="highlighter-rouge">puts()</code> y no a <code class="highlighter-rouge">printf()</code>.</p>
</blockquote>

<p>Al llamar a una función con la instrucción <code class="highlighter-rouge">call</code>, después de haber apilado los parámetros en la pila en sentido inverso, se almacena la dirección de retorno (de la instrucción siguiente a <code class="highlighter-rouge">call</code> para saber a dónde retornar) y el valor del registro <code class="highlighter-rouge">ebp</code> usado en el marco actual. Si observamos el código en assembler de la <code class="highlighter-rouge">funcion_a</code>:</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">080483</span><span class="n">fb</span> <span class="o">&lt;</span><span class="n">funcion_a</span><span class="o">&gt;:</span>

<span class="n">void</span> <span class="n">funcion_a</span><span class="p">(</span><span class="k">int</span> <span class="n">param_1</span><span class="p">,</span> <span class="k">int</span> <span class="n">param_2</span><span class="p">)</span> <span class="err">{</span>
 <span class="c">;</span>
 <span class="c">; prólogo: apilo ebp del frame de main() para preservar su valor</span>
 <span class="c">; </span>
 <span class="mi">80483</span><span class="n">fb</span><span class="o">:</span> <span class="mi">55</span>                    <span class="k">push</span>   <span class="n">ebp</span>
 <span class="c">;</span>
 <span class="c">; prólogo: ahora ebp apunta al tope de la pila: será el nuevo ebp del frame de funcion_a</span>
 <span class="c">;</span>
 <span class="mi">80483</span><span class="n">fc</span><span class="o">:</span> <span class="mi">89</span> <span class="n">e5</span>                 <span class="k">mov</span>    <span class="n">ebp</span><span class="p">,</span><span class="n">esp</span>
 <span class="c">;</span>
 <span class="c">; hago espacio para las variables locales</span>
 <span class="c">;</span>
 <span class="mi">80483</span><span class="n">fe</span><span class="o">:</span> <span class="mi">83</span> <span class="n">ec</span> <span class="mi">08</span>              <span class="k">sub</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0x8</span>                 
        
    <span class="c">; int var_1 = 3;</span>
    <span class="mi">8048401</span><span class="o">:</span> <span class="n">c7</span> <span class="mi">45</span> <span class="n">fc</span> <span class="mi">03</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="k">mov</span>    <span class="err">[</span><span class="n">ebp</span><span class="o">-</span><span class="mh">0x4</span><span class="err">]</span><span class="p">,</span><span class="mh">0x3</span>        <span class="c">; [ebp-0x4]: var_1</span>
    
    <span class="c">; int var_2 = 4;</span>
    <span class="mi">8048408</span><span class="o">:</span> <span class="n">c7</span> <span class="mi">45</span> <span class="n">f8</span> <span class="mi">04</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>  <span class="k">mov</span>    <span class="err">[</span><span class="n">ebp</span><span class="o">-</span><span class="mh">0x8</span><span class="err">]</span><span class="p">,</span><span class="mh">0x4</span>        <span class="c">; [ebp-0x8]: var_2</span>
    <span class="c">;</span>
    <span class="c">; apilo argumento de printf() y llamo a:</span>
    <span class="c">; printf("Mensaje en funcion_a()");</span>
    <span class="c">;</span>
    <span class="mi">804840</span><span class="n">f</span><span class="o">:</span> <span class="mi">68</span> <span class="n">d0</span> <span class="mi">84</span> <span class="mi">04</span> <span class="mi">08</span>        <span class="k">push</span>   <span class="mh">0x80484d0</span>            <span class="c">; addr "Mensaje en funcion_a()"</span>
    <span class="mi">8048414</span><span class="o">:</span> <span class="n">e8</span> <span class="n">b7</span> <span class="n">fe</span> <span class="n">ff</span> <span class="n">ff</span>        <span class="k">call</span>   <span class="mi">80482</span><span class="n">d0</span> <span class="o">&lt;</span><span class="n">puts</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;</span>   <span class="c">; call printf("Mensaje en funcion_a()"); </span>
    <span class="c">;</span>
    <span class="c">; desapilo argumento de printf()</span>
    <span class="c">;</span>
    <span class="mi">8048419</span><span class="o">:</span> <span class="mi">83</span> <span class="n">c4</span> <span class="mi">04</span>              <span class="k">add</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0x4</span>
<span class="err">}</span>
 <span class="c">;</span>
 <span class="c">;  epílogo: leave puede pensarse como: mov esp, ebp; pop ebp</span>
 <span class="c">;  mov esp, ebp: llevo tope de la pila al frame pointer. </span>
 <span class="c">;  pop ebp: sobreescribo el frame pointer por el valor de ebp del frame de main(). </span>
 <span class="c">;</span>
 <span class="mi">804841</span><span class="n">c</span><span class="o">:</span> <span class="n">c9</span>                    <span class="k">leave</span>
 
 <span class="c">;  epílogo: retorno a main() usando la dirección de retorno en el tope de la pila</span>
 <span class="c">;  </span>
 <span class="mi">804841</span><span class="n">d</span><span class="o">:</span> <span class="n">c3</span>                    <span class="k">ret</span>    
</code></pre></div></div>

<h3 id="punto-de-entrada-del-binario-_start">Punto de entrada del binario _start</h3>

<p>Cuando trabajamos en GNU/Linux el formato de los ejecutables es ELF (Executable and Linking Format). Con <code class="highlighter-rouge">readelf -h</code> es posible ver los campos de la cabecera del archivo, que nos dan información relevante del binario:</p>
<div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> gcc <span class="nt">-g</span> <span class="nt">-m32 -no-pie</span> <span class="nt">-fno-stack-protector</span> <span class="nt">-fno-asynchronous-unwind-tables</span> 
<span class="go">-mpreferred-stack-boundary=2 -o programa programa.c
</span><span class="gp">user@abos:~$</span> readelf <span class="nt">-h</span> programa
<span class="go">ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x80482d0
</span><span class="c">  ...
</span></code></pre></div></div>
<p>Esta información es útil ya que nos indica que es un binario de la arquitectura Intel x86 y nos informa el punto de entrada del programa (<code class="highlighter-rouge">Entry point adress: 0x80482d0</code>). Como podemos ver en el código desensamblado esa exacta dirección del punto de entrada corresponde a <code class="highlighter-rouge">_start</code> y no a <code class="highlighter-rouge">main</code>:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span><span class="err">@</span><span class="n">abos</span><span class="o">:~</span><span class="err">$</span> <span class="n">objdump</span> <span class="o">-</span><span class="n">M</span> <span class="n">intel</span> <span class="o">-</span><span class="n">d</span> <span class="n">suma</span>
<span class="mi">080482</span><span class="n">d0</span> <span class="o">&lt;</span><span class="n">_start</span><span class="o">&gt;:</span>
 <span class="mi">80482</span><span class="n">d0</span><span class="o">:</span> <span class="mi">31</span> <span class="n">ed</span>                 <span class="k">xor</span>    <span class="n">ebp</span><span class="p">,</span><span class="n">ebp</span>
 <span class="mi">80482</span><span class="n">d2</span><span class="o">:</span> <span class="mi">5</span><span class="n">e</span>                    <span class="k">pop</span>    <span class="n">esi</span>
 <span class="p">...</span>
 <span class="mi">80482</span><span class="n">ec</span><span class="o">:</span> <span class="n">e8</span> <span class="n">cf</span> <span class="n">ff</span> <span class="n">ff</span> <span class="n">ff</span>        <span class="k">call</span>   <span class="mi">80482</span><span class="n">c0</span> <span class="o">&lt;</span><span class="n">__libc_start_main</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;</span>
 
<span class="mi">080483</span><span class="n">d8</span> <span class="o">&lt;</span><span class="n">main</span><span class="o">&gt;:</span>
 <span class="mi">80483</span><span class="n">d8</span><span class="o">:</span> <span class="mi">55</span>                    <span class="k">push</span>   <span class="n">ebp</span>
 <span class="mi">80483</span><span class="n">d9</span><span class="o">:</span> <span class="mi">89</span> <span class="n">e5</span>                 <span class="k">mov</span>    <span class="n">ebp</span><span class="p">,</span><span class="n">esp</span>
 <span class="p">...</span>
 <span class="mi">80483</span><span class="n">ed</span><span class="o">:</span> <span class="n">c9</span>                    <span class="k">leave</span>  
 <span class="mi">80483</span><span class="n">ee</span><span class="o">:</span> <span class="n">c3</span>                    <span class="k">ret</span>    
</code></pre></div></div>
<p>Efectivamente, la entrada al programa es <code class="highlighter-rouge">_start</code> que se encarga de llamar a funciones de inicialización y hace un llamado a <code class="highlighter-rouge">__libc_start_main</code> que -a su vez- se encarga de hacer el call a <code class="highlighter-rouge">main</code> con los parámetros correspondientes.   <br />
Cuando se hable del frame anterior a <code class="highlighter-rouge">main()</code> nos referiremos de manera simplificada al frame de <code class="highlighter-rouge">_start</code>.</p>

<h3 id="herramientas">Herramientas</h3>
<ol>
  <li><a href="../herramientas.md#compilador-gcc">Compilador GCC</a></li>
  <li><a href="../herramientas.md#objdump">Desensamblador OBJDUMP</a></li>
  <li><a href="../herramientas.md#debugger-gdb">Debugger GDB</a></li>
</ol>

<h3 id="práctica">Práctica</h3>
<p>Con los contenidos vistos hasta el momento es posible avanzar con <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/stack1.c">Stack 1</a>, <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/stack2.c">Stack 2</a> y <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/stack3.c">Stack 3</a>.    <br />
Y está disponible una práctica guiada para la <a href="1-practica.md">resolución de Stack 1 a través del ataque “Smash the stack”</a>.</p>

<h3 id="material-consultado">Material consultado</h3>
<p>[1]. Tanenbaum, Andrew S. (2005). <em>Structured computer organization.</em></p>

<p>[2]. Intel Corporation. (Mayo de 2011). <em>Intel 64 and IA-32 Architectures Software Developer’s Manual: Combined volumes</em>. Disponible en: https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf</p>

<p>[3]. Younan, Y., Piessens, F., Joosen, W. (Sin fecha). <em>Protecting global and static variables from buffer overflow attacks</em>. Disponible en: http://fort-knox.org/files/globstat.pdf</p>

<p>[4]. Aleph One. (Noviembre de 1996). Smashing the Stack for Fun and Profit. <em>Phrack</em>, 7. Disponible en: http://phrack.org/issues/49/14.html</p>

<p>[5]. Liveoverflow.com. (2018). Disponible en: http://liveoverflow.com/</p>

