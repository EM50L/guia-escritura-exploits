<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
       &middot; Guía de exploits
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
 <!-- <div class="container sidebar-sticky">-->
  <div class="container sidebar">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Guía de exploits
        </a>
      </h1>
      <!--<p class="lead">Basada en Insecure programming de <a href="">Gera</a></p>-->
    </div>

    <nav class="sidebar-nav">

     <!-- <a class="sidebar-nav-item" href="/">Home</a>-->

        <a class="sidebar-nav-item" href="/buffer-overflow/index.html">Buffer Overflow</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/buffer-overflow/1-introduccion.html">Nivel 1 | Teoría</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/buffer-overflow/1-practica.html">Nivel 1 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/buffer-overflow/2-shellcode.html">Nivel 2 | Shellcode</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/buffer-overflow/2-practica.html">Nivel 2 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/buffer-overflow/3-got.html">Nivel 3 | GOT</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/buffer-overflow/3-practica.html">Nivel 3 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/buffer-overflow/4-practica.html">Nivel 4 | Práctica</a>

        <a class="sidebar-nav-item" href="/format-string/index.html">Format String</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/format-string/5-format-string.html">Nivel 5 | Format strings</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/format-string/5-practica.html">Nivel 5 | Práctica</a>

        <a class="sidebar-nav-item" href="/esoteric/index.html">Esoteric</a>

      <a class="sidebar-nav-item sidebar-sub-item" href="/esoteric/6-ret2libc.html">Nivel 6 | Return to libc</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/esoteric/6-practica.html">Nivel 6 | Práctica</a>


      <!--<a class="sidebar-nav-item" href="https://github.com/poole/hyde/archive/v2.1.0.zip">Descargar PDF</a>-->
      <a class="sidebar-nav-item" href="https://github.com/fundacion-sadosky/guia-escritura-exploits">Proyecto en GitHub</a>
    </nav>

    <p class="sidebar-nav-item footer">Basado en los <a href="https://github.com/gerasdf/InsecureProgramming/">abos de Gera</a></br> Teresa Alberto | STIC, Fundación Sadosky  </br> BY-NC-SA | 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <!--<h1 class="page-title"></h1>-->
  <h1 id="introducción">Introducción</h1>

<h2 id="primer-programa-en-assembler">Primer programa en assembler</h2>
<p>Un programa se compone de una serie de instrucciones de máquina que al ejecutarse se almacenan en la memoria del proceso. Cada instrucción es un flujo de bytes que interpretados por el procesador modifican el estado del programa.    <br />
El código de un programa escrito en lenguaje ensamblador o assembler permite trabajar con una representación simbólica de ese flujo de bytes. Por ejemplo, la instrucción en assembler <code>add eax, 0x1</code> suma 1 al contenido del registro de memoria <code>eax</code>. Y <code>add eax, 0x1</code> es en realidad una representación simbólica del número: <code>83 c0 01</code> (en hexadecimal) o lo que es lo mismo <code>1000 0011 1100 0000 0000 0001</code>. Este último es el contenido binario efectivamente almacenado en la memoria.</p>

<pre><code class="language-asm">instrucción       | contenido binario en mem.       | contenido hexa en mem. 
add    eax, 0x1   | 1000 0011 1100 0000 0000 0001   | 83 c0 01                     
</code></pre>

<p>Por facilidad de lectura el contenido escrito en memoria se representará en hexadecimal y no en binario.</p>

<pre><code class="language-asm">dir. mem. | contenido en mem.   |   instrucción
08048334:   83 c0 01                add    eax,0x1
08048337:   83 c3 01                add    ebx,0x1
0804833a:   83 c0 02                add    eax,0x2
0804833c:   83 c3 02                add    ebx,0x2
</code></pre>

<blockquote>
  <p><strong>Consideraciones:</strong></p>
  <ul>
    <li>Tener en cuenta que se trabaja con la arquitectura Intel x86.</li>
    <li>Y que a lo largo de la guía el código assembler se presenta con la <a href="https://es.wikipedia.org/wiki/Lenguaje_ensamblador_x86#Sintaxis">sintaxis Intel</a>. Las diferencias con la sintaxis AT&amp;T son numerosas, una de las más importantes es que en la sintaxis Intel el registro destino se indica primero y luego el registro fuente, al revés que en AT&amp;T.</li>
  </ul>
</blockquote>

<p>La CPU, dependiendo de su arquitectura, tiene una cierta cantidad de registros. 
Los registros son memoria de muy alta velocidad que es utilizada como si fueran variables globales dentro de un programa. A través de instrucciones en assembler se les asigna un valor y sobre ellos se realizan operaciones aritméticas.    <br />
En una computadora de 32 bits, el número más grande que se puede almacenar en un registro es de 32 bits y de 64 bits para una computadora de 64.    <br />
Dentro de los denominados registros de propósito general de 32 bits están: <code>eax</code>, <code>ebx</code>, <code>ecx</code> y <code>edx</code>. (Por convención cuando los registros son de 64 bits se denominan: <code>rax</code>, <code>rbx</code>, <code>rcx</code> y <code>rdx</code>). A ellos se suman los registros <code>esi</code>, <code>edi</code> y otros registros también considerados de propósito general de los que hablaremos más adelante.</p>

<pre><code class="language-asm">==========================
registro eax = 00 00 00 00
==========================

dir. mem. | instrucción       | ¿qué hace?
08048334:   mov eax, 0x4      ; almacena el valor 4 en el registro eax
08048339:   add eax, 0x3      ; suma 3 al valor almacenado en eax
0804833f:   mov ebx, eax      ; almacena el valor del registro eax en ebx

==========================
registro eax = 00 00 00 07
registro ebx = 00 00 00 07
==========================
</code></pre>

<p>Cuando una instrucción manipula sólo una porción de los 32 bits de un registro puede acceder únicamente a ese subset de bytes utilizando nombres como: <code>ax</code>, <code>ah</code> y <code>al</code> según el criterio que indica la imagen:</p>

<p><img src="/buffer-overflow/imagenes/partes-registro.png" alt="registro-eax" /></p>

<p>Por ejemplo, para modificar el byte menos significativo de <code>eax</code> una instrucción usaría directamente <code>al</code>. Como se puede ver con ello la instrucción ocupa menos espacio en memoria (parece un detalle pero en la escritura de exploits la cuestión del espacio es muy relevante).</p>

<pre><code class="language-asm">dir. mem. | contenido en mem.   |   instrucción
08048330:   b8 04 00 00 00          mov    eax,0x4
08048335:   66 b8 04 00             mov    ax ,0x4
08048339:   b4 04                   mov    ah ,0x4
0804833b:   b0 04                   mov    al ,0x4
</code></pre>

<blockquote>
  <p><strong>Consideraciones:</strong> 
En el ejemplo anterior cuando se quería copiar el número 4 en <code>mov    eax,0x4</code>, éste se almacenaba en formato <strong>little endian</strong> bajo la forma <code>04 00 00 00</code>. Cuando nos referimos a little endian o big endian hablamos del formato en el que una computadora almacena los datos en celdas de memoria.      Justamente en la arquitectura x86 los datos se almacenan en el formato <strong>little endian</strong>, es decir, el byte menos siginificativo se almacena en una posición de memoria menor, y así hasta el byte más significativo.</p>

  <p><img src="/buffer-overflow/imagenes/teoria0/formato-little-endian.png" alt="formato" /></p>

  <p>Fuente: <a href="https://es.wikipedia.org/wiki/Endianness">Wikipedia</a></p>

  <p>Por lo tanto, en <em>little endian</em> el dato <code>0x12345678</code> se almacena en memoria:</p>
  <pre><code class="language-asm">  0x78 | 0x56 | 0x34 | 0x12
  n    | n+1  | n+2  | n+3 
</code></pre>
  <p>El dato <code>ABCD</code>, es decir <code>\x41\x42\x43\x44</code> se almacena en memoria como <code>DCBA</code>:</p>
  <pre><code class="language-asm">  0x44 | 0x43 | 0x42 | 0x41
  n    | n+1  | n+2  | n+3 
</code></pre>
</blockquote>

<h2 id="el-contador-de-programa--registro-eip">El contador de programa ( registro <code>eip</code>).</h2>

<p>El <em>instruction pointer register</em> apunta a la siguiente instrucción a ser ejecutada por el programa. Cada vez que una instrucción se procesa, el procesador actualiza automáticamente este registro para que apunte a la siguiente instrucción a ser ejecutada. Para ello su valor se incrementa de acuerdo al tamaño de la instrucción (por ejemplo, la instrucción <code>add eax, 0x1</code> que se almacena en memoria como <code>83 c0 01</code>, ocupa 3 bytes).</p>

<p>Además de los registros para el almacenamiento de datos en un programa se utilizan áreas de memoria que pueden ser accedidas con instrucciones de accesos a memoria del tipo <code>load/store</code> o con las operaciones de la pila <code>push/pop</code>.</p>

<h2 id="instrucción-mov">Instrucción MOV</h2>
<p>En la arquitectura x86 <code>mov</code> es la instrucción encargada de los accesos a memoria.</p>
<ol>
  <li><code>mov reg, [addr]</code>: permite copiar valores desde una dirección de memoria a un registro.</li>
  <li><code>mov [addr], reg</code>: permite copiar valores desde un registro a una dirección de memoria.</li>
</ol>

<pre><code class="language-asm">==========================
registro ebx = 00 00 00 00
==========================

dir. mem. | contenido en mem.  | instrucción           | ¿qué hace?
08048334:   68 10 85 04 08       mov ebx, [0x08048510] ; almacena el valor 0x123 en el registro ebx
08048339: ....                                  | 
...                                             |
08048510:   23 01 00 00      &lt;------------------+      ; 0x123 almacenado en little endian

==========================
registro ebx = 00 00 01 23
==========================
</code></pre>

<p>De manera similar a la dereferencia de punteros en C, un operando de una instrucción puede ser dereferenciado como puntero si está rodeado de corchetes. El uso de corchetes en las direcciones como <code>[0x08048510]</code> es similar a su uso en los arrays como <code>array[2]</code>. En vez de un índice se usa una dirección de memoria para localizar un valor.</p>
<ol>
  <li>Con []: <code>mov eax, [ebx]</code>   <br />
Al segundo operando de <code>mov</code> se lo trata como un puntero, se sigue esa dirección y se copia el valor almacenado en ella en <code>eax</code>.
    <pre><code class="language-asm">==========================
registro eax = 00 00 00 00
registro ebx = 08 04 85 10    ; 0x08048510
==========================
   
dir. mem. | contenido en mem. | instrucción     | ¿qué hace?
08048334:   8b 03               mov eax, [ebx]  ; ebx = 0x08048510. [ebx] = 0x123. eax = 0x123. 
...                                        |    ; guardo en eax el contenido almacenado en 0x08048510
08048510:   23 01 00 00         &lt;----------+

==========================
registro eax = 00 00 01 23     ; Notar que el valor está invertido en relación a cómo se almacena en little endian en memoria
==========================
</code></pre>
  </li>
  <li>Sin []: <code>mov eax, ebx</code>   <br />
Al no usar corchetes, el segundo operando consiste en el contenido de <code>ebx</code> (no entendido ya como puntero), por lo que se lo copia directamente en <code>eax</code>.
    <pre><code class="language-asm">==========================
registro eax = 00 00 00 00
registro ebx = 08 04 85 10    ; 0x08048510
==========================
   
dir. mem. | contenido en mem. | instrucción      | ¿qué hace?
08048336:   89 d8               mov eax, ebx     ; ebx = 0x08048510. eax = 0x08048510. 
...                                              ; guardo en eax el contenido almacenado en ebx
08048510:   23 01 00 00 
   
==========================
registro eax = 08 04 85 10
==========================
</code></pre>
  </li>
</ol>

<h2 id="la-pila">La pila</h2>
<h3 id="push--pop">PUSH &amp; POP</h3>
<p>Las operaciones <code>push/pop</code> manipulan un área de la memoria de un proceso denominada pila o stack. Es un área de la RAM manejada como una estructura de datos <em>LIFO</em> (<em>last in, first out</em>: último en entrar, primero en salir) donde los elementos se almacenan con <code>push</code> y se desapilan con <code>pop</code>.    <br />
La pila se utiliza para almacenar: valores de registros de manera temporaria, variables locales, parametros de funciones y direcciones de retorno.</p>

<p>Uno de los registros especiales vinculados a la pila es el puntero de pila.</p>

<h3 id="puntero-de-pila-registro-esp">Puntero de pila (registro <code>esp</code>).</h3>
<p>El <em>stack pointer register</em> (o <em>extended stack pointer</em>) apunta al tope de la pila, es decir al último elemento almacenado en ella. Cuando se almacena un nuevo valor en la pila con <code>push</code>, el valor del puntero se actualiza para siempre apuntar al tope de la pila.</p>

<p><img src="/buffer-overflow/imagenes/teoria0/crecimiento-pila.png" alt="stack" /></p>

<pre><code class="language-asm">==========================
registro esp = 0xbffff590
==========================

dir. mem. | contenido en mem. | instrucción | ¿qué hace?
08048334:   68 00 01 00 00      push 0x100  ; actualiza esp = esp - 4
...                                         ; y apila el valor 0x100
...                                                     |
bffff58c:   00 00 00 00                                 |
bffff590:   00 03 00 00         &lt;= ESP                  |
                                                        |
                                                        |
                                                        |
==========================                              |
registro esp = 0xbffff58c                               |
==========================                              |
...                                                     |
...                                                     |
bffff58c:   00 01 00 00         &lt;= ESP            &lt;-----+ 
bffff590:   00 03 00 00  
</code></pre>
<p>Cuando se desapila un dato con <code>pop</code> lo apuntado por <code>esp</code> se almacena en el regitro indicado en la instrucción. Y el valor de <code>esp</code> se actualiza con el nuevo tope de pila.</p>

<pre><code class="language-asm">==========================
registro esp = 0xbffff58c
==========================

dir. mem. | contenido en mem. | instrucción | ¿qué hace?
08048339:   5b                  pop ebx     ; desapila 0x100, lo guarda en ebx
...                                         ; y actualiza esp = esp + 4
bffff58c:   00 01 00 00         &lt;= ESP
bffff590:   00 03 00 00  



==========================
registro esp = 0xbffff590
registro ebx = 0x00000100
==========================
...
bffff58c:   00 01 00 00      
bffff590:   00 03 00 00         &lt;= ESP
</code></pre>
<p>Es interesante notar que con <code>pop ebx</code> el valor <code>0x100</code> se almacena en <code>ebx</code> quedando la dirección <code>0xbffff58c</code> disponible para su uso. Es posible ver cómo aún permanece <code>0x100</code> en <code>0xbffff58c</code> porque todavía no se lo ha sobreescrito por otra instrucción que utilice la pila.</p>

<h3 id="crecimiento-de-la-pila">Crecimiento de la pila</h3>
<p>En el ejemplo, contraintuitivamente, al almacenar un nuevo valor en la pila con <code>push</code>, el tope de la pila que estaba en <code>0xbffff590</code> pasa a estar en <code>0xbffff58c</code>. Es decir que, al agregar un elemento, la pila creció hacia las direcciones numéricas menores.    <br />
Al desapilar un elemento el proceso fue inverso, la pila decreció desde <code>0xbffff58c</code> hasta <code>0xbffff590</code>, es decir decreció hacia direcciones mayores.    <br />
Esto se debe a que la pila crece desde direcciones numéricas mayores (que son usadas primero) hacia las direcciones de memoria menores. Es decir, crece desde <code>0xf...fff</code> hacia <code>0x0...000</code>. Como la pila crece desde su base -desde la dirección más alta- hacia direcciones menores de memoria, al apilar un nuevo elemento se debe decrementar el puntero de la pila y al desapilar un elemento se debe incrementar el puntero de la pila. Por eso con <code>push</code> se resta <code>esp = esp - 4</code> y con <code>pop</code> se suma <code>esp = esp + 4</code>.</p>

<p><img src="/buffer-overflow/imagenes/teoria0/crecimiento-pila.png" alt="stack" /></p>

<blockquote>
  <p><strong>Consideraciones</strong>:
Es posible pensar a las instrucciones <code>push</code> y <code>pop</code> como dos instrucciones concatenadas.</p>
  <pre><code class="language-asm">
; push eax puede pensarse como:
sub esp, 4               ; actualizo tope de la pila (o registro esp)
mov [esp], eax           ; almaceno contenido de eax allí

 
; pop eax puede pensarse como:
mov eax, [esp]           ; almaceno valor de esp en eax
add esp, 4               ; actualizo tope de la pila
</code></pre>
</blockquote>

<h3 id="instrucciones-de-salto">Instrucciones de salto</h3>
<p>En assembler instrucciones del tipo <code>jump</code>, <code>branch</code> o <code>call</code> modifican el valor del contador del programa. De esta manera instrucciones como <code>jmp</code>, <code>je</code>, <code>jne</code>, <code>call</code> provocan que el programa deje de ejecutarse de manera lineal modificando el flujo de ejecución.</p>

<p>La instrucción <code>jmp</code> es un ejemplo de un salto incondicional, es decir, siempre va a ejecutarse.    <br />
En cambio <code>jne</code> (<code>jump if not equals</code> o saltar si los operandos son distintos) es un salto condicional que depende del valor del flag zero. Existe un registro especial llamado <strong>registro de estado</strong> o registro eflags (rflags en 64 bits) donde cada bit almacena información de control que se modifica con las operaciones aritmético lógicas. Se compone de flags (o banderas en español) de 1 bit, como el <code>Z o zero flag</code> que se setea en 1 si la operación anterior resultó en 0, por ejemplo si el resultado de una resta como <code>sub ebx, eax</code> dió 0. Otros flags son <code>S o sign flag</code> si el resultado de la operación anterior da negativo y <code>O u overflow flag</code> si se produce un overflow.</p>

<p><img src="/buffer-overflow/imagenes/teoria0/eflags-register.png" alt="registro" /></p>

<p>Fuente: <a href="#material-consultado">Intel (2011)</a></p>

<p>La información del registro de estado es utilizada luego por instrucciones de salto condicional. Si el resultado de una resta es 0, eso implica que ambos operandos son iguales y que la condición de <code>jump if equals</code> debe considerarse como verdadera y por lo tanto el salto debe producirse.</p>

<p>Por ejemplo, considerando el siguiente programa:</p>
<pre><code class="language-asm">==========================
registro eax = 0x100
registro ebx = 0x100
registro de estado =&gt; Z=0
==========================

08048332: sub ebx, eax       ; el resultado es 0. ebx = 0. Z = 1
08048334: je  8048340        ; ¿Z==1? true. eip = 0x08048340

==========================
registro eax = 0x100
registro ebx = 0x0
registro de estado =&gt; Z=1
==========================

</code></pre>

<p>Una instrucción de salto condicional como <code>je 8048340</code> (<code>jump equals</code>) evalúa que los operandos de la última instrucción aritmético lógica sean iguales, si lo son el salto debe producirse. Es posible conocer si son iguales a partir de una resta con <code>sub</code>: si se antecede esa instrucción al <code>jump if equals</code> y si el resultado de esa resta da 0, es que ambos operandos son iguales (tal como indica el ejemplo); si el resultado no da 0 es que no lo son.    <br />
En el ejemplo la operación <code>sub ebx, eax</code> tiene como efecto setear Z=1, porque el resultado de la resta fue 0. La instrucción <code>jump if equals</code> evalúa el valor de <code>Z</code>, si es 1 significa que los operandos eran iguales, por ende <code>eip</code> se modifica por el nuevo valor y el salto se produce.</p>

<p>De esta manera, es posible evaluar saltos condicionales corroborando el estado del flag <code>zero</code>.</p>

<h3 id="call-y-convención-del-llamado-a-funciones">CALL y convención del llamado a funciones</h3>
<p>En la arquitectura x86, en el llamado a funciones la pila juega un rol fundamental. En este espacio de memoria se almacenan las variables locales de la función llamada, sus argumentos y su dirección de retorno.  Justamente se habla de <code>frame</code> o marco de una función al sector de la pila donde ésta almacena sus argumentos y variables locales, entre otra información.   <br />
A medida que se llaman funciones y se retorna de ellas, en la pila se crean y destruyen <code>frames</code>, permaneciendo siempre en el tope de la pila el marco de la función en ejecución.</p>

<pre><code class="language-C">void funcion_a(param_1, param_2) {
        int var_1 = 10;
        int var_2 = 11;
        funcion_b(arg_3, arg_4)
}
void funcion_b(param_3, param_4) {
        int var = 12;
        funcion_c(arg_5);
}
void funcion_c(param_5) {
        int var = 13;
        ...                         &lt;= EIP
}

int main() {
        funcion_a(arg_1, arg_2);
        printf("Mensaje\n");
}
</code></pre>
<p>Después del llamado a las tres funciones (<code>funcion_a, funcion_b, funcion_c</code>) y cuando se están ejecutando instrucciones dentro de la <code>funcion_c</code> (<code>eip</code> apunta al cuerpo de esa función), el layout de la pila -en una versión simplificada- es:</p>

<p><img src="/buffer-overflow/imagenes/teoria0/frames-de-funciones.png" alt="frames" /></p>

<p>Por convención los parámetros de una función se encuentran disponibles en la pila y se almacenan en orden inverso: desde el último al primero, de esta manera se encontrarán disponibles en el orden correcto. (Bajo otras convenciones los parámetros se almacenan en registros).   <br />
En el ejemplo anterior, el llamado a <code>funcion_a(arg_1, arg_2)</code> haría que primero se apile <code>arg_2</code> y después <code>arg_1</code>.</p>

<p><img src="/buffer-overflow/imagenes/teoria0/frame-funcion_a.png" alt="frame" /></p>

<p>Este gráfico es una versión simplificada del layout de la pila como se verá a continuación.</p>

<h4 id="frame-pointer-registro-ebp">Frame pointer (registro <code>ebp</code>).</h4>
<p>En tiempo de compilación no es posible conocer la dirección de memoria que tendrán los argumentos y variables locales de una función al ejecutar un programa. Por eso para acceder a ellos se usa el registro especial <code>ebp</code> o <em>frame pointer</em> (también llamado <em>base pointer register</em>) que apunta a una ubicación fija dentro del marco de una función, para que la dirección de variables y argumentos pueda ser accedida como offsets utilizando este registro.</p>

<pre><code class="language-asm">ebp-0x8     ; variable local #2  
ebp-0x4     ; variable local #1  
ebp         ; valor ebp de función llamadora  
ebp+0x4     ; dirección de retorno  
ebp+0x8     ; parámetro #1  
ebp+0xc     ; parámetro #2  
</code></pre>

<p>Entonces en el llamado a una función sus parámetros y variables locales son accedidos como un offset de <code>ebp</code>, siempre negativo en el caso de las variables locales (<code>ebp-0x4: var local #1</code>, <code>ebp-0x8: var local #2</code>) y siempre positivo para los argumentos (<code>ebp+0x8: param #1</code>, <code>ebp+0xc: param #2</code>) ya que fueron apilados con anterioridad.</p>

<p>Considerando el mismo programa de ejemplo anterior, cuando la ejecución se encuentra en la <code>funcion_a</code> sin haber llamado todavía la <code>funcion_b</code>:</p>
<pre><code class="language-C">void funcion_a(param_1, param_2) {
        int var_1 = 10;
        int var_2 = 11;
        funcion_b(arg_3, arg_4)   &lt;= EIP
}
</code></pre>

<p>En la pila se observa el stack frame de la <code>funcion_a</code> después de ser llamada, con los respectivos offsets de <code>ebp</code>:</p>

<p><img src="/buffer-overflow/imagenes/teoria0/frame-funcion_a-2.png" alt="frame" /></p>

<p>Este es el layout resultante de la pila y ya no una versión simplificada.</p>

<h4 id="prologo-de-una-funcion">Prologo de una funcion</h4>
<p>A las instrucciones iniciales que se pueden observar tanto en <code>main()</code> como en <code>funcion_a()</code> se las denomina <strong>prólogo</strong>:</p>
<pre><code class="language-asm">; prólogo

push    ebp                                     
mov     ebp, esp                                
</code></pre>
<p>El prólogo de una función son las instrucciones en assembler que modifican los registros para la creación del marco de la función llamada.</p>
<ol>
  <li><code>push ebp</code>: el valor del registro <code>ebp</code> se modifica en cada llamado a una función (es diferente para cada frame), por eso su valor se almacena en la pila. El valor del registro <code>ebp</code> almacenado permite acceder a las variables y parámetros de la función llamadora. Se lo almacena en la pila porque -al llamar a una función- se modifica el valor de <code>ebp</code> para acceder a las variables y parámetros de la función llamada.</li>
  <li><code>mov ebp, esp</code>: se apunta el registro <code>ebp</code> al puntero de la pila, de esta manera se establece una dirección de referencia para el nuevo marco de la función llamada. 
Como inmediatamente antes se habían apilado los parámetros, estos serán accedidos; <code>[ebp+0x8] parámetro #1</code> y <code>[ebp+0xc] parámetro #2</code>.
Como a posteriori se apilan las variables locales, éstas serán accedidas: <code>[ebp-0x4] variable local #1</code> y <code>[ebp-0x8] variable local #2</code>.</li>
</ol>

<p>Resultando en el layout ya mencionado:</p>
<pre><code class="language-asm">ebp-0x8     ; variable local #2  
ebp-0x4     ; variable local #1  
ebp         ; valor ebp de función llamadora  
ebp+0x4     ; dirección de retorno  
ebp+0x8     ; parámetro #1  
ebp+0xc     ; parámetro #2  
</code></pre>

<h4 id="epilogo-de-una-funcion">Epilogo de una funcion</h4>
<p>Luego, se denomina <strong>epílogo</strong> a las instrucciones que, al finalizar la ejecución de la función llamada, vuelven la pila al estado inicial antes del llamado a la función:</p>
<pre><code class="language-asm">; epílogo

leave             
ret               
</code></pre>
<p>La instrucción <code>leave</code> puede pensarse como dos instrucciones:</p>
<pre><code class="language-asm">mov esp, ebp  ; leave, parte 1
pop ebp       ; leave, parte 2       
ret               
</code></pre>

<ol>
  <li><code>mov esp, ebp</code> deja de lado las variables locales de la función llamada y reestablece el tope de la pila</li>
  <li><code>pop ebp</code> actualiza el registro <code>ebp</code> a la base del marco de la función llamadora anterior.</li>
  <li><code>ret</code> es un retorno desde una función llamada. Desapila una dirección del tope de la pila (apuntada por <code>esp</code>) y la almacena en el registro <code>eip</code> para ejecutar a continuación esa instrucción. (Al desapilarla, actualiza el valor de <code>esp</code> al nuevo tope de la pila)</li>
</ol>

<h4 id="qué-es-la-dirección-de-retorno">¿Qué es la dirección de retorno?</h4>
<p>Al igual que con los saltos condicionales e incondicionales, el llamado a una función modifica el flujo de ejecución de un programa. No obstante, a diferencia de los saltos, cuando la función llamada termina de ejecutarse el control debe retornar a la función llamadora. El punto al que se debe retornar es la instrucción exactamente posterior al llamado a la función (dentro de la función llamadora).</p>

<p>Considerando una versión modificada del ejemplo anterior que imprime dos mensajes:</p>

<pre><code class="language-C">void funcion_a(int param_1, int param_2) {
        int var_1 = 3;
        int var_2 = 4;
        printf("Mensaje en funcion_a()");
}                                          &lt;= eip debe retornar a main()

int main() {
        funcion_a(1,2);
        printf("Mensaje en main()");
}
</code></pre>
<p>En <code>main()</code> se llama a <code>funcion_a(1,2)</code>. Estando al final de la <code>funcion_a</code> una vez finalizada su ejecución (es decir, ya impreso el mensaje “Mensaje en funcion_a()”), el contador del programa debe retornar a <code>main()</code> y continuar con la ejecución de <code>printf("Mensaje en main()")</code>.</p>

<p>¿Cómo se sabe dónde retornar dentro de main? Para conocer en qué punto exacto de <code>main()</code> debe continuar el flujo de ejecución se usa la dirección de retorno y la instrucción <code>call</code>.</p>

<p>Viendo el pseudo assembler (código assembler levemente modificado para que resulte más fácil su lectura) es posible identificar el llamado de <code>funcion_a(1,2)</code> dentro de <code>main()</code> con el <a href="../herramientas.md#objdump">desensamblador OBJDUMP</a>.</p>

<p>(El significado de los flags para la compilación del programa se detalla en la <a href="../configuracion.md#simular-entorno-sin-mitigaciones">sección de configuración</a>).</p>
<pre><code class="language-bash">user@u:~$ sudo sysctl -w kernel.randomize_va_space=0
user@u:~$ gcc -g -m32 -fno-stack-protector -fno-asynchronous-unwind-tables 
-mpreferred-stack-boundary=2 -o funcion_a funcion_a.c

user@u:~$ objdump -M intel -S funcion_a
</code></pre>
<pre><code class="language-asm">0804841e &lt;main&gt;:

int main() {
 804841e: 55                    push   ebp
 804841f: 89 e5                 mov    ebp,esp
        
    funcion_a(1,2);
    8048421: 6a 02                 push   0x2                  ; param_2
    8048423: 6a 01                 push   0x1                  ; param_1
    8048425: e8 d1 ff ff ff        call   80483fb &lt;funcion_a&gt;  ; call funcion_a(1,2)
    804842a: 83 c4 08              add    esp,0x8
    
    printf("Mensaje en main()");
    804842d: 68 da 84 04 08        push   0x80484da            ; addr "Mensaje en main()"
    8048432: e8 99 fe ff ff        call   80482d0 &lt;puts@plt&gt;   ; call printf("Mensaje en main()");
    8048437: 83 c4 04              add    esp,0x4
}
 804843a: c9                    leave  
 804843b: c3                    ret  
</code></pre>

<blockquote>
  <p><strong>Consideraciones:</strong> como <code>printf("Mensaje..." )</code> tiene como argumento un string fijo sin parámetros por una optimización del compilador se llama a la función <code>puts()</code> y no a <code>printf()</code>.</p>
</blockquote>

<p>Al llamar a una función con la instrucción <code>call</code>, después de haber apilado los parámetros en la pila en sentido inverso, se almacena la dirección de retorno (de la instrucción siguiente a <code>call</code> para saber a dónde retornar) y el valor del registro <code>ebp</code> usado en el marco actual. Si observamos el código en assembler de la <code>funcion_a</code>:</p>

<pre><code class="language-asm">080483fb &lt;funcion_a&gt;:

void funcion_a(int param_1, int param_2) {
 ;
 ; prólogo: apilo ebp del frame de main() para preservar su valor
 ; 
 80483fb: 55                    push   ebp
 ;
 ; prólogo: ahora ebp apunta al tope de la pila: será el nuevo ebp del frame de funcion_a
 ;
 80483fc: 89 e5                 mov    ebp,esp
 ;
 ; hago espacio para las variables locales
 ;
 80483fe: 83 ec 08              sub    esp,0x8                 
        
    ; int var_1 = 3;
    8048401: c7 45 fc 03 00 00 00  mov    [ebp-0x4],0x3        ; [ebp-0x4]: var_1
    
    ; int var_2 = 4;
    8048408: c7 45 f8 04 00 00 00  mov    [ebp-0x8],0x4        ; [ebp-0x8]: var_2
    ;
    ; apilo argumento de printf() y llamo a:
    ; printf("Mensaje en funcion_a()");
    ;
    804840f: 68 d0 84 04 08        push   0x80484d0            ; addr "Mensaje en funcion_a()"
    8048414: e8 b7 fe ff ff        call   80482d0 &lt;puts@plt&gt;   ; call printf("Mensaje en funcion_a()"); 
    ;
    ; desapilo argumento de printf()
    ;
    8048419: 83 c4 04              add    esp,0x4
}
 ;
 ;  epílogo: leave puede pensarse como: mov esp, ebp; pop ebp
 ;  mov esp, ebp: llevo tope de la pila al frame pointer. 
 ;  pop ebp: sobreescribo el frame pointer por el valor de ebp del frame de main(). 
 ;
 804841c: c9                    leave
 
 ;  epílogo: retorno a main() usando la dirección de retorno en el tope de la pila
 ;  
 804841d: c3                    ret    
</code></pre>

<h3 id="punto-de-entrada-del-binario-_start">Punto de entrada del binario _start</h3>

<p>Cuando trabajamos en GNU/Linux el formato de los ejecutables es ELF (Executable and Linking Format). Con <code>readelf -h</code> es posible ver los campos de la cabecera del archivo, que nos dan información relevante del binario:</p>
<pre><code class="language-bash">user@abos:~$ gcc -g -m32 -fno-stack-protector -fno-asynchronous-unwind-tables 
-mpreferred-stack-boundary=2 -o programa programa.c
user@abos:~$ readelf -h programa
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x80482d0
  ...
</code></pre>
<p>Esta información es útil ya que nos indica que es un binario de la arquitectura Intel x86 y nos informa el punto de entrada del programa (<code>Entry point adress: 0x80482d0</code>). Como podemos ver en el código desensamblado esa exacta dirección del punto de entrada corresponde a <code>_start</code> y no a <code>main</code>:</p>
<pre><code class="language-asm">user@abos:~$ objdump -M intel -d suma
080482d0 &lt;_start&gt;:
 80482d0: 31 ed                 xor    ebp,ebp
 80482d2: 5e                    pop    esi
 ...
 80482ec: e8 cf ff ff ff        call   80482c0 &lt;__libc_start_main@plt&gt;
 
080483d8 &lt;main&gt;:
 80483d8: 55                    push   ebp
 80483d9: 89 e5                 mov    ebp,esp
 ...
 80483ed: c9                    leave  
 80483ee: c3                    ret    
</code></pre>
<p>Efectivamente, la entrada al programa es <code>_start</code> que se encarga de llamar a funciones de inicialización y hace un llamado a <code>__libc_start_main</code> que -a su vez- se encarga de hacer el call a <code>main</code> con los parámetros correspondientes.   <br />
Cuando se hable del frame anterior a <code>main()</code> nos referiremos de manera simplificada al frame de <code>_start</code>.</p>

<h3 id="herramientas">Herramientas</h3>
<ol>
  <li><a href="../herramientas.md#compilador-gcc">Compilador GCC</a></li>
  <li><a href="../herramientas.md#objdump">Desensamblador OBJDUMP</a></li>
  <li><a href="../herramientas.md#debugger-gdb">Debugger GDB</a></li>
</ol>

<h3 id="práctica">Práctica</h3>
<p>Con los contenidos vistos hasta el momento es posible avanzar con <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/stack1.c">Stack 1</a>, <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/stack2.c">Stack 2</a> y <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/stack3.c">Stack 3</a>.    <br />
Y está disponible una práctica guiada para la <a href="/buffer-overflow/1-practica.html">resolución de Stack 1 a través del ataque “Smash the stack”</a>.</p>

<h3 id="material-consultado">Material consultado</h3>
<p>[1]. Tanenbaum, Andrew S. (2005). <em>Structured computer organization.</em></p>

<p>[2]. Intel Corporation. (Mayo de 2011). <em>Intel 64 and IA-32 Architectures Software Developer’s Manual: Combined volumes</em>. Disponible en: https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf</p>

<p>[3]. Younan, Y., Piessens, F., Joosen, W. (Sin fecha). <em>Protecting global and static variables from buffer overflow attacks</em>. Disponible en: http://fort-knox.org/files/globstat.pdf</p>

<p>[4]. Aleph One. (Noviembre de 1996). Smashing the Stack for Fun and Profit. <em>Phrack</em>, 7. Disponible en: http://phrack.org/issues/49/14.html</p>

<p>[5]. Liveoverflow.com. (2018). Disponible en: http://liveoverflow.com/</p>


</div>

    </div>

  </body>
</html>
