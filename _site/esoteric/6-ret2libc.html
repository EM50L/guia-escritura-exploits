<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
       &middot; Guía de exploits
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/guia-escritura-exploits/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/guia-escritura-exploits/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
 <!-- <div class="container sidebar-sticky">-->
  <div class="container sidebar">
    <div class="sidebar-about">
      <h1>
        <a href="/guia-escritura-exploits/">
          Guía de exploits
        </a>
      </h1>
      <!--<p class="lead"></p>-->
    </div>

    <nav class="sidebar-nav">

     <!-- <a class="sidebar-nav-item" href="/guia-escritura-exploits/">Home</a>-->

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/buffer-overflow/index.html">Buffer Overflow</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-introduccion.html">Nivel 1 | Teoría</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-practica.html">Nivel 1 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html">Nivel 2 | Shellcode</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-practica.html">Nivel 2 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-got.html">Nivel 3 | GOT</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-practica.html">Nivel 3 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/4-practica.html">Nivel 4 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/format-string/index.html">Format String</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-format-string.html">Nivel 5 | Format strings</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-practica.html">Nivel 5 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/esoteric/index.html">Esoteric</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-ret2libc.html">Nivel 6 | Return to libc</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-practica.html">Nivel 6 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/configuracion.html">Configuración</a>
        <a class="sidebar-nav-item" href="/guia-escritura-exploits/herramientas.html">Herramientas</a>


      <!--<a class="sidebar-nav-item" href="/archive/v2.1.0.zip">Descargar PDF</a>-->
      <a class="sidebar-nav-item" href="https://github.com/fundacion-sadosky/guia-escritura-exploits">Proyecto en GitHub</a>
    </nav>

    <p class="sidebar-nav-item footer">Basado en los <a href="https://github.com/gerasdf/InsecureProgramming/">abos de Gera</a></br> Teresa Alberto | STIC, Fundación Sadosky  </br> <a href="https://github.com/fundacion-sadosky/guia-escritura-exploits/blob/master/LICENSE">GNU GPL</a> | 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <!--<h1 class="page-title"></h1>-->
  <h1 id="ataque-return-to-libc">Ataque return to libc</h1>

<h2 id="habilitar-mitigacin-wx">Habilitar mitigación W^X</h2>
<p>Para presentar una serie de estrategias tradicionales de ataque a programas vulnerables se propuso <a href="../configuracion.md">deshabilitar configuraciones de seguridad</a> presentes en los sistemas operativos modernos, entre ellas la <a href="../configuracion.md#deshabilitar-mitigacion-wx">mitigacion W^X</a>: una política en relación a la memoria que impedía ejecutar código almacenado la pila. Gracias a ello fue posible inyectar un shellcode como string en la pila y ejecutarlo a través de una redirección de la dirección de retorno de una función por ejemplo.       <br />
En este punto <strong>se propone volver a habilitar la mitigación W^X habilitada, lo que nos obligará a crear estrategias de ataque más complejas.</strong></p>

<p><strong>IMPORTANTE</strong>:   <br />
Antes de avanzar es necesario habilitar la <a href="../configuracion.md#deshabilitar-mitigacion-wx">mitigación W^X</a>. Para eso el programa vulnerable ya no debe compilarse con el flag <code class="highlighter-rouge">-z exestack</code> que la deshabilitaba. A partir de ahora los programas vulnerables se compilan de la siguiente manera:</p>
<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">gcc</span><span class="kv"> -m32 -fno-stack-protector -ggdb -mpreferred-stack-boundary=2 -o e1 e1.c
</span></code></pre></div>

<h2 id="return-oriented-programming-rop">Return-oriented programming (ROP)</h2>
<p>Se asume un escenario donde no es posible la ejecución de código almacenado en la pila. El objetivo de este nivel va a ser lograr el control de la pila con el objetivo de ejecutar código existente (como puede ser una función de <code class="highlighter-rouge">libc</code>) sin inyectar código propio que no podría ejecutarse.</p>

<h3 id="return-to-libc">Return-to-libc</h3>
<p>Una estrategia para contrarrestar la mitigación W^X es ejecutar código que no se encuentre en la pila sino en un sector de la memoria que sea ejecutable, por ejemplo en <code class="highlighter-rouge">libc</code>. Esta táctica se denomina <strong>return-to-libc</strong> ya que el código utilizado para vulnerar el programa son funciones dentro de esta libreria.   <br />
Entonces así como se modificó la dirección de retorno para la ejecución de código arbitrario dentro de la pila, es posible sobreescribir esta dirección pero para que apunte a la biblioteca <code class="highlighter-rouge">libc</code>, que cuenta con funciones muy útiles como <code class="highlighter-rouge">system()</code> para, por ejemplo, obtener una shell.</p>

<p><img src="imagenes/ret-2-libc.png" alt="ret2libc" /></p>

<p>El retorno a libc es parte de un tipo de ataque más amplio que se denomina <strong>Return-oriented programming</strong> (o <strong>ROP</strong>). La estrategia de ROP en términos generales se trata de concatenar secuencias de instrucciones ya existentes en el programa vulnerable, denominadas <strong>gadgets</strong>. Estos gadgets al ser ejecutados logran el comportamiento deseado por el atacante, al modificar el estado de los registros y realizar llamadas a sistema que permitan tomar el control del programa vulnerable. Cuando esas instrucciones son parte de <code class="highlighter-rouge">libc</code> es que estamos frente a un ataque del tipo <code class="highlighter-rouge">return-to-libc</code>.</p>

<h4 id="funcin-system">Función system()</h4>
<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">man</span><span class="kv"> system
</span>NAME
       system - execute a shell command

SYNOPSIS
       #include &lt;stdlib.h&gt;

       int system(const char *command);
</code></pre></div>
<p>Es una función de la biblioteca <code class="highlighter-rouge">libc</code>, generalmente utilizada en este tipo de ataques, que ejecuta el programa o comando indicado. Por ejemplo, <code class="highlighter-rouge">system("ls")</code> ejecuta el comando <code class="highlighter-rouge">ls</code> que lista el contenido del directorio actual.         <br />
Su potencialidad en la escritura de exploits se evidencia cuando se llama a esa función con el argumento <code class="highlighter-rouge">system("/bin/sh")</code>. Su funcionamiento se observa en el siguiente programa de ejemplo:</p>
<div class="language-c highlighter-rouge"><pre class="codehilite"><code><span class="n">include</span> <span class="o">&lt;</span><span class="n">stdlib</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(){</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">);</span>
<span class="p">}</span> 
</code></pre></div>
<p>Lo compilamos y ejecutamos:</p>
<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">gcc</span><span class="kv"> sys.c -o sys
</span><span class="w">user@abos:~$ </span><span class="nc">sudo</span><span class="kv"> chown root ./sys; sudo chmod u+s ./sys                      ; root owner &amp; setuid
</span><span class="w">user@abos:~$ </span><span class="nc">./sys</span><span class="kv">
</span><span class="ni"># </span><span class="nc">whoami</span><span class="kv">
</span>root
<span class="ni"># </span><span class="nc">id</span><span class="kv">
</span>uid=1001(user) gid=1001(user) euid=0(root) groups=1001(user),27(sudo)
<span class="ni"># </span><span class="kv">
</span></code></pre></div>
<p>Efectivamente logramos una shell. Esta shell tiene privilegios de root gracias a que definimos su setuid.    <br />
En este punto nos interesa ver el layout de la pila en el llamado a <code class="highlighter-rouge">system("/bin/sh")</code>, por lo que desensamblamos el ejecutable:</p>
<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">gdb</span><span class="kv"> sys
</span><span class="w">user@abos:~$ </span><span class="nc">disassemble</span><span class="kv"> main
</span>&gt;&gt;&gt; disassemble main
Dump of assembler code for function main:
void main(){
   0x080483fb &lt;+0&gt;:  push   ebp
   0x080483fc &lt;+1&gt;:  mov    ebp,esp

  system("/bin/sh");
   0x080483fe &lt;+3&gt;:  push   0x80484a0              ; "/bin/sh"
   0x08048403 &lt;+8&gt;:  call   0x80482d0 &lt;system@plt&gt;
   0x08048408 &lt;+13&gt;: add    esp,0x4
  }
   0x0804840b &lt;+16&gt;: leave  
   0x0804840c &lt;+17&gt;: ret    
End of assembler dump.
&gt;&gt;&gt; x/s 0x80484a0
0x80484a0:  "/bin/sh"
</code></pre></div>

<p>Vemos que, antes del llamado a <code class="highlighter-rouge">system</code>, se apila la dirección de <code class="highlighter-rouge">/bin/sh</code> con la instrucción <code class="highlighter-rouge">push   0x80484a0</code>.    <br />
En términos generales la estrategia de <strong>return-to-libc</strong> apunta a sobreescribir la dirección de retorno de una función para que apunte a la función <code class="highlighter-rouge">system</code> dentro de <code class="highlighter-rouge">libc</code> con el string “/bin/sh” como argumento. Para que el llamado a <code class="highlighter-rouge">system</code> nos devuelva una shell es necesario -previo al <code class="highlighter-rouge">call</code>- construir un layout de la pila que simule el llamado a esa función con el argumento “<code class="highlighter-rouge">/bin/sh</code>”, tal como indica el gráfico a continuación:</p>

<p><img src="imagenes/llamado-sys.png" alt="pila en llamado a sys" /></p>

<p>Ese layout de la pila necesario se podría construir aprovechando una vulnerabilidad de desbordamiento de un búfer o del tipo format string.</p>

<blockquote>
  <p><strong>Consideraciones:</strong>   <br />
Es importante tener en cuenta que la técnica de <a href="../configuracion.md#deshabilitar-aslr">aleatoriedad en el espacio de direcciones (ASLR en inglés)</a> dispone de forma aleatoria no sólo las direcciones de la pila y el heap sino también de las librerias compartidas.    <br />
Con esta mitigación funcionando no sería posible un ataque <code class="highlighter-rouge">return-to-libc</code> tal como lo planteamos porque no podríamos utilizar la dirección de <code class="highlighter-rouge">libc</code> (y dentro de ella de <code class="highlighter-rouge">system()</code>) de manera consistente.</p>
</blockquote>

<p>En este punto, no nos preocupamos aún por el ASLR, es por ello que lo deshabilitamos con:</p>
<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">sudo</span><span class="kv"> sysctl -w kernel.randomize_va_space=0
</span>kernel.randomize_va_space=0
</code></pre></div>

<h3 id="prctica">Práctica</h3>
<p>Con los contenidos vistos hasta el momento es posible avanzar con <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/e1.c">E 1</a>.</p>

<p>Y está disponible una práctica guiada para la <a href="6-practica.md">resolución de E 1 a través de un ataque <em>return to libc</em></a>.</p>


</div>

    </div>

  </body>
</html>
